/**
 * Enhanced Stock Chart Component
 * Provides candlestick charts, technical indicators, and interactive features
 */

class StockChart {
    constructor(canvasId, options = {}) {
        this.canvasId = canvasId;
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas?.getContext('2d');
        this.chart = null;
        this.currentSymbol = null;
        this.currentTimeframe = '1W';
        this.chartType = 'candlestick'; // candlestick, line, area
        this.indicators = new Set(); // Technical indicators
        this.isLoading = false;
        
        // Default options
        this.options = {
            responsive: true,
            maintainAspectRatio: false,
            showVolume: true,
            showIndicators: true,
            enableZoom: true,
            enablePan: true,
            ...options
        };
        
        this.init();
    }

    init() {
        if (!this.canvas || !this.ctx) {
            console.error('Chart canvas not found:', this.canvasId);
            return;
        }
        
        this.initChart();
        this.bindEvents();
    }

    /**
     * Initialize the Chart.js instance with candlestick configuration
     */
    initChart() {
        const config = {
            type: 'candlestick',
            data: {
                datasets: [{
                    label: 'Price',
                    data: [],
                    borderColor: {
                        up: 'var(--color-success)',
                        down: 'var(--color-error)',
                        unchanged: 'var(--color-secondary)'
                    },
                    backgroundColor: {
                        up: 'rgba(var(--color-success-rgb), 0.8)',
                        down: 'rgba(var(--color-error-rgb), 0.8)',
                        unchanged: 'rgba(var(--color-secondary-rgb), 0.8)'
                    }
                }]
            },
            options: {
                responsive: this.options.responsive,
                maintainAspectRatio: this.options.maintainAspectRatio,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'var(--bg-card)',
                        titleColor: 'var(--text-primary)',
                        bodyColor: 'var(--text-primary)',
                        borderColor: 'var(--border-color)',
                        borderWidth: 1,
                        cornerRadius: 8,
                        displayColors: false,
                        callbacks: {
                            title: (context) => {
                                const date = new Date(context[0].parsed.x);
                                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                            },
                            label: (context) => {
                                const data = context.parsed;
                                return [
                                    `Open: ₹${data.o?.toFixed(2) || 'N/A'}`,
                                    `High: ₹${data.h?.toFixed(2) || 'N/A'}`,
                                    `Low: ₹${data.l?.toFixed(2) || 'N/A'}`,
                                    `Close: ₹${data.c?.toFixed(2) || 'N/A'}`
                                ];
                            }
                        }
                    },
                    zoom: this.options.enableZoom ? {
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                        },
                        pan: {
                            enabled: this.options.enablePan,
                            mode: 'x',
                        }
                    } : undefined
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            displayFormats: {
                                day: 'MMM dd',
                                week: 'MMM dd',
                                month: 'MMM yyyy'
                            }
                        },
                        grid: {
                            color: 'var(--border-color-light)',
                            drawOnChartArea: true,
                            drawTicks: true
                        },
                        ticks: {
                            color: 'var(--text-secondary)',
                            maxTicksLimit: 8
                        }
                    },
                    y: {
                        type: 'linear',
                        position: 'right',
                        grid: {
                            color: 'var(--border-color-light)',
                            drawOnChartArea: true,
                            drawTicks: true
                        },
                        ticks: {
                            color: 'var(--text-secondary)',
                            callback: function(value) {
                                return '₹' + value.toFixed(2);
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                animation: {
                    duration: 750,
                    easing: 'easeInOutQuart'
                }
            }
        };

        // Add volume chart if enabled
        if (this.options.showVolume) {
            config.data.datasets.push({
                label: 'Volume',
                type: 'bar',
                data: [],
                backgroundColor: 'rgba(var(--color-primary-rgb), 0.3)',
                borderColor: 'var(--color-primary)',
                borderWidth: 1,
                yAxisID: 'volume'
            });

            config.options.scales.volume = {
                type: 'linear',
                position: 'left',
                max: function(context) {
                    const volumes = context.chart.data.datasets[1].data;
                    const maxVolume = Math.max(...volumes.map(d => d.y || 0));
                    return maxVolume * 4; // Scale volume to 1/4 of chart height
                },
                grid: {
                    display: false
                },
                ticks: {
                    display: false
                }
            };
        }

        this.chart = new Chart(this.ctx, config);
    }

    /**
     * Bind chart events and interactions
     */
    bindEvents() {
        // Handle canvas resize
        const resizeObserver = new ResizeObserver(() => {
            if (this.chart) {
                this.chart.resize();
            }
        });
        resizeObserver.observe(this.canvas);

        // Handle chart click events
        this.canvas.addEventListener('click', (event) => {
            const points = this.chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
            if (points.length) {
                const firstPoint = points[0];
                const datasetIndex = firstPoint.datasetIndex;
                const index = firstPoint.index;
                const data = this.chart.data.datasets[datasetIndex].data[index];
                this.onDataPointClick(data, index);
            }
        });
    }

    /**
     * Load chart data for a specific symbol and timeframe
     */
    async loadData(symbol, timeframe = '1W') {
        if (this.isLoading) return;
        
        this.isLoading = true;
        this.currentSymbol = symbol;
        this.currentTimeframe = timeframe;
        
        this.showLoading();
        
        try {
            this.hideError(); // Hide any previous errors
            
            // Try to fetch real data first
            const response = await fetch(`/api/chart/${symbol}?timeframe=${timeframe}`);
            
            let chartData;
            if (response.ok) {
                chartData = await response.json();
            } else if (response.status === 404) {
                // API endpoint not found, use mock data
                console.info('Chart API not available, using mock data');
                chartData = this.generateMockOHLCData(symbol, timeframe);
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            this.updateChart(chartData);
            this.hideLoading();
            
        } catch (error) {
            console.warn('Failed to load chart data:', error);
            this.hideLoading();
            
            // Try to use mock data as fallback
            try {
                const mockData = this.generateMockOHLCData(symbol, timeframe);
                this.updateChart(mockData);
                console.info('Using mock chart data for demonstration');
            } catch (mockError) {
                console.error('Failed to generate mock data:', mockError);
                this.showError('Unable to load chart data');
            }
        } finally {
            this.isLoading = false;
        }
    }

    /**
     * Generate mock OHLC data for demonstration
     */
    generateMockOHLCData(symbol, timeframe) {
        const basePrice = 100 + Math.random() * 400; // Random base price between 100-500
        const periods = this.getPeriodsForTimeframe(timeframe);
        const data = [];
        const volumeData = [];
        
        let currentPrice = basePrice;
        
        for (let i = 0; i < periods; i++) {
            const date = this.getDateForPeriod(i, timeframe);
            
            // Generate realistic OHLC data
            const open = currentPrice;
            const volatility = 0.02 + Math.random() * 0.03; // 2-5% volatility
            const direction = Math.random() > 0.5 ? 1 : -1;
            const change = open * volatility * direction;
            
            const high = Math.max(open, open + change) + (Math.random() * open * 0.01);
            const low = Math.min(open, open + change) - (Math.random() * open * 0.01);
            const close = open + change + (Math.random() - 0.5) * open * 0.005;
            
            // Ensure high is highest and low is lowest
            const finalHigh = Math.max(high, open, close);
            const finalLow = Math.min(low, open, close);
            
            data.push({
                x: date.getTime(),
                o: parseFloat(open.toFixed(2)),
                h: parseFloat(finalHigh.toFixed(2)),
                l: parseFloat(finalLow.toFixed(2)),
                c: parseFloat(close.toFixed(2))
            });
            
            // Generate volume data
            const baseVolume = 100000 + Math.random() * 500000;
            const volumeMultiplier = Math.abs(change) / open * 10 + 1; // Higher volume on bigger moves
            volumeData.push({
                x: date.getTime(),
                y: Math.floor(baseVolume * volumeMultiplier)
            });
            
            currentPrice = close;
        }
        
        return {
            symbol,
            timeframe,
            ohlc: data,
            volume: volumeData
        };
    }

    /**
     * Get number of periods for timeframe
     */
    getPeriodsForTimeframe(timeframe) {
        const periods = {
            '1D': 24,    // 24 hours
            '1W': 7,     // 7 days
            '1M': 30,    // 30 days
            '3M': 90,    // 90 days
            '1Y': 252,   // Trading days in a year
            '5Y': 1260   // 5 years of trading days
        };
        return periods[timeframe] || 30;
    }

    /**
     * Get date for specific period based on timeframe
     */
    getDateForPeriod(index, timeframe) {
        const now = new Date();
        const date = new Date(now);
        
        switch (timeframe) {
            case '1D':
                date.setHours(date.getHours() - (23 - index));
                break;
            case '1W':
                date.setDate(date.getDate() - (6 - index));
                break;
            case '1M':
                date.setDate(date.getDate() - (29 - index));
                break;
            case '3M':
                date.setDate(date.getDate() - (89 - index));
                break;
            case '1Y':
                date.setDate(date.getDate() - (251 - index));
                break;
            case '5Y':
                date.setDate(date.getDate() - (1259 - index));
                break;
            default:
                date.setDate(date.getDate() - (29 - index));
        }
        
        return date;
    }

    /**
     * Update chart with new data
     */
    updateChart(chartData) {
        if (!this.chart || !chartData) return;
        
        // Update OHLC data
        this.chart.data.datasets[0].data = chartData.ohlc || [];
        
        // Update volume data if available
        if (this.options.showVolume && chartData.volume && this.chart.data.datasets[1]) {
            this.chart.data.datasets[1].data = chartData.volume;
        }
        
        // Update time scale based on timeframe
        this.updateTimeScale(chartData.timeframe);
        
        // Animate chart update
        this.chart.update('active');
        
        // Trigger custom event
        this.onChartUpdated(chartData);
    }

    /**
     * Update time scale configuration based on timeframe
     */
    updateTimeScale(timeframe) {
        if (!this.chart) return;
        
        const timeConfig = {
            '1D': { unit: 'hour', displayFormat: 'HH:mm' },
            '1W': { unit: 'day', displayFormat: 'MMM dd' },
            '1M': { unit: 'day', displayFormat: 'MMM dd' },
            '3M': { unit: 'week', displayFormat: 'MMM dd' },
            '1Y': { unit: 'month', displayFormat: 'MMM yyyy' },
            '5Y': { unit: 'year', displayFormat: 'yyyy' }
        };
        
        const config = timeConfig[timeframe] || timeConfig['1M'];
        
        this.chart.options.scales.x.time.unit = config.unit;
        this.chart.options.scales.x.time.displayFormats[config.unit] = config.displayFormat;
    }

    /**
     * Change chart type (candlestick, line, area)
     */
    setChartType(type) {
        if (!this.chart) return;
        
        this.chartType = type;
        
        switch (type) {
            case 'line':
                this.chart.config.type = 'line';
                this.chart.data.datasets[0] = {
                    ...this.chart.data.datasets[0],
                    type: 'line',
                    borderColor: 'var(--color-primary)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    data: this.chart.data.datasets[0].data.map(d => ({
                        x: d.x,
                        y: d.c // Use close price for line chart
                    }))
                };
                break;
                
            case 'area':
                this.chart.config.type = 'line';
                this.chart.data.datasets[0] = {
                    ...this.chart.data.datasets[0],
                    type: 'line',
                    borderColor: 'var(--color-primary)',
                    backgroundColor: 'rgba(var(--color-primary-rgb), 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    data: this.chart.data.datasets[0].data.map(d => ({
                        x: d.x,
                        y: d.c // Use close price for area chart
                    }))
                };
                break;
                
            case 'candlestick':
            default:
                this.chart.config.type = 'candlestick';
                // Restore original candlestick configuration
                this.chart.data.datasets[0] = {
                    label: 'Price',
                    data: this.chart.data.datasets[0].data,
                    borderColor: {
                        up: 'var(--color-success)',
                        down: 'var(--color-error)',
                        unchanged: 'var(--color-secondary)'
                    },
                    backgroundColor: {
                        up: 'rgba(var(--color-success-rgb), 0.8)',
                        down: 'rgba(var(--color-error-rgb), 0.8)',
                        unchanged: 'rgba(var(--color-secondary-rgb), 0.8)'
                    }
                };
                break;
        }
        
        this.chart.update('none');
    }

    /**
     * Add technical indicator
     */
    addIndicator(indicator) {
        this.indicators.add(indicator);
        
        switch (indicator) {
            case 'sma20':
                this.addMovingAverage(20, 'SMA 20', '#f39c12');
                break;
            case 'sma50':
                this.addMovingAverage(50, 'SMA 50', '#3498db');
                break;
            case 'ema20':
                this.addExponentialMovingAverage(20, 'EMA 20', '#2ecc71');
                break;
            case 'bollinger':
                this.addBollingerBands(20, 2, 'Bollinger Bands');
                break;
            case 'rsi':
                this.addRSI(14, 'RSI (14)');
                break;
            case 'macd':
                this.addMACD(12, 26, 9, 'MACD');
                break;
        }
    }

    /**
     * Remove technical indicator
     */
    removeIndicator(indicator) {
        this.indicators.delete(indicator);
        
        // Remove datasets associated with this indicator
        const indicatorLabels = this.getIndicatorLabels(indicator);
        
        for (let i = this.chart.data.datasets.length - 1; i >= 0; i--) {
            const dataset = this.chart.data.datasets[i];
            if (indicatorLabels.includes(dataset.label)) {
                this.chart.data.datasets.splice(i, 1);
            }
        }
        
        this.chart.update('none');
    }

    /**
     * Get all dataset labels for an indicator
     */
    getIndicatorLabels(indicator) {
        const labelMap = {
            'sma20': ['SMA 20'],
            'sma50': ['SMA 50'],
            'ema20': ['EMA 20'],
            'bollinger': ['Bollinger Upper', 'Bollinger Lower', 'Bollinger SMA'],
            'rsi': ['RSI (14)'],
            'macd': ['MACD', 'MACD Signal', 'MACD Histogram']
        };
        
        return labelMap[indicator] || [indicator];
    }

    /**
     * Add simple moving average
     */
    addMovingAverage(period, label, color) {
        const ohlcData = this.chart.data.datasets[0].data;
        const smaData = this.calculateSMA(ohlcData, period);
        
        this.chart.data.datasets.push({
            label: label,
            type: 'line',
            data: smaData,
            borderColor: color,
            backgroundColor: 'transparent',
            borderWidth: 1,
            fill: false,
            pointRadius: 0,
            tension: 0.1
        });
        
        this.chart.update('none');
    }

    /**
     * Add exponential moving average
     */
    addExponentialMovingAverage(period, label, color) {
        const ohlcData = this.chart.data.datasets[0].data;
        const emaData = this.calculateEMA(ohlcData, period);
        
        this.chart.data.datasets.push({
            label: label,
            type: 'line',
            data: emaData,
            borderColor: color,
            backgroundColor: 'transparent',
            borderWidth: 1,
            fill: false,
            pointRadius: 0,
            tension: 0.1
        });
        
        this.chart.update('none');
    }

    /**
     * Calculate Simple Moving Average
     */
    calculateSMA(data, period) {
        const smaData = [];
        
        for (let i = period - 1; i < data.length; i++) {
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += data[i - j].c; // Use close price
            }
            const average = sum / period;
            
            smaData.push({
                x: data[i].x,
                y: average
            });
        }
        
        return smaData;
    }

    /**
     * Calculate Exponential Moving Average
     */
    calculateEMA(data, period) {
        const emaData = [];
        const multiplier = 2 / (period + 1);
        
        // Start with SMA for first value
        let ema = data.slice(0, period).reduce((sum, d) => sum + d.c, 0) / period;
        emaData.push({
            x: data[period - 1].x,
            y: ema
        });
        
        // Calculate EMA for remaining values
        for (let i = period; i < data.length; i++) {
            ema = (data[i].c * multiplier) + (ema * (1 - multiplier));
            emaData.push({
                x: data[i].x,
                y: ema
            });
        }
        
        return emaData;
    }

    /**
     * Add Bollinger Bands
     */
    addBollingerBands(period, stdDev, label) {
        const ohlcData = this.chart.data.datasets[0].data;
        const bollingerData = this.calculateBollingerBands(ohlcData, period, stdDev);
        
        // Add upper band
        this.chart.data.datasets.push({
            label: 'Bollinger Upper',
            type: 'line',
            data: bollingerData.upper,
            borderColor: '#e74c3c',
            backgroundColor: 'transparent',
            borderWidth: 1,
            fill: false,
            pointRadius: 0,
            tension: 0.1
        });
        
        // Add lower band
        this.chart.data.datasets.push({
            label: 'Bollinger Lower',
            type: 'line',
            data: bollingerData.lower,
            borderColor: '#e74c3c',
            backgroundColor: 'rgba(231, 76, 60, 0.1)',
            borderWidth: 1,
            fill: '-1', // Fill between upper and lower
            pointRadius: 0,
            tension: 0.1
        });
        
        // Add middle line (SMA)
        this.chart.data.datasets.push({
            label: 'Bollinger SMA',
            type: 'line',
            data: bollingerData.middle,
            borderColor: '#95a5a6',
            backgroundColor: 'transparent',
            borderWidth: 1,
            fill: false,
            pointRadius: 0,
            tension: 0.1,
            borderDash: [5, 5]
        });
        
        this.chart.update('none');
    }

    /**
     * Calculate Bollinger Bands
     */
    calculateBollingerBands(data, period, stdDev) {
        const upperBand = [];
        const lowerBand = [];
        const middleBand = [];
        
        for (let i = period - 1; i < data.length; i++) {
            // Calculate SMA
            let sum = 0;
            for (let j = 0; j < period; j++) {
                sum += data[i - j].c;
            }
            const sma = sum / period;
            
            // Calculate standard deviation
            let variance = 0;
            for (let j = 0; j < period; j++) {
                variance += Math.pow(data[i - j].c - sma, 2);
            }
            const standardDeviation = Math.sqrt(variance / period);
            
            const upper = sma + (stdDev * standardDeviation);
            const lower = sma - (stdDev * standardDeviation);
            
            upperBand.push({ x: data[i].x, y: upper });
            lowerBand.push({ x: data[i].x, y: lower });
            middleBand.push({ x: data[i].x, y: sma });
        }
        
        return { upper: upperBand, lower: lowerBand, middle: middleBand };
    }

    /**
     * Add RSI indicator
     */
    addRSI(period, label) {
        const ohlcData = this.chart.data.datasets[0].data;
        const rsiData = this.calculateRSI(ohlcData, period);
        
        // Create a separate chart or overlay for RSI
        // For now, we'll normalize RSI to fit on the price chart
        const normalizedRSI = rsiData.map(point => ({
            x: point.x,
            y: point.y // RSI is already 0-100, we might want to scale it
        }));
        
        this.chart.data.datasets.push({
            label: label,
            type: 'line',
            data: normalizedRSI,
            borderColor: '#9b59b6',
            backgroundColor: 'transparent',
            borderWidth: 2,
            fill: false,
            pointRadius: 0,
            tension: 0.1,
            yAxisID: 'rsi'
        });
        
        // Add RSI scale if it doesn't exist
        if (!this.chart.options.scales.rsi) {
            this.chart.options.scales.rsi = {
                type: 'linear',
                position: 'left',
                min: 0,
                max: 100,
                grid: {
                    display: false
                },
                ticks: {
                    color: 'var(--text-secondary)',
                    callback: function(value) {
                        return value;
                    }
                }
            };
        }
        
        this.chart.update('none');
    }

    /**
     * Calculate RSI
     */
    calculateRSI(data, period) {
        const rsiData = [];
        const gains = [];
        const losses = [];
        
        // Calculate initial gains and losses
        for (let i = 1; i < data.length; i++) {
            const change = data[i].c - data[i - 1].c;
            gains.push(change > 0 ? change : 0);
            losses.push(change < 0 ? Math.abs(change) : 0);
        }
        
        // Calculate RSI
        for (let i = period - 1; i < gains.length; i++) {
            let avgGain, avgLoss;
            
            if (i === period - 1) {
                // First RSI calculation
                avgGain = gains.slice(0, period).reduce((sum, gain) => sum + gain, 0) / period;
                avgLoss = losses.slice(0, period).reduce((sum, loss) => sum + loss, 0) / period;
            } else {
                // Smoothed averages
                const prevAvgGain = rsiData[i - period].avgGain;
                const prevAvgLoss = rsiData[i - period].avgLoss;
                avgGain = (prevAvgGain * (period - 1) + gains[i]) / period;
                avgLoss = (prevAvgLoss * (period - 1) + losses[i]) / period;
            }
            
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            
            rsiData.push({
                x: data[i + 1].x,
                y: rsi,
                avgGain: avgGain,
                avgLoss: avgLoss
            });
        }
        
        return rsiData;
    }

    /**
     * Add MACD indicator
     */
    addMACD(fastPeriod, slowPeriod, signalPeriod, label) {
        const ohlcData = this.chart.data.datasets[0].data;
        const macdData = this.calculateMACD(ohlcData, fastPeriod, slowPeriod, signalPeriod);
        
        // Add MACD line
        this.chart.data.datasets.push({
            label: 'MACD',
            type: 'line',
            data: macdData.macd,
            borderColor: '#3498db',
            backgroundColor: 'transparent',
            borderWidth: 2,
            fill: false,
            pointRadius: 0,
            tension: 0.1,
            yAxisID: 'macd'
        });
        
        // Add Signal line
        this.chart.data.datasets.push({
            label: 'MACD Signal',
            type: 'line',
            data: macdData.signal,
            borderColor: '#e74c3c',
            backgroundColor: 'transparent',
            borderWidth: 1,
            fill: false,
            pointRadius: 0,
            tension: 0.1,
            yAxisID: 'macd'
        });
        
        // Add Histogram
        this.chart.data.datasets.push({
            label: 'MACD Histogram',
            type: 'bar',
            data: macdData.histogram,
            backgroundColor: 'rgba(52, 152, 219, 0.3)',
            borderColor: '#3498db',
            borderWidth: 1,
            yAxisID: 'macd'
        });
        
        // Add MACD scale if it doesn't exist
        if (!this.chart.options.scales.macd) {
            this.chart.options.scales.macd = {
                type: 'linear',
                position: 'left',
                grid: {
                    display: false
                },
                ticks: {
                    color: 'var(--text-secondary)'
                }
            };
        }
        
        this.chart.update('none');
    }

    /**
     * Calculate MACD
     */
    calculateMACD(data, fastPeriod, slowPeriod, signalPeriod) {
        const fastEMA = this.calculateEMA(data, fastPeriod);
        const slowEMA = this.calculateEMA(data, slowPeriod);
        
        const macdLine = [];
        const startIndex = Math.max(fastPeriod, slowPeriod) - 1;
        
        // Calculate MACD line
        for (let i = 0; i < Math.min(fastEMA.length, slowEMA.length); i++) {
            const macdValue = fastEMA[i].y - slowEMA[i].y;
            macdLine.push({
                x: fastEMA[i].x,
                y: macdValue
            });
        }
        
        // Calculate Signal line (EMA of MACD)
        const signalLine = this.calculateEMA(macdLine, signalPeriod);
        
        // Calculate Histogram
        const histogram = [];
        for (let i = 0; i < signalLine.length; i++) {
            const macdIndex = macdLine.findIndex(m => m.x === signalLine[i].x);
            if (macdIndex !== -1) {
                histogram.push({
                    x: signalLine[i].x,
                    y: macdLine[macdIndex].y - signalLine[i].y
                });
            }
        }
        
        return {
            macd: macdLine,
            signal: signalLine,
            histogram: histogram
        };
    }

    /**
     * Show loading state
     */
    showLoading() {
        const container = this.canvas.parentElement;
        const loadingEl = container.querySelector('.chart-loading');
        if (loadingEl) {
            loadingEl.style.display = 'flex';
        }
    }

    /**
     * Hide loading state
     */
    hideLoading() {
        const container = this.canvas.parentElement;
        const loadingEl = container.querySelector('.chart-loading');
        if (loadingEl) {
            loadingEl.style.display = 'none';
        }
    }

    /**
     * Show error state
     */
    showError(message = 'Failed to load chart data') {
        const container = this.canvas.parentElement;
        let errorEl = container.querySelector('.chart-error');
        
        if (!errorEl) {
            errorEl = document.createElement('div');
            errorEl.className = 'chart-error';
            errorEl.innerHTML = `
                <div class="error-content">
                    <i class="fas fa-exclamation-triangle error-icon"></i>
                    <div class="error-message">${message}</div>
                    <button class="btn btn-sm btn-outline-primary retry-btn">
                        <i class="fas fa-redo"></i> Retry
                    </button>
                </div>
            `;
            container.appendChild(errorEl);
            
            // Bind retry button
            const retryBtn = errorEl.querySelector('.retry-btn');
            retryBtn.addEventListener('click', () => {
                this.hideError();
                if (this.currentSymbol) {
                    this.loadData(this.currentSymbol, this.currentTimeframe);
                }
            });
        }
        
        errorEl.style.display = 'flex';
    }

    /**
     * Hide error state
     */
    hideError() {
        const container = this.canvas.parentElement;
        const errorEl = container.querySelector('.chart-error');
        if (errorEl) {
            errorEl.style.display = 'none';
        }
    }

    /**
     * Reset zoom to fit all data
     */
    resetZoom() {
        if (this.chart && this.chart.resetZoom) {
            this.chart.resetZoom();
        }
    }

    /**
     * Destroy chart instance
     */
    destroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = null;
        }
    }

    /**
     * Enable real-time updates
     */
    enableRealTimeUpdates(interval = 30000) { // 30 seconds default
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        
        this.updateInterval = setInterval(() => {
            if (this.currentSymbol && !this.isLoading) {
                this.updateRealTimeData();
            }
        }, interval);
    }

    /**
     * Disable real-time updates
     */
    disableRealTimeUpdates() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }

    /**
     * Update chart with real-time data
     */
    async updateRealTimeData() {
        try {
            const response = await fetch(`/api/realtime/${this.currentSymbol}`);
            
            if (response.ok) {
                const realtimeData = await response.json();
                this.updateLatestDataPoint(realtimeData);
            } else {
                // Simulate real-time update with mock data
                this.simulateRealTimeUpdate();
            }
        } catch (error) {
            console.warn('Real-time update failed:', error);
            // Fallback to simulated update
            this.simulateRealTimeUpdate();
        }
    }

    /**
     * Update the latest data point with new real-time data
     */
    updateLatestDataPoint(realtimeData) {
        if (!this.chart || !this.chart.data.datasets[0].data.length) return;
        
        const dataset = this.chart.data.datasets[0];
        const lastIndex = dataset.data.length - 1;
        const lastDataPoint = dataset.data[lastIndex];
        
        // Update the last data point with new real-time data
        if (realtimeData.timestamp > lastDataPoint.x) {
            // Add new data point
            dataset.data.push({
                x: realtimeData.timestamp,
                o: realtimeData.open,
                h: realtimeData.high,
                l: realtimeData.low,
                c: realtimeData.close
            });
        } else {
            // Update existing data point
            lastDataPoint.h = Math.max(lastDataPoint.h, realtimeData.high);
            lastDataPoint.l = Math.min(lastDataPoint.l, realtimeData.low);
            lastDataPoint.c = realtimeData.close;
        }
        
        // Update volume if available
        if (this.options.showVolume && this.chart.data.datasets[1] && realtimeData.volume) {
            const volumeDataset = this.chart.data.datasets[1];
            if (volumeDataset.data.length > lastIndex) {
                volumeDataset.data[lastIndex].y = realtimeData.volume;
            }
        }
        
        // Animate the update
        this.chart.update('active');
        
        // Trigger update event
        this.onRealTimeUpdate(realtimeData);
    }

    /**
     * Simulate real-time updates for demonstration
     */
    simulateRealTimeUpdate() {
        if (!this.chart || !this.chart.data.datasets[0].data.length) return;
        
        const dataset = this.chart.data.datasets[0];
        const lastDataPoint = dataset.data[dataset.data.length - 1];
        
        // Simulate price movement
        const volatility = 0.005; // 0.5% volatility
        const direction = Math.random() > 0.5 ? 1 : -1;
        const change = lastDataPoint.c * volatility * direction * Math.random();
        
        const newPrice = lastDataPoint.c + change;
        
        // Update the last data point
        lastDataPoint.h = Math.max(lastDataPoint.h, newPrice);
        lastDataPoint.l = Math.min(lastDataPoint.l, newPrice);
        lastDataPoint.c = newPrice;
        
        // Add subtle animation
        this.chart.update('none');
        
        // Trigger update event
        this.onRealTimeUpdate({
            symbol: this.currentSymbol,
            price: newPrice,
            change: change,
            timestamp: Date.now()
        });
    }

    /**
     * Event handlers (can be overridden)
     */
    onDataPointClick(data, index) {
        // Override this method to handle data point clicks
        console.log('Data point clicked:', data, index);
    }

    onChartUpdated(chartData) {
        // Override this method to handle chart updates
        console.log('Chart updated:', chartData);
    }

    onRealTimeUpdate(realtimeData) {
        // Override this method to handle real-time updates
        console.log('Real-time update:', realtimeData);
    }
}

// Export for use in other modules
window.StockChart = StockChart;
// Dashboard functionality for portfolio summary cards and holdings
class DashboardManager {
    constructor() {
        this.portfolioData = {
            totalHoldings: 0,
            currentValue: 0,
            profitLoss: 0,
            availableFunds: 0,
            userRank: 1,
            totalParticipants: 1
        };
        
        this.animationDuration = 1000; // 1 second
        this.updateInterval = 5000; // 5 seconds
        this.rankUpdateInterval = 30000; // 30 seconds
        
        // Initialize error handler and data manager integration
        this.errorHandler = window.errorHandler;
        this.dataManager = null;
        this.loadingManager = window.loadingStateManager;
        
        // Retry tracking
        this.retryAttempts = new Map();
        this.maxRetries = 3;
        
        this.init();
    }
    
    init() {
        this.initializeManagers();
        this.setupEventListeners();
        this.setupMobileEnhancements();
        this.setupErrorRecovery();
        this.loadInitialData();
        this.startPeriodicUpdates();
    }
    
    /**
     * Initialize error handler and data manager
     */
    initializeManagers() {
        // Initialize data manager
        if (window.DashboardDataManager) {
            this.dataManager = new window.DashboardDataManager();
        }
        
        // Ensure error handler is available
        if (!this.errorHandler && window.EnhancedErrorHandler) {
            this.errorHandler = new window.EnhancedErrorHandler();
            this.errorHandler.initialize();
        }
        
        // Setup retry callbacks
        if (this.errorHandler) {
            this.errorHandler.addRetryCallback('dashboard-portfolio', () => this.retryPortfolioLoad());
            this.errorHandler.addRetryCallback('dashboard-funds', () => this.retryFundsLoad());
            this.errorHandler.addRetryCallback('dashboard-rank', () => this.retryRankLoad());
            this.errorHandler.addRetryCallback('dashboard-holdings', () => this.retryHoldingsLoad());
            this.errorHandler.addRetryCallback('dashboard-watchlist', () => this.retryWatchlistLoad());
        }
    }
    
    /**
     * Setup error recovery mechanisms
     */
    setupErrorRecovery() {
        // Listen for loading retry events
        document.addEventListener('loadingRetry', (event) => {
            const { component } = event.detail;
            this.handleRetryRequest(component);
        });
        
        // Listen for data manager loading state changes
        window.addEventListener('dashboardLoadingStateChange', (event) => {
            const { component, isLoading } = event.detail;
            this.handleLoadingStateChange(component, isLoading);
        });
    }
    
    setupEventListeners() {
        // Add any event listeners for dashboard interactions
        document.addEventListener('DOMContentLoaded', () => {
            this.animateWelcomeMessage();
        });

        // Handle swipe events on watchlist items
        document.addEventListener('removestock', (e) => {
            this.handleRemoveStock(e.detail.symbol);
        });

        document.addEventListener('tradestock', (e) => {
            this.handleTradeStock(e.detail.symbol);
        });

        // Handle pull-to-refresh
        document.addEventListener('pullrefresh', (e) => {
            this.handlePullToRefresh();
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                this.handleOrientationChange();
            }, 100);
        });
    }

    setupMobileEnhancements() {
        // Add pull-to-refresh to main content
        const mainContent = document.querySelector('.dashboard-content');
        if (mainContent && this.isMobile()) {
            mainContent.classList.add('pull-to-refresh');
        }

        // Add swipeable class to watchlist items
        this.setupWatchlistSwipes();

        // Add touch feedback to summary cards
        this.setupCardTouchFeedback();

        // Setup mobile-specific table handling
        this.setupMobileTableHandling();
    }

    isMobile() {
        return window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    setupWatchlistSwipes() {
        // This will be called when watchlist items are created
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1 && node.classList.contains('watchlist-item')) {
                        this.addSwipeSupport(node);
                    }
                });
            });
        });

        const watchlistContainer = document.querySelector('#watchlistTable');
        if (watchlistContainer) {
            observer.observe(watchlistContainer, { childList: true, subtree: true });
        }
    }

    addSwipeSupport(item) {
        if (!this.isMobile()) return;

        item.classList.add('swipeable');
        
        // Add data attribute for symbol
        const symbolElement = item.querySelector('.stock-symbol');
        if (symbolElement) {
            item.dataset.symbol = symbolElement.textContent.trim();
        }
    }

    setupCardTouchFeedback() {
        const summaryCards = document.querySelectorAll('.summary-card');
        summaryCards.forEach(card => {
            if (this.isMobile()) {
                card.addEventListener('touchstart', () => {
                    card.classList.add('touch-active');
                });

                card.addEventListener('touchend', () => {
                    setTimeout(() => {
                        card.classList.remove('touch-active');
                    }, 150);
                });
            }
        });
    }

    setupMobileTableHandling() {
        if (!this.isMobile()) return;

        const tables = document.querySelectorAll('.modern-table-container table');
        tables.forEach(table => {
            // Add mobile-specific attributes to table cells
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const headers = table.querySelectorAll('thead th');
                
                cells.forEach((cell, index) => {
                    if (headers[index]) {
                        cell.setAttribute('data-label', headers[index].textContent.trim());
                    }
                });
            });
        });
    }

    handleRemoveStock(symbol) {
        if (!symbol) return;

        // Show confirmation with haptic feedback
        if (this.isMobile() && navigator.vibrate) {
            navigator.vibrate(50); // Light haptic feedback
        }

        // Call existing remove stock functionality
        if (typeof AddStock === 'function') {
            const actionData = {
                Stock: symbol,
                AddDel: 0, // 0 for delete
                GameType: this.getGameType()
            };

            $.ajax({
                url: "/api/AddDelete",
                type: "GET",
                data: actionData,
                success: (data) => {
                    this.loadWatchlistData();
                    this.showNotification(`${symbol} removed from watchlist`, 'success');
                    
                    // Haptic feedback for success
                    if (this.isMobile() && navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]);
                    }
                },
                error: () => {
                    this.showNotification('Failed to remove stock from watchlist', 'error');
                }
            });
        }
    }

    handleTradeStock(symbol) {
        if (!symbol) return;

        // Light haptic feedback
        if (this.isMobile() && navigator.vibrate) {
            navigator.vibrate(30);
        }

        // Open stock modal (assuming this function exists)
        if (typeof openStockModal === 'function') {
            openStockModal(symbol);
        } else {
            // Fallback: trigger click on existing trade button
            const tradeBtn = document.querySelector(`[data-symbol="${symbol}"] .trade-btn`);
            if (tradeBtn) {
                tradeBtn.click();
            }
        }
    }

    handlePullToRefresh() {
        // Refresh all dashboard data
        this.loadInitialData();
        
        // Hide refresh indicator after data loads
        setTimeout(() => {
            const refreshElement = document.querySelector('.pull-to-refresh');
            if (refreshElement) {
                refreshElement.classList.remove('refreshing');
            }
        }, 1500);
    }

    handleOrientationChange() {
        // Recalculate layouts and refresh charts
        if (typeof window.stockChart !== 'undefined' && window.stockChart.resize) {
            window.stockChart.resize();
        }

        // Refresh table layouts
        this.setupMobileTableHandling();

        // Trigger window resize for other components
        window.dispatchEvent(new Event('resize'));
    }
    
    animateWelcomeMessage() {
        const welcomeTitle = document.getElementById('user');
        if (welcomeTitle) {
            setTimeout(() => {
                welcomeTitle.style.opacity = '0';
                welcomeTitle.style.transform = 'translateY(-20px)';
                welcomeTitle.style.transition = 'all 0.5s ease-out';
            }, 2000);
        }
    }
    
    async loadInitialData() {
        try {
            // Use data manager if available for coordinated loading
            if (this.dataManager) {
                await this.loadDataWithManager();
            } else {
                // Fallback to individual loading with enhanced error handling
                await this.loadDataIndividually();
            }
        } catch (error) {
            this.handleCriticalError('loadInitialData', error);
        }
    }
    
    /**
     * Load data using the dashboard data manager
     */
    async loadDataWithManager() {
        const gameType = this.getGameType();
        const userId = this.getCurrentUserId();
        
        try {
            // Start loading states
            this.startLoadingStates();
            
            // Load all dashboard data simultaneously
            const dashboardData = await this.dataManager.loadDashboardData(userId, gameType);
            
            // Process successful data
            this.processDashboardData(dashboardData);
            
            // Load additional data that's not part of core dashboard
            await Promise.allSettled([
                this.loadHoldingsDataWithErrorHandling(),
                this.loadWatchlistDataWithErrorHandling()
            ]);
            
        } catch (error) {
            this.handleDashboardLoadError(error);
        } finally {
            this.completeLoadingStates();
        }
    }
    
    /**
     * Load data individually with enhanced error handling
     */
    async loadDataIndividually() {
        // Start loading states
        this.startLoadingStates();
        
        // Load data with individual error handling
        const dataPromises = [
            this.updatePortfolioSummaryWithErrorHandling(),
            this.updateUserRankWithErrorHandling(),
            this.loadHoldingsDataWithErrorHandling(),
            this.loadWatchlistDataWithErrorHandling()
        ];
        
        // Wait for all operations to complete
        const results = await Promise.allSettled(dataPromises);
        
        // Process results and show specific errors
        this.processLoadResults(results);
        
        this.completeLoadingStates();
    }
    
    /**
     * Start loading states for all components
     */
    startLoadingStates() {
        if (this.loadingManager) {
            this.loadingManager.startLoading('portfolio-summary', {
                message: 'Loading portfolio data...',
                timeout: 10000,
                onTimeout: () => this.handleTimeout('portfolio')
            });
            
            this.loadingManager.startLoading('holdings-table', {
                message: 'Loading holdings...',
                timeout: 10000,
                onTimeout: () => this.handleTimeout('holdings')
            });
            
            this.loadingManager.startLoading('watchlist-table', {
                message: 'Loading watchlist...',
                timeout: 10000,
                onTimeout: () => this.handleTimeout('watchlist')
            });
        } else {
            // Fallback loading indicators
            this.showPortfolioLoading();
            this.showHoldingsLoading();
            this.showWatchlistLoading();
        }
    }
    
    /**
     * Complete loading states for all components
     */
    completeLoadingStates() {
        if (this.loadingManager) {
            this.loadingManager.completeLoading('portfolio-summary', true);
            this.loadingManager.completeLoading('holdings-table', true);
            this.loadingManager.completeLoading('watchlist-table', true);
        }
    }
    
    showPortfolioLoading() {
        const portfolioCards = document.querySelectorAll('.summary-card .card-body');
        portfolioCards.forEach(card => {
            if (window.lottieManager) {
                window.lottieManager.showLoading(card, {
                    width: '40px',
                    height: '40px',
                    minHeight: '60px'
                });
            }
        });
    }
    
    showHoldingsLoading() {
        const holdingsContainer = document.getElementById('holdingsTable');
        if (holdingsContainer && window.lottieManager) {
            window.lottieManager.showLoading(holdingsContainer, {
                width: '60px',
                height: '60px',
                text: 'Loading holdings...',
                minHeight: '200px'
            });
        }
    }
    
    showWatchlistLoading() {
        const watchlistContainer = document.getElementById('watchlistTable');
        if (watchlistContainer && window.lottieManager) {
            window.lottieManager.showLoading(watchlistContainer, {
                width: '60px',
                height: '60px',
                text: 'Loading watchlist...',
                minHeight: '200px'
            });
        }
    }
    
    startPeriodicUpdates() {
        // Update holdings and watchlist every 5 seconds
        setInterval(() => {
            this.updatePortfolioSummary();
            this.loadHoldingsData();
            this.loadWatchlistData();
        }, this.updateInterval);
        
        // Update rank every 30 seconds
        setInterval(() => {
            this.updateUserRank();
        }, this.rankUpdateInterval);
    }
    
    /**
     * Update portfolio summary with enhanced error handling
     */
    async updatePortfolioSummaryWithErrorHandling() {
        const operation = 'portfolio-summary';
        
        try {
            if (this.dataManager) {
                // Use data manager for portfolio data
                const gameType = this.getGameType();
                const userId = this.getCurrentUserId();
                
                const [portfolioData, fundsData] = await Promise.all([
                    this.dataManager.loadPortfolioData(userId, gameType),
                    this.dataManager.getAvailableFunds(gameType)
                ]);
                
                this.processPortfolioData(portfolioData);
                this.processFundsData(fundsData);
                
            } else {
                // Fallback to legacy method with error handling
                await this.updatePortfolioSummaryLegacy();
            }
            
        } catch (error) {
            this.handleOperationError(operation, error, () => this.retryPortfolioLoad());
        }
    }
    
    /**
     * Legacy portfolio summary update with error handling
     */
    updatePortfolioSummaryLegacy() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "/api/UserStocks",
                dataType: "json",
                data: { "GameType": this.getGameType() },
                contentType: "application/json",
                timeout: 10000,
                success: (data) => {
                    try {
                        const listData = JSON.parse(data).Value.UserStockList;
                        this.calculatePortfolioMetrics(listData);
                        this.updatePortfolioCards();
                        resolve(data);
                    } catch (parseError) {
                        reject(new Error('Failed to parse portfolio data'));
                    }
                },
                error: (xhr, status, error) => {
                    const apiError = new Error(error || 'Failed to load portfolio data');
                    apiError.status = xhr.status;
                    apiError.statusText = xhr.statusText;
                    reject(apiError);
                }
            });
            
            // Also update available funds
            this.updateAvailableFundsLegacy().catch(reject);
        });
    }
    
    /**
     * Update available funds with error handling
     */
    updateAvailableFundsLegacy() {
        return new Promise((resolve, reject) => {
            $.ajax({
                type: "GET",
                url: "/api/GetFunds",
                data: { "GameType": this.getGameType() },
                contentType: "application/json",
                timeout: 10000,
                success: (funds) => {
                    this.portfolioData.availableFunds = parseFloat(funds) || 0;
                    this.animateCounter('availableFunds', this.portfolioData.availableFunds, 2);
                    resolve(funds);
                },
                error: (xhr, status, error) => {
                    const apiError = new Error(error || 'Failed to load available funds');
                    apiError.status = xhr.status;
                    reject(apiError);
                }
            });
        });
    }
    
    calculatePortfolioMetrics(holdings) {
        if (!holdings || holdings.length === 0) {
            this.portfolioData = {
                totalHoldings: 0,
                currentValue: 0,
                profitLoss: 0,
                availableFunds: this.portfolioData.availableFunds,
                userRank: this.portfolioData.userRank,
                totalParticipants: this.portfolioData.totalParticipants
            };
            return;
        }
        
        let totalHoldings = 0;
        let currentValue = 0;
        
        holdings.forEach(stock => {
            stock.ProfitLoss = Number((stock.Price - stock.AveragePrice) * stock.Count).toFixed(2);
            totalHoldings += stock.AveragePrice * stock.Count;
            currentValue += stock.Price * stock.Count;
        });
        
        this.portfolioData.totalHoldings = totalHoldings;
        this.portfolioData.currentValue = currentValue;
        this.portfolioData.profitLoss = currentValue - totalHoldings;
    }
    
    updatePortfolioCards() {
        // Animate portfolio value
        this.animateCounter('portfolioValue', this.portfolioData.currentValue, 2);
        
        // Update P&L with color coding
        const changeElement = document.getElementById('portfolioChange');
        const changeValueElement = document.getElementById('portfolioChangeValue');
        const changePercentElement = document.getElementById('portfolioChangePercent');
        
        if (changeElement && changeValueElement && changePercentElement) {
            const pnl = this.portfolioData.profitLoss;
            const pnlPercent = this.portfolioData.totalHoldings > 0 ? 
                (pnl / this.portfolioData.totalHoldings) * 100 : 0;
            
            changeValueElement.textContent = `${pnl >= 0 ? '+' : ''}₹${Math.abs(pnl).toFixed(2)}`;
            changePercentElement.textContent = `(${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)`;
            
            // Update color class
            changeElement.className = 'change-indicator ' + (pnl >= 0 ? 'positive' : 'negative');
        }
    }
    
    updateAvailableFunds() {
        $.ajax({
            type: "GET",
            url: "/api/GetFunds",
            data: { "GameType": this.getGameType() },
            contentType: "application/json",
            success: (funds) => {
                this.portfolioData.availableFunds = parseFloat(funds) || 0;
                this.animateCounter('availableFunds', this.portfolioData.availableFunds, 2);
            },
            error: (error) => {
                console.error("Failed to load funds:", error);
            }
        });
    }
    
    /**
     * Update user rank with enhanced error handling
     */
    async updateUserRankWithErrorHandling() {
        const operation = 'user-rank';
        
        try {
            if (this.dataManager) {
                const gameType = this.getGameType();
                const rankData = await this.dataManager.calculateUserRank(gameType);
                this.processRankData(rankData);
            } else {
                await this.updateUserRankLegacy();
            }
        } catch (error) {
            this.handleOperationError(operation, error, () => this.retryRankLoad());
        }
    }
    
    /**
     * Legacy user rank update with error handling
     */
    updateUserRankLegacy() {
        return new Promise((resolve, reject) => {
            $.ajax({
                type: "GET",
                url: "/api/GetRank",
                data: { "GameType": this.getGameType() },
                contentType: "application/json",
                timeout: 10000,
                success: (rankData) => {
                    try {
                        const rankParts = rankData.split(" / ");
                        this.portfolioData.userRank = parseInt(rankParts[0]) || 1;
                        this.portfolioData.totalParticipants = parseInt(rankParts[1]) || 1;
                        
                        this.animateCounter('userRank', this.portfolioData.userRank, 0);
                        this.animateCounter('totalParticipants', this.portfolioData.totalParticipants, 0);
                        resolve(rankData);
                    } catch (parseError) {
                        reject(new Error('Failed to parse rank data'));
                    }
                },
                error: (xhr, status, error) => {
                    const apiError = new Error(error || 'Failed to load user rank');
                    apiError.status = xhr.status;
                    reject(apiError);
                }
            });
        });
    }
    
    animateCounter(elementId, targetValue, decimals = 0) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const startValue = parseFloat(element.textContent.replace(/[₹,]/g, '')) || 0;
        const difference = targetValue - startValue;
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / this.animationDuration, 1);
            
            // Easing function for smooth animation
            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = startValue + (difference * easeOutQuart);
            
            element.textContent = currentValue.toFixed(decimals);
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                element.textContent = targetValue.toFixed(decimals);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    /**
     * Load holdings data with enhanced error handling
     */
    async loadHoldingsDataWithErrorHandling() {
        const operation = 'holdings-data';
        
        try {
            if (this.dataManager) {
                const gameType = this.getGameType();
                const userId = this.getCurrentUserId();
                const portfolioData = await this.dataManager.loadPortfolioData(userId, gameType);
                this.renderModernHoldingsTable(portfolioData.holdings);
            } else {
                await this.loadHoldingsDataLegacy();
            }
        } catch (error) {
            this.handleOperationError(operation, error, () => this.retryHoldingsLoad());
        }
    }
    
    /**
     * Legacy holdings data loading with error handling
     */
    loadHoldingsDataLegacy() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "/api/UserStocks",
                dataType: "json",
                data: { "GameType": this.getGameType() },
                contentType: "application/json",
                timeout: 10000,
                success: (data) => {
                    try {
                        const listData = JSON.parse(data).Value.UserStockList;
                        this.renderModernHoldingsTable(listData);
                        resolve(data);
                    } catch (parseError) {
                        reject(new Error('Failed to parse holdings data'));
                    }
                },
                error: (xhr, status, error) => {
                    const apiError = new Error(error || 'Failed to load holdings data');
                    apiError.status = xhr.status;
                    reject(apiError);
                }
            });
        });
    }
    
    renderModernHoldingsTable(holdings) {
        const container = document.getElementById('holdingsTable');
        if (!container) return;
        
        if (!holdings || holdings.length === 0) {
            // Show empty state with Lottie animation
            if (window.lottieManager) {
                window.lottieManager.showEmptyState(container, {
                    title: 'No Holdings Yet',
                    message: 'Start trading to see your portfolio here',
                    actionText: 'Add Stocks to Watchlist',
                    actionCallback: () => this.focusStockSearch(),
                    width: '120px',
                    height: '120px'
                });
            } else {
                container.innerHTML = this.getEmptyHoldingsHTML();
            }
            return;
        }
        
        // Calculate P&L for each holding
        holdings.forEach(stock => {
            stock.ProfitLoss = Number((stock.Price - stock.AveragePrice) * stock.Count).toFixed(2);
            stock.ProfitLossPercent = stock.AveragePrice > 0 ? 
                (((stock.Price - stock.AveragePrice) / stock.AveragePrice) * 100).toFixed(2) : 0;
        });
        
        // Store holdings data for sorting/filtering
        this.currentHoldings = holdings;
        
        const tableHTML = `
            <div class="holdings-controls">
                <div class="controls-left">
                    <div class="search-box">
                        <i class="fas fa-search"></i>
                        <input type="text" id="holdingsSearch" placeholder="Search holdings..." class="form-control">
                    </div>
                </div>
                <div class="controls-right">
                    <div class="sort-dropdown">
                        <select id="holdingsSort" class="form-select">
                            <option value="name">Sort by Name</option>
                            <option value="quantity">Sort by Quantity</option>
                            <option value="pnl">Sort by P&L</option>
                            <option value="value">Sort by Value</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modern-table">
                <div class="table-header">
                    <div class="header-cell stock-col sortable" data-sort="name">
                        Stock <i class="fas fa-sort"></i>
                    </div>
                    <div class="header-cell qty-col sortable" data-sort="quantity">
                        Qty <i class="fas fa-sort"></i>
                    </div>
                    <div class="header-cell price-col sortable" data-sort="avgPrice">
                        Avg Price <i class="fas fa-sort"></i>
                    </div>
                    <div class="header-cell price-col sortable" data-sort="currentPrice">
                        LTP <i class="fas fa-sort"></i>
                    </div>
                    <div class="header-cell pnl-col sortable" data-sort="pnl">
                        P&L <i class="fas fa-sort"></i>
                    </div>
                    <div class="header-cell actions-col">Actions</div>
                </div>
                <div class="table-body" id="holdingsTableBody">
                    ${this.renderHoldingsRows(holdings)}
                </div>
            </div>
        `;
        
        container.innerHTML = tableHTML;
        this.addHoldingRowEventListeners();
        this.setupHoldingsControls();
        this.renderHoldingsSummary(holdings);
    }
    
    renderHoldingsRows(holdings) {
        return holdings.map(stock => this.getHoldingRowHTML(stock)).join('');
    }
    
    setupHoldingsControls() {
        // Search functionality
        const searchInput = document.getElementById('holdingsSearch');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterHoldings(e.target.value);
            });
        }
        
        // Sort functionality
        const sortSelect = document.getElementById('holdingsSort');
        if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
                this.sortHoldings(e.target.value);
            });
        }
        
        // Header click sorting
        document.querySelectorAll('.header-cell.sortable').forEach(header => {
            header.addEventListener('click', () => {
                const sortBy = header.dataset.sort;
                this.sortHoldings(sortBy);
                this.updateSortIndicators(header);
            });
        });
    }
    
    filterHoldings(searchTerm) {
        if (!this.currentHoldings) return;
        
        const filtered = this.currentHoldings.filter(stock => 
            stock.Name.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        const tableBody = document.getElementById('holdingsTableBody');
        if (tableBody) {
            tableBody.innerHTML = this.renderHoldingsRows(filtered);
            this.addHoldingRowEventListeners();
        }
    }
    
    sortHoldings(sortBy) {
        if (!this.currentHoldings) return;
        
        const sorted = [...this.currentHoldings].sort((a, b) => {
            switch (sortBy) {
                case 'name':
                    return a.Name.localeCompare(b.Name);
                case 'quantity':
                    return b.Count - a.Count;
                case 'pnl':
                    return parseFloat(b.ProfitLoss) - parseFloat(a.ProfitLoss);
                case 'value':
                    return (b.Price * b.Count) - (a.Price * a.Count);
                case 'avgPrice':
                    return b.AveragePrice - a.AveragePrice;
                case 'currentPrice':
                    return b.Price - a.Price;
                default:
                    return 0;
            }
        });
        
        const tableBody = document.getElementById('holdingsTableBody');
        if (tableBody) {
            // Add fade out animation
            tableBody.style.opacity = '0.5';
            
            setTimeout(() => {
                tableBody.innerHTML = this.renderHoldingsRows(sorted);
                this.addHoldingRowEventListeners();
                
                // Fade back in
                tableBody.style.opacity = '1';
            }, 150);
        }
    }
    
    updateSortIndicators(activeHeader) {
        // Remove active class from all headers
        document.querySelectorAll('.header-cell.sortable').forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
        });
        
        // Add active class to clicked header
        const currentSort = activeHeader.classList.contains('sort-asc') ? 'desc' : 'asc';
        activeHeader.classList.remove('sort-asc', 'sort-desc');
        activeHeader.classList.add(`sort-${currentSort}`);
    }
    
    renderHoldingsSummary(holdings) {
        const summaryContainer = document.getElementById('holdingsSummary');
        if (!summaryContainer || !holdings || holdings.length === 0) return;
        
        let totalInvested = 0;
        let currentValue = 0;
        let totalPnL = 0;
        
        holdings.forEach(stock => {
            totalInvested += stock.AveragePrice * stock.Count;
            currentValue += stock.Price * stock.Count;
            totalPnL += parseFloat(stock.ProfitLoss);
        });
        
        const pnlPercent = totalInvested > 0 ? ((totalPnL / totalInvested) * 100) : 0;
        const pnlClass = totalPnL >= 0 ? 'positive' : 'negative';
        
        const summaryHTML = `
            <div class="summary-grid">
                <div class="summary-item">
                    <div class="summary-label">Total Invested</div>
                    <div class="summary-value">₹${totalInvested.toFixed(2)}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">Current Value</div>
                    <div class="summary-value">₹${currentValue.toFixed(2)}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">Total P&L</div>
                    <div class="summary-value ${pnlClass}">
                        ${totalPnL >= 0 ? '+' : ''}₹${totalPnL.toFixed(2)}
                        <small>(${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</small>
                    </div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">Holdings Count</div>
                    <div class="summary-value">${holdings.length} stocks</div>
                </div>
            </div>
        `;
        
        summaryContainer.innerHTML = summaryHTML;
    }
    
    addRealTimeUpdateAnimation(element, type = 'neutral') {
        if (!element) return;
        
        element.classList.add('price-update', type);
        
        setTimeout(() => {
            element.classList.remove('price-update', type);
        }, 800);
    }
    
    updateHoldingRow(stockName, newData) {
        const row = document.querySelector(`[data-stock="${stockName}"]`);
        if (!row) return;
        
        // Add updating animation
        row.classList.add('updating');
        
        // Update price cells with animation
        const priceCell = row.querySelector('.price-col:last-of-type .price');
        const pnlCell = row.querySelector('.pnl-col');
        
        if (priceCell && newData.Price) {
            const oldPrice = parseFloat(priceCell.textContent.replace('₹', ''));
            const newPrice = parseFloat(newData.Price);
            
            priceCell.textContent = `₹${newPrice.toFixed(2)}`;
            
            // Add price change animation
            const changeType = newPrice > oldPrice ? 'positive' : newPrice < oldPrice ? 'negative' : 'neutral';
            this.addRealTimeUpdateAnimation(priceCell, changeType);
        }
        
        if (pnlCell && newData.ProfitLoss) {
            const pnlAmount = pnlCell.querySelector('.pnl-amount');
            const pnlPercent = pnlCell.querySelector('.pnl-percent');
            
            if (pnlAmount) {
                const pnl = parseFloat(newData.ProfitLoss);
                const icon = pnl >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
                pnlAmount.innerHTML = `<i class="fas ${icon}"></i> ₹${Math.abs(pnl).toFixed(2)}`;
            }
            
            if (pnlPercent && newData.ProfitLossPercent) {
                pnlPercent.textContent = `(${newData.ProfitLossPercent}%)`;
            }
            
            // Update P&L color class
            pnlCell.classList.remove('positive', 'negative');
            pnlCell.classList.add(parseFloat(newData.ProfitLoss) >= 0 ? 'positive' : 'negative');
            
            this.addRealTimeUpdateAnimation(pnlCell, parseFloat(newData.ProfitLoss) >= 0 ? 'positive' : 'negative');
        }
        
        // Remove updating animation
        setTimeout(() => {
            row.classList.remove('updating');
        }, 500);
    }
    
    getHoldingRowHTML(stock) {
        const pnlClass = parseFloat(stock.ProfitLoss) >= 0 ? 'positive' : 'negative';
        const pnlIcon = parseFloat(stock.ProfitLoss) >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
        
        return `
            <div class="table-row" data-stock="${stock.Name}">
                <div class="table-cell stock-col">
                    <div class="stock-info">
                        <div class="stock-symbol">${stock.Name}</div>
                        <div class="stock-name">${stock.Name}</div>
                    </div>
                </div>
                <div class="table-cell qty-col">
                    <span class="quantity">${stock.Count}</span>
                </div>
                <div class="table-cell price-col">
                    <span class="price">₹${parseFloat(stock.AveragePrice).toFixed(2)}</span>
                </div>
                <div class="table-cell price-col">
                    <span class="price">₹${parseFloat(stock.Price).toFixed(2)}</span>
                </div>
                <div class="table-cell pnl-col ${pnlClass}">
                    <div class="pnl-container">
                        <span class="pnl-amount">
                            <i class="fas ${pnlIcon}"></i>
                            ₹${Math.abs(parseFloat(stock.ProfitLoss)).toFixed(2)}
                        </span>
                        <span class="pnl-percent">(${stock.ProfitLossPercent}%)</span>
                    </div>
                </div>
                <div class="table-cell actions-col">
                    <button class="btn btn-sm btn-primary trade-btn" onclick="dashboard.openTradeModal('${stock.Name}', ${stock.Price})">
                        <i class="fas fa-exchange-alt"></i>
                        Trade
                    </button>
                </div>
            </div>
        `;
    }
    
    getEmptyHoldingsHTML() {
        return `
            <div class="empty-state">
                <div class="empty-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
                <h3 class="empty-title">No Holdings Yet</h3>
                <p class="empty-message">Start trading to see your portfolio here</p>
                <button class="btn btn-primary" onclick="dashboard.focusStockSearch()">
                    <i class="fas fa-plus"></i>
                    Add Stocks to Watchlist
                </button>
            </div>
        `;
    }
    
    addHoldingRowEventListeners() {
        // Add click handlers for table rows
        document.querySelectorAll('.table-row').forEach(row => {
            row.addEventListener('click', (e) => {
                if (!e.target.closest('.trade-btn')) {
                    const stockName = row.dataset.stock;
                    this.showStockDetails(stockName);
                }
            });
        });
    }
    
    /**
     * Load watchlist data with enhanced error handling
     */
    async loadWatchlistDataWithErrorHandling() {
        const operation = 'watchlist-data';
        
        try {
            // Use modern watchlist if available
            if (window.modernWatchlist && modernWatchlist.loadWatchlistData) {
                await new Promise((resolve, reject) => {
                    try {
                        modernWatchlist.loadWatchlistData();
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                });
            } else {
                await this.loadWatchlistDataLegacy();
            }
        } catch (error) {
            this.handleOperationError(operation, error, () => this.retryWatchlistLoad());
        }
    }
    
    /**
     * Legacy watchlist data loading with error handling
     */
    loadWatchlistDataLegacy() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "/api/UserWatchlist",
                dataType: "json",
                data: { "GameType": this.getGameType() },
                contentType: "application/json",
                timeout: 10000,
                success: (data) => {
                    try {
                        const listData = JSON.parse(data).Value;
                        this.renderModernWatchlist(listData);
                        resolve(data);
                    } catch (parseError) {
                        reject(new Error('Failed to parse watchlist data'));
                    }
                },
                error: (xhr, status, error) => {
                    const apiError = new Error(error || 'Failed to load watchlist data');
                    apiError.status = xhr.status;
                    reject(apiError);
                }
            });
        });
    }
    
    renderModernWatchlist(watchlist) {
        const container = document.getElementById('watchlistTable');
        if (!container) return;
        
        if (!watchlist || watchlist.length === 0) {
            // Show empty state with Lottie animation
            if (window.lottieManager) {
                window.lottieManager.showEmptyState(container, {
                    title: 'No Stocks in Watchlist',
                    message: 'Add stocks to track their performance',
                    width: '100px',
                    height: '100px'
                });
            } else {
                container.innerHTML = this.getEmptyWatchlistHTML();
            }
            return;
        }
        
        const watchlistHTML = `
            <div class="watchlist-items">
                ${watchlist.map(stock => this.getWatchlistItemHTML(stock)).join('')}
            </div>
        `;
        
        container.innerHTML = watchlistHTML;
        this.addWatchlistEventListeners();
    }
    
    getWatchlistItemHTML(stock) {
        // Calculate change (assuming we have previous price data)
        const change = 0; // This would come from API
        const changePercent = 0; // This would come from API
        const changeClass = change >= 0 ? 'positive' : 'negative';
        
        return `
            <div class="watchlist-item" data-stock="${stock.Name}">
                <div class="stock-info">
                    <div class="symbol">${stock.Name}</div>
                    <div class="name">${stock.Name}</div>
                </div>
                <div class="price-info">
                    <div class="current-price">₹${parseFloat(stock.Price).toFixed(2)}</div>
                    <div class="change ${changeClass}">
                        ${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent.toFixed(2)}%)
                    </div>
                </div>
                <div class="actions">
                    <button class="btn btn-sm btn-primary" onclick="dashboard.openTradeModal('${stock.Name}', ${stock.Price})">
                        Trade
                    </button>
                    <button class="btn btn-sm btn-outline-danger" onclick="dashboard.removeFromWatchlist('${stock.Name}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
        `;
    }
    
    getEmptyWatchlistHTML() {
        return `
            <div class="empty-state">
                <div class="empty-icon">
                    <i class="fas fa-eye"></i>
                </div>
                <h3 class="empty-title">No Stocks in Watchlist</h3>
                <p class="empty-message">Add stocks to track their performance</p>
            </div>
        `;
    }
    
    addWatchlistEventListeners() {
        document.querySelectorAll('.watchlist-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (!e.target.closest('button')) {
                    const stockName = item.dataset.stock;
                    this.showStockDetails(stockName);
                }
            });
        });
    }
    
    openTradeModal(stockName, price) {
        // Use new modern stock modal if available
        if (window.stockModal) {
            const stockData = {
                symbol: stockName,
                name: stockName,
                currentPrice: price,
                price: price,
                change: 0, // Would be calculated from real data
                changePercent: 0,
                open: price,
                high: price,
                low: price,
                prevClose: price,
                volume: 0
            };
            window.stockModal.show(stockData);
        } else {
            // Fallback to existing modal functionality
            $("#mStock").html(stockName);
            $("#mPrice").html(price);
            $("#buyButton").prop("disabled", false);
            $("#sellButton").prop("disabled", false);
            $('#myModal').modal('show');
        }
    }
    
    removeFromWatchlist(stockName) {
        if (confirm(`Remove ${stockName} from watchlist?`)) {
            const actionData = {
                Stock: stockName,
                AddDel: 0,
                GameType: this.getGameType()
            };
            
            $.ajax({
                url: "/api/AddDelete",
                type: "GET",
                data: actionData,
                contentType: "application/json",
                success: () => {
                    this.loadWatchlistData();
                    this.showNotification(`${stockName} removed from watchlist`, 'success');
                },
                error: () => {
                    this.showNotification('Failed to remove stock from watchlist', 'error');
                }
            });
        }
    }
    
    focusStockSearch() {
        const searchElement = document.getElementById('SearchStocks');
        if (searchElement) {
            searchElement.focus();
        }
    }
    
    showStockDetails(stockName) {
        // Find stock data from current holdings or watchlist
        let stockData = null;
        
        // Try to find in holdings first
        if (this.currentHoldings) {
            const holding = this.currentHoldings.find(h => h.Name === stockName);
            if (holding) {
                stockData = {
                    symbol: holding.Name,
                    name: holding.Name,
                    currentPrice: holding.Price,
                    price: holding.Price,
                    change: holding.ProfitLoss / holding.Count, // Per share P&L
                    changePercent: holding.ProfitLossPercent,
                    open: holding.Price,
                    high: holding.Price,
                    low: holding.Price,
                    prevClose: holding.AveragePrice,
                    volume: 0
                };
            }
        }
        
        // If not found in holdings, create basic stock data
        if (!stockData) {
            stockData = {
                symbol: stockName,
                name: stockName,
                currentPrice: 0,
                price: 0,
                change: 0,
                changePercent: 0,
                open: 0,
                high: 0,
                low: 0,
                prevClose: 0,
                volume: 0
            };
        }
        
        // Open stock modal
        if (window.stockModal) {
            window.stockModal.show(stockData);
        } else {
            console.log(`Show details for ${stockName}`);
        }
    }
    
    showNotification(message, type = 'info') {
        // Use Lottie animations for notifications if available
        if (window.lottieManager && type === 'success') {
            this.showSuccessNotification(message);
        } else if (window.lottieManager && type === 'error') {
            this.showErrorNotification(message);
        } else {
            // Fallback to simple notification system
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
    }
    
    showSuccessNotification(message) {
        if (window.lottieManager) {
            // Create a temporary container for the notification
            const notificationContainer = document.createElement('div');
            notificationContainer.className = 'toast-notification success';
            notificationContainer.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                background: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                padding: 16px;
                min-width: 300px;
                animation: slideInRight 0.3s ease-out;
            `;
            
            document.body.appendChild(notificationContainer);
            
            window.lottieManager.showSuccess(notificationContainer, {
                message: message,
                duration: 3000,
                width: '30px',
                height: '30px',
                replace: false,
                onComplete: () => {
                    notificationContainer.remove();
                }
            });
        }
    }
    
    showErrorNotification(message) {
        if (window.lottieManager) {
            // Create a temporary container for the notification
            const notificationContainer = document.createElement('div');
            notificationContainer.className = 'toast-notification error';
            notificationContainer.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                background: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                padding: 16px;
                min-width: 300px;
                animation: slideInRight 0.3s ease-out;
            `;
            
            document.body.appendChild(notificationContainer);
            
            window.lottieManager.showError(notificationContainer, {
                message: message,
                duration: 4000,
                width: '30px',
                height: '30px',
                replace: false,
                onComplete: () => {
                    notificationContainer.remove();
                }
            });
        }
    }
    
    /**
     * Process dashboard data from data manager
     */
    processDashboardData(dashboardData) {
        if (dashboardData.portfolio.success) {
            this.processPortfolioData(dashboardData.portfolio.data);
        } else {
            this.showPortfolioError(dashboardData.portfolio.error);
        }
        
        if (dashboardData.funds.success) {
            this.processFundsData(dashboardData.funds.data);
        } else {
            this.showFundsError(dashboardData.funds.error);
        }
        
        if (dashboardData.rank.success) {
            this.processRankData(dashboardData.rank.data);
        } else {
            this.showRankError(dashboardData.rank.error);
        }
    }
    
    /**
     * Process portfolio data from data manager
     */
    processPortfolioData(portfolioData) {
        if (portfolioData && portfolioData.summary) {
            this.portfolioData.totalHoldings = portfolioData.summary.totalInvested;
            this.portfolioData.currentValue = portfolioData.summary.currentValue;
            this.portfolioData.profitLoss = portfolioData.summary.totalPnL;
            this.updatePortfolioCards();
        }
    }
    
    /**
     * Process funds data from data manager
     */
    processFundsData(fundsData) {
        if (fundsData && typeof fundsData.amount === 'number') {
            this.portfolioData.availableFunds = fundsData.amount;
            this.animateCounter('availableFunds', this.portfolioData.availableFunds, 2);
        }
    }
    
    /**
     * Process rank data from data manager
     */
    processRankData(rankData) {
        if (rankData) {
            this.portfolioData.userRank = rankData.userRank;
            this.portfolioData.totalParticipants = rankData.totalParticipants;
            
            this.animateCounter('userRank', this.portfolioData.userRank, 0);
            this.animateCounter('totalParticipants', this.portfolioData.totalParticipants, 0);
        }
    }
    
    /**
     * Process load results from Promise.allSettled
     */
    processLoadResults(results) {
        results.forEach((result, index) => {
            if (result.status === 'rejected') {
                const operations = ['portfolio', 'rank', 'holdings', 'watchlist'];
                const operation = operations[index];
                console.error(`Failed to load ${operation}:`, result.reason);
                
                // Show specific error for each operation
                switch (operation) {
                    case 'portfolio':
                        this.showPortfolioError(result.reason);
                        break;
                    case 'rank':
                        this.showRankError(result.reason);
                        break;
                    case 'holdings':
                        this.showHoldingsError(result.reason);
                        break;
                    case 'watchlist':
                        this.showWatchlistError(result.reason);
                        break;
                }
            }
        });
    }
    
    /**
     * Handle operation errors with specific messaging and retry options
     */
    handleOperationError(operation, error, retryCallback) {
        console.error(`Dashboard operation failed: ${operation}`, error);
        
        // Track retry attempts
        const retryCount = this.retryAttempts.get(operation) || 0;
        
        // Use error handler if available
        if (this.errorHandler) {
            const shouldRetry = this.errorHandler.handleApiError(`/api/${operation}`, error, retryCount);
            
            if (shouldRetry && retryCount < this.maxRetries) {
                // Show retry option
                this.showRetryOption(operation, error, retryCallback);
            } else {
                // Show final error state
                this.showFinalErrorState(operation, error);
            }
        } else {
            // Fallback error handling
            this.showRetryOption(operation, error, retryCallback);
        }
    }
    
    /**
     * Handle critical errors that affect the entire dashboard
     */
    handleCriticalError(operation, error) {
        console.error(`Critical dashboard error in ${operation}:`, error);
        
        if (this.errorHandler) {
            this.errorHandler.handleComponentError('Dashboard', error, { operation });
        }
        
        // Show critical error message
        this.showCriticalErrorMessage(error);
    }
    
    /**
     * Handle dashboard load error
     */
    handleDashboardLoadError(error) {
        console.error('Dashboard load error:', error);
        
        if (this.errorHandler) {
            this.errorHandler.handleComponentError('Dashboard', error, { 
                operation: 'loadDashboardData',
                timestamp: new Date()
            });
        }
        
        // Show user-friendly error with retry option
        this.showDashboardLoadError(error);
    }
    
    /**
     * Handle timeout events
     */
    handleTimeout(component) {
        console.warn(`Timeout occurred for component: ${component}`);
        
        const timeoutError = new Error(`Loading timeout for ${component}`);
        timeoutError.type = 'timeout';
        
        if (this.errorHandler) {
            this.errorHandler.handleComponentError('Dashboard', timeoutError, { 
                component,
                operation: 'timeout'
            });
        }
        
        this.showTimeoutError(component);
    }
    
    /**
     * Handle loading state changes
     */
    handleLoadingStateChange(component, isLoading) {
        // Update UI based on loading state changes
        if (isLoading) {
            this.showComponentLoading(component);
        } else {
            this.hideComponentLoading(component);
        }
    }
    
    /**
     * Handle retry requests
     */
    handleRetryRequest(component) {
        console.log(`Retry requested for component: ${component}`);
        
        switch (component) {
            case 'portfolio-summary':
                this.retryPortfolioLoad();
                break;
            case 'holdings-table':
                this.retryHoldingsLoad();
                break;
            case 'watchlist-table':
                this.retryWatchlistLoad();
                break;
            default:
                console.warn(`Unknown component for retry: ${component}`);
        }
    }
    
    /**
     * Show retry option for failed operations
     */
    showRetryOption(operation, error, retryCallback) {
        const message = this.getErrorMessage(operation, error);
        const actions = [{
            text: 'Retry',
            callback: () => {
                const retryCount = this.retryAttempts.get(operation) || 0;
                this.retryAttempts.set(operation, retryCount + 1);
                retryCallback();
            }
        }];
        
        if (this.errorHandler) {
            this.errorHandler.showUserError(
                { type: this.errorHandler.errorTypes.API },
                message,
                actions
            );
        } else {
            // Fallback notification
            this.showNotification(message + ' Click to retry.', 'error');
        }
    }
    
    /**
     * Get user-friendly error message for operations
     */
    getErrorMessage(operation, error) {
        const baseMessages = {
            'portfolio-summary': 'Unable to load portfolio data',
            'user-rank': 'Unable to load your ranking',
            'holdings-data': 'Unable to load your holdings',
            'watchlist-data': 'Unable to load your watchlist'
        };
        
        let message = baseMessages[operation] || 'An error occurred';
        
        // Add specific error details
        if (error.status === 408 || error.message?.includes('timeout')) {
            message += '. The request timed out.';
        } else if (error.status >= 500) {
            message += '. Server error occurred.';
        } else if (!navigator.onLine) {
            message += '. Please check your internet connection.';
        } else {
            message += '. Please try again.';
        }
        
        return message;
    }
    
    /**
     * Show specific error states for different components
     */
    showPortfolioError(error) {
        const portfolioValue = document.getElementById('portfolioValue');
        const availableFunds = document.getElementById('availableFunds');
        
        if (portfolioValue) {
            portfolioValue.innerHTML = `
                <span class="error-text">Unable to load</span>
                <button class="btn btn-sm btn-link retry-btn" onclick="dashboard.retryPortfolioLoad()">
                    <i class="fas fa-redo"></i> Retry
                </button>
            `;
        }
        
        if (availableFunds) {
            availableFunds.innerHTML = `
                <span class="error-text">Unable to load</span>
                <button class="btn btn-sm btn-link retry-btn" onclick="dashboard.retryPortfolioLoad()">
                    <i class="fas fa-redo"></i> Retry
                </button>
            `;
        }
    }
    
    showFundsError(error) {
        const availableFunds = document.getElementById('availableFunds');
        if (availableFunds) {
            availableFunds.innerHTML = `
                <span class="error-text">Unable to load funds</span>
                <button class="btn btn-sm btn-link retry-btn" onclick="dashboard.retryFundsLoad()">
                    <i class="fas fa-redo"></i> Retry
                </button>
            `;
        }
    }
    
    showRankError(error) {
        const userRank = document.getElementById('userRank');
        const totalParticipants = document.getElementById('totalParticipants');
        
        if (userRank) {
            userRank.innerHTML = `
                <span class="error-text">--</span>
                <button class="btn btn-sm btn-link retry-btn" onclick="dashboard.retryRankLoad()">
                    <i class="fas fa-redo"></i> Retry
                </button>
            `;
        }
        
        if (totalParticipants) {
            totalParticipants.textContent = "Unable to load";
        }
    }
    
    showHoldingsError(error) {
        const container = document.getElementById('holdingsTable');
        if (container) {
            const errorMessage = this.getErrorMessage('holdings-data', error);
            container.innerHTML = `
                <div class="error-state">
                    <div class="error-icon">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div class="error-content">
                        <h4>Unable to Load Holdings</h4>
                        <p>${errorMessage}</p>
                        <div class="error-actions">
                            <button class="btn btn-primary" onclick="dashboard.retryHoldingsLoad()">
                                <i class="fas fa-redo"></i> Retry
                            </button>
                            <button class="btn btn-outline-secondary" onclick="dashboard.loadInitialData()">
                                <i class="fas fa-refresh"></i> Refresh All
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
    }
    
    showWatchlistError(error) {
        const container = document.getElementById('watchlistTable');
        if (container) {
            const errorMessage = this.getErrorMessage('watchlist-data', error);
            container.innerHTML = `
                <div class="error-state">
                    <div class="error-icon">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div class="error-content">
                        <h4>Unable to Load Watchlist</h4>
                        <p>${errorMessage}</p>
                        <div class="error-actions">
                            <button class="btn btn-primary" onclick="dashboard.retryWatchlistLoad()">
                                <i class="fas fa-redo"></i> Retry
                            </button>
                            <button class="btn btn-outline-secondary" onclick="dashboard.loadInitialData()">
                                <i class="fas fa-refresh"></i> Refresh All
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
    }
    
    showFinalErrorState(operation, error) {
        // Show final error state when max retries exceeded
        const message = `${this.getErrorMessage(operation, error)} Maximum retry attempts exceeded.`;
        
        if (this.errorHandler) {
            this.errorHandler.showUserError(
                { type: this.errorHandler.errorTypes.CRITICAL },
                message,
                [{
                    text: 'Refresh Page',
                    callback: () => window.location.reload()
                }]
            );
        }
    }
    
    showCriticalErrorMessage(error) {
        if (this.errorHandler) {
            this.errorHandler.showUserError(
                { type: this.errorHandler.errorTypes.CRITICAL },
                'A critical error occurred while loading the dashboard. Please refresh the page.',
                [{
                    text: 'Refresh Page',
                    callback: () => window.location.reload()
                }]
            );
        }
    }
    
    showDashboardLoadError(error) {
        const message = 'Unable to load dashboard data. Please check your connection and try again.';
        
        if (this.errorHandler) {
            this.errorHandler.showUserError(
                { type: this.errorHandler.errorTypes.API },
                message,
                [{
                    text: 'Retry',
                    callback: () => this.loadInitialData()
                }, {
                    text: 'Refresh Page',
                    callback: () => window.location.reload()
                }]
            );
        }
    }
    
    showTimeoutError(component) {
        const message = `Loading ${component} is taking longer than expected. Please try again.`;
        
        if (this.errorHandler) {
            this.errorHandler.showUserError(
                { type: this.errorHandler.errorTypes.TIMEOUT },
                message,
                [{
                    text: 'Retry',
                    callback: () => this.handleRetryRequest(component)
                }]
            );
        }
    }
    
    /**
     * Show/hide component loading states
     */
    showComponentLoading(component) {
        // Implementation depends on specific component
        console.log(`Showing loading for ${component}`);
    }
    
    hideComponentLoading(component) {
        // Implementation depends on specific component
        console.log(`Hiding loading for ${component}`);
    }
    
    /**
     * Retry methods for different operations
     */
    retryPortfolioLoad() {
        console.log('Retrying portfolio load...');
        this.updatePortfolioSummaryWithErrorHandling();
    }
    
    retryFundsLoad() {
        console.log('Retrying funds load...');
        this.updateAvailableFundsLegacy().catch(error => {
            this.handleOperationError('funds', error, () => this.retryFundsLoad());
        });
    }
    
    retryRankLoad() {
        console.log('Retrying rank load...');
        this.updateUserRankWithErrorHandling();
    }
    
    retryHoldingsLoad() {
        console.log('Retrying holdings load...');
        this.loadHoldingsDataWithErrorHandling();
    }
    
    retryWatchlistLoad() {
        console.log('Retrying watchlist load...');
        this.loadWatchlistDataWithErrorHandling();
    }
    
    /**
     * Get current user ID (implement based on your authentication system)
     */
    getCurrentUserId() {
        // This should be implemented based on your authentication system
        // For now, return a default or extract from DOM/session
        return 'current-user';
    }
    
    getGameType() {
        const type = $("#mainGrid").attr("data-value");
        switch (type) {
            case "Competition":
                return "C1";
            default:
                return "";
        }
    }
}

// Add CSS styles for error states
function addDashboardErrorStyles() {
    if (document.getElementById('dashboard-error-styles')) {
        return;
    }
    
    const style = document.createElement('style');
    style.id = 'dashboard-error-styles';
    style.textContent = `
        .error-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            min-height: 200px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .error-icon {
            font-size: 48px;
            color: #dc3545;
            margin-bottom: 16px;
        }
        
        .error-content h4 {
            color: #495057;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .error-content p {
            color: #6c757d;
            margin-bottom: 20px;
            max-width: 400px;
        }
        
        .error-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .error-text {
            color: #dc3545;
            font-size: 14px;
            font-weight: 500;
        }
        
        .retry-btn {
            color: #007bff !important;
            font-size: 12px;
            padding: 2px 6px !important;
            text-decoration: none !important;
        }
        
        .retry-btn:hover {
            color: #0056b3 !important;
            text-decoration: underline !important;
        }
        
        .retry-btn i {
            margin-right: 4px;
        }
        
        @media (max-width: 768px) {
            .error-state {
                padding: 30px 15px;
                min-height: 150px;
            }
            
            .error-icon {
                font-size: 36px;
            }
            
            .error-actions {
                flex-direction: column;
                align-items: center;
            }
            
            .error-actions .btn {
                width: 100%;
                max-width: 200px;
            }
        }
    `;
    document.head.appendChild(style);
}

// Initialize dashboard when DOM is loaded
let dashboard;
document.addEventListener('DOMContentLoaded', () => {
    addDashboardErrorStyles();
    dashboard = new DashboardManager();
});

// Legacy function compatibility with error handling
function GetGameType() {
    return dashboard ? dashboard.getGameType() : "";
}

function GetHoldingsGrid() {
    if (dashboard) {
        dashboard.loadHoldingsDataWithErrorHandling().catch(error => {
            console.error('Legacy GetHoldingsGrid failed:', error);
        });
    }
}

function GetWatchListGrid() {
    if (dashboard) {
        dashboard.loadWatchlistDataWithErrorHandling().catch(error => {
            console.error('Legacy GetWatchListGrid failed:', error);
        });
    }
}

function GetUserData() {
    if (dashboard) {
        dashboard.updatePortfolioSummaryWithErrorHandling().catch(error => {
            console.error('Legacy GetUserData failed:', error);
        });
    }
}

function GetRank() {
    if (dashboard) {
        dashboard.updateUserRankWithErrorHandling().catch(error => {
            console.error('Legacy GetRank failed:', error);
        });
    }
}
// Advanced Stock Search with Autocomplete
class WatchlistSearchManager {
    constructor() {
        this.searchElement = null;
        this.searchResults = [];
        this.selectedIndex = -1;
        this.searchTimeout = null;
        this.minSearchLength = 1;
        this.searchDelay = 300;
        
        this.init();
    }
    
    init() {
        this.setupSearchElement();
        this.setupEventListeners();
        this.createSearchResultsContainer();
    }
    
    setupSearchElement() {
        const searchContainer = document.querySelector('.search-container');
        if (!searchContainer) return;
        
        // Replace the existing select2 with our custom search
        const existingSelect = document.getElementById('SearchStocks');
        if (existingSelect) {
            existingSelect.remove();
        }
        
        // Create new search input with enhanced features
        const searchHTML = `
            <div class="advanced-search-wrapper">
                <div class="search-input-container">
                    <i class="fas fa-search search-icon"></i>
                    <input 
                        type="text" 
                        id="advancedStockSearch" 
                        class="advanced-search-input" 
                        placeholder="Search stocks by symbol or company name..."
                        autocomplete="off"
                        spellcheck="false"
                    >
                    <button class="search-clear-btn" id="clearSearchBtn" style="display: none;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="search-results-container" id="searchResultsContainer" style="display: none;">
                    <div class="search-results-list" id="searchResultsList"></div>
                    <div class="search-loading" id="searchLoading" style="display: none;">
                        <div class="loading-spinner"></div>
                        <span>Searching...</span>
                    </div>
                    <div class="search-no-results" id="searchNoResults" style="display: none;">
                        <i class="fas fa-search"></i>
                        <span>No stocks found</span>
                    </div>
                </div>
            </div>
        `;
        
        searchContainer.innerHTML = searchHTML;
        this.searchElement = document.getElementById('advancedStockSearch');
    }
    
    setupEventListeners() {
        if (!this.searchElement) return;
        
        // Input event for real-time search
        this.searchElement.addEventListener('input', (e) => {
            this.handleSearchInput(e.target.value);
        });
        
        // Keyboard navigation
        this.searchElement.addEventListener('keydown', (e) => {
            this.handleKeyboardNavigation(e);
        });
        
        // Focus events
        this.searchElement.addEventListener('focus', () => {
            this.showSearchResults();
        });
        
        this.searchElement.addEventListener('blur', (e) => {
            // Delay hiding to allow clicking on results
            setTimeout(() => {
                if (!this.isMouseOverResults()) {
                    this.hideSearchResults();
                }
            }, 150);
        });
        
        // Clear button
        const clearBtn = document.getElementById('clearSearchBtn');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                this.clearSearch();
            });
        }
        
        // Click outside to close
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.advanced-search-wrapper')) {
                this.hideSearchResults();
            }
        });
    }
    
    createSearchResultsContainer() {
        const container = document.getElementById('searchResultsContainer');
        if (container) {
            // Add mouse events to prevent blur when hovering over results
            container.addEventListener('mouseenter', () => {
                this.mouseOverResults = true;
            });
            
            container.addEventListener('mouseleave', () => {
                this.mouseOverResults = false;
            });
        }
    }
    
    handleSearchInput(query) {
        const trimmedQuery = query.trim();
        
        // Show/hide clear button
        const clearBtn = document.getElementById('clearSearchBtn');
        if (clearBtn) {
            clearBtn.style.display = trimmedQuery ? 'flex' : 'none';
        }
        
        // Clear previous timeout
        if (this.searchTimeout) {
            clearTimeout(this.searchTimeout);
        }
        
        if (trimmedQuery.length < this.minSearchLength) {
            this.hideSearchResults();
            return;
        }
        
        // Debounce search
        this.searchTimeout = setTimeout(() => {
            this.performSearch(trimmedQuery);
        }, this.searchDelay);
    }
    
    async performSearch(query) {
        this.showLoading();
        this.selectedIndex = -1;
        
        try {
            const response = await this.fetchStockData(query);
            this.searchResults = response || [];
            this.renderSearchResults();
        } catch (error) {
            console.error('Search failed:', error);
            this.showError();
        }
    }
    
    fetchStockData(query) {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "/api/AllStocks",
                method: "GET",
                data: { item: query },
                success: (data) => {
                    try {
                        const parsedData = JSON.parse(data);
                        resolve(parsedData.Value || []);
                    } catch (e) {
                        reject(e);
                    }
                },
                error: (xhr, status, error) => {
                    reject(error);
                }
            });
        });
    }
    
    renderSearchResults() {
        const resultsList = document.getElementById('searchResultsList');
        const noResults = document.getElementById('searchNoResults');
        
        this.hideLoading();
        
        if (!this.searchResults || this.searchResults.length === 0) {
            resultsList.innerHTML = '';
            noResults.style.display = 'flex';
            this.showSearchResults();
            return;
        }
        
        noResults.style.display = 'none';
        
        const resultsHTML = this.searchResults.map((stock, index) => 
            this.createSearchResultItem(stock, index)
        ).join('');
        
        resultsList.innerHTML = resultsHTML;
        this.addResultEventListeners();
        this.showSearchResults();
    }
    
    createSearchResultItem(stock, index) {
        const query = this.searchElement.value.toLowerCase();
        const highlightedSymbol = this.highlightMatch(stock.Symbol, query);
        const highlightedName = stock.CompanyName ? this.highlightMatch(stock.CompanyName, query) : stock.Symbol;
        
        return `
            <div class="search-result-item" data-index="${index}" data-symbol="${stock.Symbol}">
                <div class="result-main-info">
                    <div class="result-symbol">${highlightedSymbol}</div>
                    <div class="result-name">${highlightedName}</div>
                </div>
                <div class="result-actions">
                    <button class="result-action-btn add-to-watchlist" data-symbol="${stock.Symbol}">
                        <i class="fas fa-plus"></i>
                        <span>Add</span>
                    </button>
                    <button class="result-action-btn trade-stock" data-symbol="${stock.Symbol}">
                        <i class="fas fa-exchange-alt"></i>
                        <span>Trade</span>
                    </button>
                </div>
            </div>
        `;
    }
    
    highlightMatch(text, query) {
        if (!query || !text) return text;
        
        const regex = new RegExp(`(${this.escapeRegExp(query)})`, 'gi');
        return text.replace(regex, '<mark class="search-highlight">$1</mark>');
    }
    
    escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    addResultEventListeners() {
        // Add to watchlist buttons
        document.querySelectorAll('.add-to-watchlist').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const symbol = btn.dataset.symbol;
                this.addToWatchlist(symbol);
            });
        });
        
        // Trade buttons
        document.querySelectorAll('.trade-stock').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const symbol = btn.dataset.symbol;
                this.openTradeModal(symbol);
            });
        });
        
        // Result item clicks
        document.querySelectorAll('.search-result-item').forEach(item => {
            item.addEventListener('click', () => {
                const symbol = item.dataset.symbol;
                this.selectStock(symbol);
            });
            
            item.addEventListener('mouseenter', () => {
                this.highlightResult(parseInt(item.dataset.index));
            });
        });
    }
    
    handleKeyboardNavigation(e) {
        const resultsContainer = document.getElementById('searchResultsContainer');
        const isResultsVisible = resultsContainer && resultsContainer.style.display !== 'none';
        
        if (!isResultsVisible || this.searchResults.length === 0) return;
        
        switch (e.key) {
            case 'ArrowDown':
                e.preventDefault();
                this.selectedIndex = Math.min(this.selectedIndex + 1, this.searchResults.length - 1);
                this.highlightResult(this.selectedIndex);
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
                this.highlightResult(this.selectedIndex);
                break;
                
            case 'Enter':
                e.preventDefault();
                if (this.selectedIndex >= 0 && this.selectedIndex < this.searchResults.length) {
                    const selectedStock = this.searchResults[this.selectedIndex];
                    this.selectStock(selectedStock.Symbol);
                }
                break;
                
            case 'Escape':
                e.preventDefault();
                this.hideSearchResults();
                this.searchElement.blur();
                break;
                
            case 'Tab':
                this.hideSearchResults();
                break;
        }
    }
    
    highlightResult(index) {
        // Remove previous highlights
        document.querySelectorAll('.search-result-item').forEach(item => {
            item.classList.remove('highlighted');
        });
        
        // Highlight current item
        if (index >= 0) {
            const item = document.querySelector(`[data-index="${index}"]`);
            if (item) {
                item.classList.add('highlighted');
                item.scrollIntoView({ block: 'nearest' });
            }
        }
        
        this.selectedIndex = index;
    }
    
    selectStock(symbol) {
        // Add to watchlist by default when selecting
        this.addToWatchlist(symbol);
    }
    
    async addToWatchlist(symbol) {
        try {
            // Show loading state on the button
            const btn = document.querySelector(`[data-symbol="${symbol}"].add-to-watchlist`);
            if (btn) {
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Adding...</span>';
                btn.disabled = true;
            }
            
            const actionData = {
                Stock: symbol,
                AddDel: 1,
                GameType: dashboard ? dashboard.getGameType() : ""
            };
            
            await new Promise((resolve, reject) => {
                $.ajax({
                    url: "/api/AddDelete",
                    type: "GET",
                    data: actionData,
                    contentType: "application/json",
                    success: resolve,
                    error: reject
                });
            });
            
            // Success feedback
            this.showSuccessAnimation(symbol);
            
            if (dashboard) {
                dashboard.loadWatchlistData();
                dashboard.showNotification(`${symbol} added to watchlist`, 'success');
            }
            
            // Clear search and hide results
            this.clearSearch();
            
        } catch (error) {
            console.error('Failed to add to watchlist:', error);
            
            if (dashboard) {
                dashboard.showNotification('Failed to add stock to watchlist', 'error');
            }
            
            // Reset button state
            const btn = document.querySelector(`[data-symbol="${symbol}"].add-to-watchlist`);
            if (btn) {
                btn.innerHTML = '<i class="fas fa-plus"></i><span>Add</span>';
                btn.disabled = false;
            }
        }
    }
    
    openTradeModal(symbol) {
        // Get stock price first, then open modal
        const stock = this.searchResults.find(s => s.Symbol === symbol);
        if (stock && dashboard) {
            dashboard.openTradeModal(symbol, stock.Price || 0);
        }
        this.hideSearchResults();
    }
    
    showSuccessAnimation(symbol) {
        const btn = document.querySelector(`[data-symbol="${symbol}"].add-to-watchlist`);
        if (btn) {
            btn.innerHTML = '<i class="fas fa-check"></i><span>Added!</span>';
            btn.classList.add('success');
            
            setTimeout(() => {
                btn.innerHTML = '<i class="fas fa-plus"></i><span>Add</span>';
                btn.classList.remove('success');
                btn.disabled = false;
            }, 1500);
        }
    }
    
    showLoading() {
        const loading = document.getElementById('searchLoading');
        const resultsList = document.getElementById('searchResultsList');
        const noResults = document.getElementById('searchNoResults');
        
        if (loading) loading.style.display = 'flex';
        if (resultsList) resultsList.innerHTML = '';
        if (noResults) noResults.style.display = 'none';
        
        this.showSearchResults();
    }
    
    hideLoading() {
        const loading = document.getElementById('searchLoading');
        if (loading) loading.style.display = 'none';
    }
    
    showError() {
        this.hideLoading();
        const resultsList = document.getElementById('searchResultsList');
        if (resultsList) {
            resultsList.innerHTML = `
                <div class="search-error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>Search failed. Please try again.</span>
                </div>
            `;
        }
        this.showSearchResults();
    }
    
    showSearchResults() {
        const container = document.getElementById('searchResultsContainer');
        if (container) {
            container.style.display = 'block';
            // Add animation class
            setTimeout(() => {
                container.classList.add('show');
            }, 10);
        }
    }
    
    hideSearchResults() {
        const container = document.getElementById('searchResultsContainer');
        if (container) {
            container.classList.remove('show');
            setTimeout(() => {
                container.style.display = 'none';
            }, 200);
        }
        this.selectedIndex = -1;
    }
    
    clearSearch() {
        if (this.searchElement) {
            this.searchElement.value = '';
            this.searchElement.focus();
        }
        
        const clearBtn = document.getElementById('clearSearchBtn');
        if (clearBtn) {
            clearBtn.style.display = 'none';
        }
        
        this.hideSearchResults();
        this.searchResults = [];
    }
    
    isMouseOverResults() {
        return this.mouseOverResults || false;
    }
    
    focus() {
        if (this.searchElement) {
            this.searchElement.focus();
        }
    }
}

// Initialize the search manager
let watchlistSearch;
document.addEventListener('DOMContentLoaded', () => {
    // Wait a bit for the dashboard to initialize
    setTimeout(() => {
        watchlistSearch = new WatchlistSearchManager();
    }, 500);
});

// Export for global access
window.WatchlistSearchManager = WatchlistSearchManager;
// Modern Watchlist Display with Real-time Updates
class ModernWatchlistManager {
    constructor() {
        this.watchlistData = [];
        this.updateInterval = 5000; // 5 seconds
        this.animationDuration = 300;
        this.priceUpdateTimeout = null;
        this.sortOrder = 'name'; // name, price, change
        this.sortDirection = 'asc'; // asc, desc
        
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.loadWatchlistData();
        this.startRealTimeUpdates();
    }
    
    setupEventListeners() {
        // Sort controls
        document.addEventListener('click', (e) => {
            if (e.target.closest('.watchlist-sort-btn')) {
                const sortType = e.target.closest('.watchlist-sort-btn').dataset.sort;
                this.handleSort(sortType);
            }
            
            if (e.target.closest('.watchlist-view-toggle')) {
                this.toggleViewMode();
            }
        });
        
        // Refresh button
        document.addEventListener('click', (e) => {
            if (e.target.closest('.watchlist-refresh-btn')) {
                this.refreshWatchlist();
            }
        });
    }
    
    async loadWatchlistData() {
        try {
            this.showLoadingState();
            
            const data = await this.fetchWatchlistData();
            this.watchlistData = data || [];
            this.renderWatchlist();
            
        } catch (error) {
            console.error('Failed to load watchlist:', error);
            this.showErrorState();
        }
    }
    
    fetchWatchlistData() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: "/api/UserWatchlist",
                dataType: "json",
                data: { "GameType": this.getGameType() },
                contentType: "application/json",
                success: (data) => {
                    try {
                        const parsedData = JSON.parse(data);
                        resolve(parsedData.Value || []);
                    } catch (e) {
                        reject(e);
                    }
                },
                error: (xhr, status, error) => {
                    reject(error);
                }
            });
        });
    }
    
    renderWatchlist() {
        const container = document.getElementById('watchlistTable');
        if (!container) return;
        
        if (!this.watchlistData || this.watchlistData.length === 0) {
            container.innerHTML = this.getEmptyWatchlistHTML();
            return;
        }
        
        // Sort data before rendering
        const sortedData = this.sortWatchlistData(this.watchlistData);
        
        const watchlistHTML = `
            <div class="modern-watchlist-container">
                <div class="watchlist-header">
                    <div class="watchlist-controls">
                        <div class="controls-left">
                            <h3 class="watchlist-title">
                                <i class="fas fa-eye"></i>
                                Watchlist (${sortedData.length})
                            </h3>
                        </div>
                        <div class="controls-right">
                            <div class="sort-controls">
                                <button class="watchlist-sort-btn ${this.sortOrder === 'name' ? 'active' : ''}" 
                                        data-sort="name" title="Sort by Name">
                                    <i class="fas fa-sort-alpha-${this.sortDirection}"></i>
                                </button>
                                <button class="watchlist-sort-btn ${this.sortOrder === 'price' ? 'active' : ''}" 
                                        data-sort="price" title="Sort by Price">
                                    <i class="fas fa-sort-numeric-${this.sortDirection}"></i>
                                </button>
                                <button class="watchlist-sort-btn ${this.sortOrder === 'change' ? 'active' : ''}" 
                                        data-sort="change" title="Sort by Change">
                                    <i class="fas fa-sort-amount-${this.sortDirection}"></i>
                                </button>
                            </div>
                            <button class="watchlist-refresh-btn" title="Refresh Watchlist">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="watchlist-view-toggle" title="Toggle View">
                                <i class="fas fa-th-large"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="watchlist-content">
                    <div class="watchlist-grid" id="watchlistGrid">
                        ${this.renderWatchlistItems(sortedData)}
                    </div>
                </div>
            </div>
        `;
        
        container.innerHTML = watchlistHTML;
        this.addWatchlistEventListeners();
        this.animateWatchlistItems();
    }
    
    renderWatchlistItems(data) {
        return data.map((stock, index) => this.createWatchlistItemHTML(stock, index)).join('');
    }
    
    createWatchlistItemHTML(stock, index) {
        // Calculate mock change data (in real app, this would come from API)
        const mockChange = (Math.random() - 0.5) * 10; // Random change between -5 and +5
        const mockChangePercent = stock.Price > 0 ? (mockChange / stock.Price) * 100 : 0;
        
        const changeClass = mockChange >= 0 ? 'positive' : 'negative';
        const changeIcon = mockChange >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
        
        return `
            <div class="watchlist-item" 
                 data-symbol="${stock.Name}" 
                 data-index="${index}"
                 style="animation-delay: ${index * 50}ms">
                <div class="item-header">
                    <div class="stock-info">
                        <div class="symbol">${stock.Name}</div>
                        <div class="company-name">${stock.CompanyName || stock.Name}</div>
                    </div>
                    <div class="item-actions">
                        <button class="action-btn trade-btn" 
                                onclick="modernWatchlist.openTradeModal('${stock.Name}', ${stock.Price})"
                                title="Trade ${stock.Name}">
                            <i class="fas fa-exchange-alt"></i>
                        </button>
                        <button class="action-btn remove-btn" 
                                onclick="modernWatchlist.removeFromWatchlist('${stock.Name}')"
                                title="Remove from Watchlist">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                
                <div class="item-body">
                    <div class="price-section">
                        <div class="current-price" data-price="${stock.Price}">
                            ₹${parseFloat(stock.Price).toFixed(2)}
                        </div>
                        <div class="price-change ${changeClass}">
                            <i class="fas ${changeIcon}"></i>
                            <span class="change-amount">₹${Math.abs(mockChange).toFixed(2)}</span>
                            <span class="change-percent">(${mockChangePercent >= 0 ? '+' : ''}${mockChangePercent.toFixed(2)}%)</span>
                        </div>
                    </div>
                    
                    <div class="item-footer">
                        <div class="last-updated">
                            <i class="fas fa-clock"></i>
                            <span class="update-time">Just now</span>
                        </div>
                        <div class="quick-actions">
                            <button class="quick-action-btn" onclick="modernWatchlist.addToPortfolio('${stock.Name}')">
                                <i class="fas fa-plus"></i>
                                <span>Buy</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="item-overlay" onclick="modernWatchlist.showStockDetails('${stock.Name}')">
                    <div class="overlay-content">
                        <i class="fas fa-chart-line"></i>
                        <span>View Details</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    sortWatchlistData(data) {
        return [...data].sort((a, b) => {
            let aValue, bValue;
            
            switch (this.sortOrder) {
                case 'name':
                    aValue = a.Name.toLowerCase();
                    bValue = b.Name.toLowerCase();
                    break;
                case 'price':
                    aValue = parseFloat(a.Price) || 0;
                    bValue = parseFloat(b.Price) || 0;
                    break;
                case 'change':
                    // Mock change calculation for sorting
                    aValue = Math.random() - 0.5;
                    bValue = Math.random() - 0.5;
                    break;
                default:
                    return 0;
            }
            
            if (this.sortDirection === 'asc') {
                return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
            } else {
                return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
            }
        });
    }
    
    handleSort(sortType) {
        if (this.sortOrder === sortType) {
            // Toggle direction if same sort type
            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            // New sort type, default to ascending
            this.sortOrder = sortType;
            this.sortDirection = 'asc';
        }
        
        this.renderWatchlist();
    }
    
    addWatchlistEventListeners() {
        // Add hover effects and click handlers
        document.querySelectorAll('.watchlist-item').forEach(item => {
            item.addEventListener('mouseenter', () => {
                item.classList.add('hovered');
            });
            
            item.addEventListener('mouseleave', () => {
                item.classList.remove('hovered');
            });
        });
        
        // Add refresh button animation
        const refreshBtn = document.querySelector('.watchlist-refresh-btn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                refreshBtn.classList.add('spinning');
                setTimeout(() => {
                    refreshBtn.classList.remove('spinning');
                }, 1000);
            });
        }
    }
    
    animateWatchlistItems() {
        const items = document.querySelectorAll('.watchlist-item');
        items.forEach((item, index) => {
            setTimeout(() => {
                item.classList.add('animate-in');
            }, index * 50);
        });
    }
    
    startRealTimeUpdates() {
        // Simulate real-time price updates
        setInterval(() => {
            this.updatePrices();
        }, this.updateInterval);
    }
    
    updatePrices() {
        const priceElements = document.querySelectorAll('.current-price');
        
        priceElements.forEach(element => {
            const currentPrice = parseFloat(element.dataset.price);
            if (currentPrice > 0) {
                // Simulate price change (±2%)
                const changePercent = (Math.random() - 0.5) * 0.04; // ±2%
                const newPrice = currentPrice * (1 + changePercent);
                
                this.animatePriceUpdate(element, newPrice, changePercent > 0);
                element.dataset.price = newPrice.toFixed(2);
            }
        });
        
        this.updateTimestamps();
    }
    
    animatePriceUpdate(element, newPrice, isIncrease) {
        const item = element.closest('.watchlist-item');
        const changeElement = item.querySelector('.price-change');
        
        // Add update animation
        element.classList.add('price-updating');
        item.classList.add('price-flash', isIncrease ? 'flash-positive' : 'flash-negative');
        
        // Update price
        setTimeout(() => {
            element.textContent = `₹${newPrice.toFixed(2)}`;
            
            // Update change indicator
            const changeClass = isIncrease ? 'positive' : 'negative';
            const changeIcon = isIncrease ? 'fa-arrow-up' : 'fa-arrow-down';
            
            changeElement.className = `price-change ${changeClass}`;
            changeElement.querySelector('i').className = `fas ${changeIcon}`;
            
            // Remove animation classes
            setTimeout(() => {
                element.classList.remove('price-updating');
                item.classList.remove('price-flash', 'flash-positive', 'flash-negative');
            }, 300);
        }, 150);
    }
    
    updateTimestamps() {
        const timeElements = document.querySelectorAll('.update-time');
        timeElements.forEach(element => {
            element.textContent = 'Just now';
        });
    }
    
    async removeFromWatchlist(symbol) {
        const item = document.querySelector(`[data-symbol="${symbol}"]`);
        if (!item) return;
        
        // Show confirmation
        if (!confirm(`Remove ${symbol} from watchlist?`)) return;
        
        try {
            // Add removing animation
            item.classList.add('removing');
            
            const actionData = {
                Stock: symbol,
                AddDel: 0,
                GameType: this.getGameType()
            };
            
            await new Promise((resolve, reject) => {
                $.ajax({
                    url: "/api/AddDelete",
                    type: "GET",
                    data: actionData,
                    contentType: "application/json",
                    success: resolve,
                    error: reject
                });
            });
            
            // Animate removal
            setTimeout(() => {
                item.style.transform = 'translateX(-100%)';
                item.style.opacity = '0';
                
                setTimeout(() => {
                    this.loadWatchlistData();
                    this.showNotification(`${symbol} removed from watchlist`, 'success');
                }, this.animationDuration);
            }, 200);
            
        } catch (error) {
            console.error('Failed to remove from watchlist:', error);
            item.classList.remove('removing');
            this.showNotification('Failed to remove stock from watchlist', 'error');
        }
    }
    
    openTradeModal(symbol, price) {
        // Use new modern stock modal if available
        if (window.stockModal) {
            const stock = this.watchlistData.find(s => s.Name === symbol);
            const stockData = {
                symbol: symbol,
                name: stock?.CompanyName || symbol,
                currentPrice: price,
                price: price,
                change: 0, // Would be calculated from real data
                changePercent: 0,
                open: price,
                high: price,
                low: price,
                prevClose: price,
                volume: 0
            };
            window.stockModal.show(stockData);
        } else if (dashboard && dashboard.openTradeModal) {
            dashboard.openTradeModal(symbol, price);
        } else {
            // Fallback to existing modal
            $("#mStock").html(symbol);
            $("#mPrice").html(price);
            $("#buyButton").prop("disabled", false);
            $("#sellButton").prop("disabled", false);
            $('#myModal').modal('show');
        }
    }
    
    addToPortfolio(symbol) {
        const stock = this.watchlistData.find(s => s.Name === symbol);
        if (stock) {
            this.openTradeModal(symbol, stock.Price);
        }
    }
    
    showStockDetails(symbol) {
        // Use new modern stock modal if available
        if (window.stockModal) {
            const stock = this.watchlistData.find(s => s.Name === symbol);
            if (stock) {
                const stockData = {
                    symbol: symbol,
                    name: stock.CompanyName || symbol,
                    currentPrice: stock.Price,
                    price: stock.Price,
                    change: 0, // Would be calculated from real data
                    changePercent: 0,
                    open: stock.Price,
                    high: stock.Price,
                    low: stock.Price,
                    prevClose: stock.Price,
                    volume: 0
                };
                window.stockModal.show(stockData);
            }
        } else {
            // Fallback - just open trade modal
            const stock = this.watchlistData.find(s => s.Name === symbol);
            if (stock) {
                this.openTradeModal(symbol, stock.Price);
            }
        }
    }
    
    toggleViewMode() {
        const grid = document.getElementById('watchlistGrid');
        if (grid) {
            grid.classList.toggle('compact-view');
            
            const toggleBtn = document.querySelector('.watchlist-view-toggle i');
            if (toggleBtn) {
                toggleBtn.className = grid.classList.contains('compact-view') ? 
                    'fas fa-th-list' : 'fas fa-th-large';
            }
        }
    }
    
    refreshWatchlist() {
        this.loadWatchlistData();
    }
    
    showLoadingState() {
        const container = document.getElementById('watchlistTable');
        if (container) {
            container.innerHTML = `
                <div class="watchlist-loading">
                    <div class="loading-spinner"></div>
                    <span>Loading watchlist...</span>
                </div>
            `;
        }
    }
    
    showErrorState() {
        const container = document.getElementById('watchlistTable');
        if (container) {
            container.innerHTML = `
                <div class="watchlist-error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Failed to load watchlist</h3>
                    <p>Please check your connection and try again</p>
                    <button class="btn btn-primary" onclick="modernWatchlist.refreshWatchlist()">
                        <i class="fas fa-retry"></i>
                        Retry
                    </button>
                </div>
            `;
        }
    }
    
    getEmptyWatchlistHTML() {
        return `
            <div class="empty-watchlist">
                <div class="empty-icon">
                    <i class="fas fa-eye-slash"></i>
                </div>
                <h3 class="empty-title">Your watchlist is empty</h3>
                <p class="empty-message">Add stocks to track their performance and get real-time updates</p>
                <button class="btn btn-primary" onclick="watchlistSearch?.focus()">
                    <i class="fas fa-plus"></i>
                    Add Stocks
                </button>
            </div>
        `;
    }
    
    showNotification(message, type = 'info') {
        if (dashboard && dashboard.showNotification) {
            dashboard.showNotification(message, type);
        } else {
            // Simple fallback notification
            console.log(`${type.toUpperCase()}: ${message}`);
        }
    }
    
    getGameType() {
        if (dashboard && dashboard.getGameType) {
            return dashboard.getGameType();
        }
        
        // Fallback
        const type = $("#mainGrid")?.attr("data-value");
        switch (type) {
            case "Competition":
                return "C1";
            default:
                return "";
        }
    }
}

// Initialize the modern watchlist
let modernWatchlist;
document.addEventListener('DOMContentLoaded', () => {
    // Wait for dashboard to initialize
    setTimeout(() => {
        modernWatchlist = new ModernWatchlistManager();
    }, 1000);
});

// Export for global access
window.ModernWatchlistManager = ModernWatchlistManager;
/**
 * Modern Stock Details Modal
 * Handles stock information display, chart rendering, and order placement
 */

class StockModal {
    constructor() {
        this.modal = null;
        this.confirmationModal = null;
        this.currentStock = null;
        this.chart = null;
        this.currentTimeframe = '1W';
        this.orderType = 'buy';
        this.isMarketOrder = true;
        
        this.init();
    }

    init() {
        this.modal = document.getElementById('stockModal');
        this.confirmationModal = document.getElementById('orderConfirmationModal');
        
        if (!this.modal) return;
        
        this.bindEvents();
        this.initChart();
    }

    bindEvents() {
        // Order type tabs
        const buyTab = document.getElementById('buyTab');
        const sellTab = document.getElementById('sellTab');
        
        buyTab?.addEventListener('click', () => this.setOrderType('buy'));
        sellTab?.addEventListener('click', () => this.setOrderType('sell'));

        // Order type switch (Market/Limit)
        const orderTypeSwitch = document.getElementById('orderTypeSwitch');
        orderTypeSwitch?.addEventListener('change', (e) => {
            this.isMarketOrder = !e.target.checked;
            this.togglePriceInput();
            this.updateOrderSummary();
        });

        // Quantity input
        const quantityInput = document.getElementById('modalQuantity');
        quantityInput?.addEventListener('input', () => {
            this.validateQuantity();
            this.updateOrderSummary();
        });

        // Price input
        const priceInput = document.getElementById('modalOrderPrice');
        priceInput?.addEventListener('input', () => {
            this.validatePrice();
            this.updateOrderSummary();
        });

        // Place order button
        const placeOrderBtn = document.getElementById('placeOrderBtn');
        placeOrderBtn?.addEventListener('click', () => this.showOrderConfirmation());

        // Confirm order button
        const confirmOrderBtn = document.getElementById('confirmOrderBtn');
        confirmOrderBtn?.addEventListener('click', () => this.placeOrder());

        // Timeframe buttons
        const timeframeButtons = document.querySelectorAll('.timeframe-buttons .btn');
        timeframeButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const timeframe = e.target.dataset.timeframe;
                this.setTimeframe(timeframe);
            });
        });

        // Chart type buttons
        const chartTypeButtons = document.querySelectorAll('.chart-type-btn');
        chartTypeButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const type = e.target.closest('.chart-type-btn').dataset.type;
                this.setChartType(type);
            });
        });

        // Technical indicator buttons
        const indicatorButtons = document.querySelectorAll('.indicator-btn');
        indicatorButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const indicator = e.target.dataset.indicator;
                this.toggleIndicator(indicator);
            });
        });

        // Reset zoom button
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        resetZoomBtn?.addEventListener('click', () => {
            this.resetChartZoom();
        });

        // Real-time updates toggle
        const realTimeToggle = document.getElementById('realTimeUpdates');
        realTimeToggle?.addEventListener('change', (e) => {
            if (e.target.checked) {
                this.enableRealTimeUpdates();
            } else {
                this.disableRealTimeUpdates();
            }
        });

        // Zoom controls
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetZoomBtn2 = document.getElementById('resetZoomBtn2');

        zoomInBtn?.addEventListener('click', () => {
            if (this.chart && this.chart.chart && this.chart.chart.zoom) {
                this.chart.chart.zoom(1.1);
            }
        });

        zoomOutBtn?.addEventListener('click', () => {
            if (this.chart && this.chart.chart && this.chart.chart.zoom) {
                this.chart.chart.zoom(0.9);
            }
        });

        resetZoomBtn2?.addEventListener('click', () => {
            this.resetChartZoom();
        });

        // Modal events
        this.modal.addEventListener('shown.bs.modal', () => {
            this.onModalShown();
        });

        this.modal.addEventListener('hidden.bs.modal', () => {
            this.onModalHidden();
        });
    }

    /**
     * Show stock modal with stock data
     */
    show(stockData) {
        if (!this.modal) return;

        this.currentStock = stockData;
        this.populateStockData(stockData);
        this.resetForm();
        
        // Show modal using Bootstrap 5
        const bsModal = new bootstrap.Modal(this.modal);
        bsModal.show();
    }

    /**
     * Populate modal with stock data
     */
    populateStockData(stock) {
        // Header information
        document.getElementById('modalStockSymbol').textContent = stock.symbol || 'N/A';
        document.getElementById('modalStockName').textContent = stock.name || stock.symbol || 'N/A';

        // Price information
        const currentPrice = parseFloat(stock.currentPrice || stock.price || 0);
        const change = parseFloat(stock.change || 0);
        const changePercent = parseFloat(stock.changePercent || 0);

        document.getElementById('modalCurrentPrice').textContent = `₹${currentPrice.toFixed(2)}`;
        
        const changeElement = document.getElementById('modalPriceChange');
        const changeClass = change >= 0 ? 'positive' : 'negative';
        changeElement.className = `change ${changeClass}`;
        changeElement.innerHTML = `
            <span class="change-value">${change >= 0 ? '+' : ''}₹${change.toFixed(2)}</span>
            <span class="change-percent">(${change >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)</span>
        `;

        // Market data
        document.getElementById('modalOpenPrice').textContent = `₹${(stock.open || currentPrice).toFixed(2)}`;
        document.getElementById('modalHighPrice').textContent = `₹${(stock.high || currentPrice).toFixed(2)}`;
        document.getElementById('modalLowPrice').textContent = `₹${(stock.low || currentPrice).toFixed(2)}`;
        document.getElementById('modalPrevClose').textContent = `₹${(stock.prevClose || currentPrice).toFixed(2)}`;
        document.getElementById('modalVolume').textContent = this.formatVolume(stock.volume || 0);

        // Update order price placeholder
        const priceInput = document.getElementById('modalOrderPrice');
        if (priceInput) {
            priceInput.placeholder = `₹${currentPrice.toFixed(2)}`;
        }
    }

    /**
     * Format volume for display
     */
    formatVolume(volume) {
        if (volume >= 1000000) {
            return `${(volume / 1000000).toFixed(1)}M`;
        } else if (volume >= 1000) {
            return `${(volume / 1000).toFixed(1)}K`;
        }
        return volume.toString();
    }

    /**
     * Initialize chart
     */
    initChart() {
        // Initialize enhanced stock chart with candlestick support
        this.chart = new StockChart('stockChart', {
            responsive: true,
            maintainAspectRatio: false,
            showVolume: true,
            showIndicators: true,
            enableZoom: true,
            enablePan: true
        });
        
        // Override chart event handlers
        this.chart.onDataPointClick = (data, index) => {
            this.onChartDataPointClick(data, index);
        };
        
        this.chart.onChartUpdated = (chartData) => {
            this.onChartUpdated(chartData);
        };
    }

    /**
     * Load chart data for current stock and timeframe
     */
    async loadChartData() {
        if (!this.currentStock || !this.chart) return;

        // Use the enhanced chart's loadData method
        await this.chart.loadData(this.currentStock.symbol, this.currentTimeframe);
    }

    /**
     * Handle chart data point click
     */
    onChartDataPointClick(data, index) {
        // Show detailed information about the selected data point
        console.log('Chart data point clicked:', data, index);
        
        // You can implement additional functionality here like:
        // - Show detailed OHLC info in a tooltip
        // - Update order price to the clicked price
        // - Highlight the selected time period
    }

    /**
     * Handle chart update completion
     */
    onChartUpdated(chartData) {
        // Update any UI elements that depend on chart data
        console.log('Chart updated with data:', chartData);
        
        // Update chart type buttons if needed
        this.updateChartTypeButtons();
        
        // Enable real-time updates if checkbox is checked
        const realTimeToggle = document.getElementById('realTimeUpdates');
        if (realTimeToggle && realTimeToggle.checked) {
            this.enableRealTimeUpdates();
        }
    }

    /**
     * Enable real-time updates
     */
    enableRealTimeUpdates() {
        if (this.chart && this.chart.enableRealTimeUpdates) {
            this.chart.enableRealTimeUpdates(30000); // Update every 30 seconds
            
            // Override the real-time update handler
            this.chart.onRealTimeUpdate = (realtimeData) => {
                this.onRealTimeUpdate(realtimeData);
            };
        }
    }

    /**
     * Disable real-time updates
     */
    disableRealTimeUpdates() {
        if (this.chart && this.chart.disableRealTimeUpdates) {
            this.chart.disableRealTimeUpdates();
        }
    }

    /**
     * Handle real-time price updates
     */
    onRealTimeUpdate(realtimeData) {
        // Update the current price display
        if (realtimeData.price) {
            const currentPriceEl = document.getElementById('modalCurrentPrice');
            if (currentPriceEl) {
                currentPriceEl.textContent = `₹${realtimeData.price.toFixed(2)}`;
                
                // Add flash animation for price changes
                currentPriceEl.classList.add('price-flash');
                setTimeout(() => {
                    currentPriceEl.classList.remove('price-flash');
                }, 500);
            }
            
            // Update change indicator
            if (realtimeData.change) {
                const changeEl = document.getElementById('modalPriceChange');
                if (changeEl) {
                    const changePercent = (realtimeData.change / (realtimeData.price - realtimeData.change)) * 100;
                    const changeClass = realtimeData.change >= 0 ? 'positive' : 'negative';
                    
                    changeEl.className = `change ${changeClass}`;
                    changeEl.innerHTML = `
                        <span class="change-value">${realtimeData.change >= 0 ? '+' : ''}₹${realtimeData.change.toFixed(2)}</span>
                        <span class="change-percent">(${realtimeData.change >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)</span>
                    `;
                }
            }
        }
        
        // Update order price placeholder if in market order mode
        if (this.isMarketOrder) {
            const priceInput = document.getElementById('modalOrderPrice');
            if (priceInput && realtimeData.price) {
                priceInput.placeholder = `₹${realtimeData.price.toFixed(2)}`;
            }
        }
        
        // Update order summary
        this.updateOrderSummary();
    }

    /**
     * Update chart type button states
     */
    updateChartTypeButtons() {
        const chartTypeButtons = document.querySelectorAll('.chart-type-btn');
        chartTypeButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.type === this.chart.chartType) {
                btn.classList.add('active');
            }
        });
    }

    /**
     * Set chart timeframe
     */
    setTimeframe(timeframe) {
        this.currentTimeframe = timeframe;
        
        // Update active button
        document.querySelectorAll('.timeframe-buttons .btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-timeframe="${timeframe}"]`)?.classList.add('active');
        
        this.loadChartData();
    }

    /**
     * Set chart type (candlestick, line, area)
     */
    setChartType(type) {
        if (this.chart && this.chart.setChartType) {
            this.chart.setChartType(type);
            this.updateChartTypeButtons();
        }
    }

    /**
     * Toggle technical indicator
     */
    toggleIndicator(indicator) {
        if (!this.chart) return;
        
        if (this.chart.indicators.has(indicator)) {
            this.chart.removeIndicator(indicator);
        } else {
            this.chart.addIndicator(indicator);
        }
        
        // Update indicator button state
        const btn = document.querySelector(`[data-indicator="${indicator}"]`);
        if (btn) {
            btn.classList.toggle('active');
        }
    }

    /**
     * Reset chart zoom
     */
    resetChartZoom() {
        if (this.chart && this.chart.resetZoom) {
            this.chart.resetZoom();
        }
    }

    /**
     * Set order type (buy/sell)
     */
    setOrderType(type) {
        this.orderType = type;
        
        // Update tab appearance
        document.querySelectorAll('.order-type-tabs .tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById(type === 'buy' ? 'buyTab' : 'sellTab')?.classList.add('active');
        
        // Update button text
        const placeOrderBtn = document.getElementById('placeOrderBtn');
        if (placeOrderBtn) {
            const btnText = placeOrderBtn.querySelector('.btn-text');
            if (btnText) {
                btnText.textContent = type === 'buy' ? 'Place Buy Order' : 'Place Sell Order';
            }
        }
        
        this.updateOrderSummary();
    }

    /**
     * Toggle price input visibility based on order type
     */
    togglePriceInput() {
        const priceGroup = document.getElementById('priceGroup');
        if (priceGroup) {
            priceGroup.style.display = this.isMarketOrder ? 'none' : 'block';
        }
        
        // Clear price if switching to market order
        if (this.isMarketOrder) {
            const priceInput = document.getElementById('modalOrderPrice');
            if (priceInput) {
                priceInput.value = '';
            }
        }
    }

    /**
     * Validate quantity input
     */
    validateQuantity() {
        const quantityInput = document.getElementById('modalQuantity');
        const feedback = document.getElementById('quantityFeedback');
        
        if (!quantityInput || !feedback) return true;

        const quantity = parseInt(quantityInput.value);
        
        if (!quantity || quantity < 1) {
            quantityInput.classList.add('is-invalid');
            quantityInput.classList.remove('is-valid');
            feedback.textContent = 'Please enter a valid quantity';
            feedback.className = 'input-feedback invalid';
            return false;
        }
        
        quantityInput.classList.remove('is-invalid');
        quantityInput.classList.add('is-valid');
        feedback.textContent = '';
        feedback.className = 'input-feedback';
        return true;
    }

    /**
     * Validate price input for limit orders
     */
    validatePrice() {
        if (this.isMarketOrder) return true;

        const priceInput = document.getElementById('modalOrderPrice');
        const feedback = document.getElementById('priceFeedback');
        
        if (!priceInput || !feedback) return true;

        const price = parseFloat(priceInput.value);
        
        if (!price || price <= 0) {
            priceInput.classList.add('is-invalid');
            priceInput.classList.remove('is-valid');
            feedback.textContent = 'Please enter a valid price';
            feedback.className = 'input-feedback invalid';
            return false;
        }
        
        priceInput.classList.remove('is-invalid');
        priceInput.classList.add('is-valid');
        feedback.textContent = '';
        feedback.className = 'input-feedback';
        return true;
    }

    /**
     * Update order summary with real-time calculations
     */
    updateOrderSummary() {
        const quantityInput = document.getElementById('modalQuantity');
        const priceInput = document.getElementById('modalOrderPrice');
        const estimatedValue = document.getElementById('estimatedValue');
        const placeOrderBtn = document.getElementById('placeOrderBtn');
        
        if (!quantityInput || !estimatedValue || !placeOrderBtn) return;

        const quantity = parseInt(quantityInput.value) || 0;
        let price = 0;
        
        if (this.isMarketOrder) {
            price = parseFloat(this.currentStock?.currentPrice || this.currentStock?.price || 0);
        } else {
            price = parseFloat(priceInput?.value || 0);
        }
        
        const totalValue = quantity * price;
        
        // Update estimated value with animation
        this.animateValueChange(estimatedValue, totalValue);
        
        // Update order summary with additional details
        this.updateOrderSummaryDetails(quantity, price, totalValue);
        
        // Enable/disable place order button with visual feedback
        const isValid = this.validateQuantity() && this.validatePrice() && quantity > 0 && price > 0;
        this.updateOrderButton(isValid, quantity, price);
    }

    /**
     * Animate value changes in the order summary
     */
    animateValueChange(element, newValue) {
        const currentValue = parseFloat(element.textContent.replace(/[₹,]/g, '')) || 0;
        
        if (Math.abs(newValue - currentValue) > 0.01) {
            element.classList.add('value-updating');
            
            setTimeout(() => {
                element.textContent = `₹${newValue.toFixed(2)}`;
                element.classList.remove('value-updating');
            }, 150);
        } else {
            element.textContent = `₹${newValue.toFixed(2)}`;
        }
    }

    /**
     * Update order summary with additional details
     */
    updateOrderSummaryDetails(quantity, price, totalValue) {
        const orderSummary = document.getElementById('orderSummary');
        if (!orderSummary) return;

        // Calculate additional fees (mock calculation)
        const brokerage = totalValue * 0.0005; // 0.05% brokerage
        const taxes = totalValue * 0.001; // 0.1% taxes
        const totalCost = totalValue + brokerage + taxes;

        const summaryHTML = `
            <div class="summary-row">
                <span class="label">Quantity:</span>
                <span class="value">${quantity} shares</span>
            </div>
            <div class="summary-row">
                <span class="label">Price:</span>
                <span class="value">${this.isMarketOrder ? 'Market Price' : `₹${price.toFixed(2)}`}</span>
            </div>
            <div class="summary-row">
                <span class="label">Order Value:</span>
                <span class="value">₹${totalValue.toFixed(2)}</span>
            </div>
            <div class="summary-row fees">
                <span class="label">Est. Brokerage:</span>
                <span class="value">₹${brokerage.toFixed(2)}</span>
            </div>
            <div class="summary-row fees">
                <span class="label">Est. Taxes:</span>
                <span class="value">₹${taxes.toFixed(2)}</span>
            </div>
            <div class="summary-row total">
                <span class="label">Total ${this.orderType === 'buy' ? 'Cost' : 'Credit'}:</span>
                <span class="value">₹${totalCost.toFixed(2)}</span>
            </div>
        `;

        orderSummary.innerHTML = summaryHTML;
    }

    /**
     * Update order button state with visual feedback
     */
    updateOrderButton(isValid, quantity, price) {
        const placeOrderBtn = document.getElementById('placeOrderBtn');
        const btnText = placeOrderBtn?.querySelector('.btn-text');
        
        if (!placeOrderBtn || !btnText) return;

        placeOrderBtn.disabled = !isValid;
        
        if (isValid && quantity > 0 && price > 0) {
            const actionText = this.orderType === 'buy' ? 'Buy' : 'Sell';
            const orderTypeText = this.isMarketOrder ? 'Market' : 'Limit';
            btnText.textContent = `Place ${actionText} Order (${orderTypeText})`;
            placeOrderBtn.classList.remove('btn-disabled');
            placeOrderBtn.classList.add('btn-ready');
        } else {
            btnText.textContent = 'Enter Order Details';
            placeOrderBtn.classList.add('btn-disabled');
            placeOrderBtn.classList.remove('btn-ready');
        }
    }

    /**
     * Show order confirmation modal with detailed breakdown
     */
    showOrderConfirmation() {
        if (!this.validateQuantity() || !this.validatePrice()) return;

        const quantity = parseInt(document.getElementById('modalQuantity').value);
        const price = this.isMarketOrder 
            ? parseFloat(this.currentStock.currentPrice || this.currentStock.price)
            : parseFloat(document.getElementById('modalOrderPrice').value);
        
        const totalValue = quantity * price;
        
        // Calculate fees and total cost
        const brokerage = totalValue * 0.0005;
        const taxes = totalValue * 0.001;
        const totalCost = totalValue + brokerage + taxes;
        
        // Update confirmation modal title and icon based on order type
        const confirmationIcon = document.querySelector('.confirmation-modal .confirmation-icon');
        const confirmationTitle = document.querySelector('.confirmation-modal .confirmation-title');
        
        if (confirmationIcon && confirmationTitle) {
            if (this.orderType === 'buy') {
                confirmationIcon.className = 'confirmation-icon success';
                confirmationIcon.innerHTML = '<i class="fas fa-arrow-up"></i>';
                confirmationTitle.textContent = 'Confirm Buy Order';
            } else {
                confirmationIcon.className = 'confirmation-icon warning';
                confirmationIcon.innerHTML = '<i class="fas fa-arrow-down"></i>';
                confirmationTitle.textContent = 'Confirm Sell Order';
            }
        }
        
        // Populate detailed confirmation
        const orderDetails = document.getElementById('confirmationOrderDetails');
        if (orderDetails) {
            orderDetails.innerHTML = `
                <div class="order-header">
                    <div class="stock-symbol">${this.currentStock.symbol}</div>
                    <div class="stock-name">${this.currentStock.name}</div>
                </div>
                
                <div class="order-details-grid">
                    <div class="detail-row">
                        <span class="label">Action:</span>
                        <span class="value ${this.orderType}">${this.orderType.toUpperCase()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Quantity:</span>
                        <span class="value">${quantity} shares</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Order Type:</span>
                        <span class="value">${this.isMarketOrder ? 'Market Order' : 'Limit Order'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Price:</span>
                        <span class="value">${this.isMarketOrder ? 'Market Price' : `₹${price.toFixed(2)}`}</span>
                    </div>
                    <div class="detail-row subtotal">
                        <span class="label">Order Value:</span>
                        <span class="value">₹${totalValue.toFixed(2)}</span>
                    </div>
                    <div class="detail-row fees">
                        <span class="label">Brokerage:</span>
                        <span class="value">₹${brokerage.toFixed(2)}</span>
                    </div>
                    <div class="detail-row fees">
                        <span class="label">Taxes & Charges:</span>
                        <span class="value">₹${taxes.toFixed(2)}</span>
                    </div>
                    <div class="detail-row total">
                        <span class="label">Total ${this.orderType === 'buy' ? 'Debit' : 'Credit'}:</span>
                        <span class="value">₹${totalCost.toFixed(2)}</span>
                    </div>
                </div>
                
                <div class="order-warning">
                    <i class="fas fa-info-circle"></i>
                    <span>${this.isMarketOrder ? 
                        'Market orders execute immediately at the best available price.' : 
                        'Limit orders execute only when the stock reaches your specified price.'
                    }</span>
                </div>
            `;
        }
        
        // Update confirm button text
        const confirmBtn = document.getElementById('confirmOrderBtn');
        const btnText = confirmBtn?.querySelector('.btn-text');
        if (btnText) {
            btnText.textContent = `Confirm ${this.orderType.toUpperCase()} Order`;
        }
        
        // Show confirmation modal
        const bsModal = new bootstrap.Modal(this.confirmationModal);
        bsModal.show();
    }

    /**
     * Place the order
     */
    async placeOrder() {
        const confirmBtn = document.getElementById('confirmOrderBtn');
        const btnText = confirmBtn?.querySelector('.btn-text');
        const btnLoading = confirmBtn?.querySelector('.btn-loading');
        
        if (confirmBtn) {
            confirmBtn.disabled = true;
            if (btnText) btnText.style.display = 'none';
            if (btnLoading) btnLoading.style.display = 'block';
        }

        try {
            const orderData = {
                symbol: this.currentStock.symbol,
                orderType: this.orderType,
                quantity: parseInt(document.getElementById('modalQuantity').value),
                isMarketOrder: this.isMarketOrder,
                price: this.isMarketOrder ? null : parseFloat(document.getElementById('modalOrderPrice').value)
            };

            // Call the existing OnBuySell function or make API call
            const response = await this.submitOrder(orderData);
            
            if (response.success) {
                // Close modals
                bootstrap.Modal.getInstance(this.confirmationModal)?.hide();
                bootstrap.Modal.getInstance(this.modal)?.hide();
                
                // Show success notification
                if (window.dashboard) {
                    window.dashboard.showNotification(
                        `${this.orderType.toUpperCase()} order placed successfully for ${this.currentStock.symbol}`,
                        'success'
                    );
                    // Refresh data
                    window.dashboard.loadHoldingsData();
                    window.dashboard.loadWatchlistData();
                } else {
                    alert('Order placed successfully!');
                }
            } else {
                throw new Error(response.message || 'Order placement failed');
            }
        } catch (error) {
            console.error('Order placement error:', error);
            if (window.dashboard) {
                window.dashboard.showNotification('Failed to place order: ' + error.message, 'error');
            } else {
                alert('Failed to place order: ' + error.message);
            }
        } finally {
            if (confirmBtn) {
                confirmBtn.disabled = false;
                if (btnText) btnText.style.display = 'inline';
                if (btnLoading) btnLoading.style.display = 'none';
            }
        }
    }

    /**
     * Submit order to server
     */
    async submitOrder(orderData) {
        // Use existing OnBuySell functionality
        return new Promise((resolve) => {
            // Simulate the existing order placement
            const button = document.createElement('button');
            button.id = orderData.orderType === 'buy' ? 'buyButton' : 'sellButton';
            
            // Set up the modal data as expected by OnBuySell
            document.getElementById('mStock').textContent = orderData.symbol;
            document.getElementById('mQuantity').value = orderData.quantity;
            document.getElementById('mOrderPrice').value = orderData.price || '';
            
            // Call existing function
            if (typeof OnBuySell === 'function') {
                try {
                    OnBuySell(button);
                    resolve({ success: true });
                } catch (error) {
                    resolve({ success: false, message: error.message });
                }
            } else {
                resolve({ success: false, message: 'Order function not available' });
            }
        });
    }

    /**
     * Reset form to initial state
     */
    resetForm() {
        // Reset order type to buy
        this.setOrderType('buy');
        
        // Reset market order
        const orderTypeSwitch = document.getElementById('orderTypeSwitch');
        if (orderTypeSwitch) {
            orderTypeSwitch.checked = false;
            this.isMarketOrder = true;
            this.togglePriceInput();
        }
        
        // Clear inputs
        const quantityInput = document.getElementById('modalQuantity');
        const priceInput = document.getElementById('modalOrderPrice');
        
        if (quantityInput) {
            quantityInput.value = '';
            quantityInput.classList.remove('is-valid', 'is-invalid');
        }
        
        if (priceInput) {
            priceInput.value = '';
            priceInput.classList.remove('is-valid', 'is-invalid');
        }
        
        // Clear feedback
        const feedbacks = document.querySelectorAll('.input-feedback');
        feedbacks.forEach(feedback => {
            feedback.textContent = '';
            feedback.className = 'input-feedback';
        });
        
        // Reset order summary
        this.updateOrderSummary();
    }

    /**
     * Handle modal shown event
     */
    onModalShown() {
        // Load chart data
        this.loadChartData();
        
        // Focus on quantity input
        const quantityInput = document.getElementById('modalQuantity');
        if (quantityInput) {
            setTimeout(() => quantityInput.focus(), 100);
        }
    }

    /**
     * Handle modal hidden event
     */
    onModalHidden() {
        // Stop real-time updates
        this.disableRealTimeUpdates();
        
        // Reset form
        this.resetForm();
        
        // Clear current stock
        this.currentStock = null;
        
        // Reset chart if it exists
        if (this.chart && this.chart.chart) {
            // Clear all indicators
            this.chart.indicators.clear();
            
            // Reset chart type to candlestick
            this.chart.setChartType('candlestick');
        }
    }
}

// Initialize stock modal when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    window.stockModal = new StockModal();
});

// Helper function to show stock modal (for backward compatibility)
function showStockModal(stockData) {
    if (window.stockModal) {
        window.stockModal.show(stockData);
    }
}