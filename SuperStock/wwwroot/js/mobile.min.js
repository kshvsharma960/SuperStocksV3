// ==========================================================================
// MOBILE LAZY LOADING - Advanced lazy loading and performance optimization
// ==========================================================================

class MobileLazyLoader {
    constructor() {
        this.imageObserver = null;
        this.componentObserver = null;
        this.loadedImages = new Set();
        this.loadedComponents = new Set();
        this.isLowEndDevice = this.detectLowEndDevice();
        
        this.init();
    }

    init() {
        this.setupImageLazyLoading();
        this.setupComponentLazyLoading();
        this.setupIntersectionObservers();
        this.setupPreloadHints();
        this.monitorPerformance();
    }

    detectLowEndDevice() {
        const memory = navigator.deviceMemory || 4;
        const cores = navigator.hardwareConcurrency || 4;
        const connection = navigator.connection;
        
        return memory <= 2 || cores <= 2 || 
               (connection && (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g'));
    }

    setupImageLazyLoading() {
        // Create intersection observer for images
        this.imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    this.loadImage(entry.target);
                }
            });
        }, {
            rootMargin: this.isLowEndDevice ? '50px' : '100px',
            threshold: 0.01
        });

        // Observe all lazy images
        this.observeImages();
    }

    setupComponentLazyLoading() {
        // Create intersection observer for components
        this.componentObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    this.loadComponent(entry.target);
                }
            });
        }, {
            rootMargin: this.isLowEndDevice ? '100px' : '200px',
            threshold: 0.1
        });

        // Observe all lazy components
        this.observeComponents();
    }

    observeImages() {
        // Observe images with data-src attribute
        document.querySelectorAll('img[data-src]').forEach(img => {
            if (!this.loadedImages.has(img)) {
                this.imageObserver.observe(img);
            }
        });

        // Observe background images
        document.querySelectorAll('[data-bg-src]').forEach(element => {
            if (!this.loadedImages.has(element)) {
                this.imageObserver.observe(element);
            }
        });
    }

    observeComponents() {
        // Observe charts
        document.querySelectorAll('.chart-container[data-lazy]').forEach(chart => {
            if (!this.loadedComponents.has(chart)) {
                this.componentObserver.observe(chart);
            }
        });

        // Observe tables
        document.querySelectorAll('.table-container[data-lazy]').forEach(table => {
            if (!this.loadedComponents.has(table)) {
                this.componentObserver.observe(table);
            }
        });

        // Observe Lottie animations
        document.querySelectorAll('.lottie-container[data-lazy]').forEach(lottie => {
            if (!this.loadedComponents.has(lottie)) {
                this.componentObserver.observe(lottie);
            }
        });

        // Observe heavy content sections
        document.querySelectorAll('.heavy-content[data-lazy]').forEach(content => {
            if (!this.loadedComponents.has(content)) {
                this.componentObserver.observe(content);
            }
        });
    }

    loadImage(img) {
        if (this.loadedImages.has(img)) return;

        // Add loading class
        img.classList.add('loading');

        // Create loading placeholder
        this.createImagePlaceholder(img);

        // Load the image
        if (img.dataset.src) {
            this.loadRegularImage(img);
        } else if (img.dataset.bgSrc) {
            this.loadBackgroundImage(img);
        }

        this.loadedImages.add(img);
        this.imageObserver.unobserve(img);
    }

    createImagePlaceholder(img) {
        if (img.classList.contains('has-placeholder')) return;

        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder';
        placeholder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            z-index: 1;
        `;

        // Ensure parent has relative positioning
        if (getComputedStyle(img.parentNode).position === 'static') {
            img.parentNode.style.position = 'relative';
        }

        img.parentNode.appendChild(placeholder);
        img.classList.add('has-placeholder');

        // Add shimmer animation if not exists
        if (!document.querySelector('#shimmer-animation')) {
            const style = document.createElement('style');
            style.id = 'shimmer-animation';
            style.textContent = `
                @keyframes shimmer {
                    0% { background-position: -200% 0; }
                    100% { background-position: 200% 0; }
                }
            `;
            document.head.appendChild(style);
        }
    }

    loadRegularImage(img) {
        const tempImg = new Image();
        
        tempImg.onload = () => {
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            img.classList.remove('loading');
            img.classList.add('loaded');
            
            // Remove placeholder
            this.removePlaceholder(img);
            
            // Fade in effect
            img.style.opacity = '0';
            img.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                img.style.opacity = '1';
            }, 10);
        };

        tempImg.onerror = () => {
            img.classList.remove('loading');
            img.classList.add('error');
            this.removePlaceholder(img);
        };

        // Load appropriate quality based on device
        const src = this.getOptimalImageSrc(img);
        tempImg.src = src;
    }

    loadBackgroundImage(element) {
        const tempImg = new Image();
        
        tempImg.onload = () => {
            element.style.backgroundImage = `url(${element.dataset.bgSrc})`;
            element.removeAttribute('data-bg-src');
            element.classList.remove('loading');
            element.classList.add('loaded');
            
            this.removePlaceholder(element);
        };

        tempImg.onerror = () => {
            element.classList.remove('loading');
            element.classList.add('error');
            this.removePlaceholder(element);
        };

        const src = this.getOptimalImageSrc(element, 'bgSrc');
        tempImg.src = src;
    }

    getOptimalImageSrc(element, attribute = 'src') {
        const baseAttr = attribute === 'src' ? 'data-src' : 'data-bg-src';
        const baseSrc = element.getAttribute(baseAttr);
        
        // Return low quality version for slow connections
        if (this.isLowEndDevice || this.isSlowConnection()) {
            const lowQualityAttr = attribute === 'src' ? 'data-src-low' : 'data-bg-src-low';
            return element.getAttribute(lowQualityAttr) || baseSrc;
        }
        
        // Return WebP version if supported
        if (this.supportsWebP()) {
            const webpAttr = attribute === 'src' ? 'data-src-webp' : 'data-bg-src-webp';
            return element.getAttribute(webpAttr) || baseSrc;
        }
        
        return baseSrc;
    }

    removePlaceholder(element) {
        const placeholder = element.parentNode.querySelector('.image-placeholder');
        if (placeholder) {
            placeholder.style.opacity = '0';
            setTimeout(() => {
                if (placeholder.parentNode) {
                    placeholder.parentNode.removeChild(placeholder);
                }
            }, 300);
        }
    }

    loadComponent(component) {
        if (this.loadedComponents.has(component)) return;

        component.classList.add('loading');
        
        // Create loading indicator
        this.createComponentLoader(component);

        // Load based on component type
        if (component.classList.contains('chart-container')) {
            this.loadChart(component);
        } else if (component.classList.contains('table-container')) {
            this.loadTable(component);
        } else if (component.classList.contains('lottie-container')) {
            this.loadLottieAnimation(component);
        } else if (component.classList.contains('heavy-content')) {
            this.loadHeavyContent(component);
        }

        this.loadedComponents.add(component);
        this.componentObserver.unobserve(component);
    }

    createComponentLoader(component) {
        if (component.querySelector('.component-loader')) return;

        const loader = document.createElement('div');
        loader.className = 'component-loader';
        loader.innerHTML = `
            <div class="loader-content">
                <div class="loader-spinner"></div>
                <div class="loader-text">Loading...</div>
            </div>
        `;
        
        loader.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        `;

        const loaderContent = loader.querySelector('.loader-content');
        loaderContent.style.cssText = `
            text-align: center;
            color: #666;
        `;

        const spinner = loader.querySelector('.loader-spinner');
        spinner.style.cssText = `
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        `;

        // Ensure parent has relative positioning
        if (getComputedStyle(component).position === 'static') {
            component.style.position = 'relative';
        }

        component.appendChild(loader);

        // Add spin animation if not exists
        if (!document.querySelector('#spin-animation')) {
            const style = document.createElement('style');
            style.id = 'spin-animation';
            style.textContent = `
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);
        }
    }

    loadChart(container) {
        // Simulate chart loading delay
        const delay = this.isLowEndDevice ? 1000 : 500;
        
        setTimeout(() => {
            // Initialize chart
            if (window.initializeChart) {
                window.initializeChart(container);
            }
            
            this.removeComponentLoader(container);
            container.classList.remove('loading');
            container.classList.add('loaded');
            container.removeAttribute('data-lazy');
        }, delay);
    }

    loadTable(container) {
        // Load table data progressively
        const rows = container.querySelectorAll('tr[data-lazy]');
        const batchSize = this.isLowEndDevice ? 10 : 20;
        
        this.loadTableBatch(rows, 0, batchSize, () => {
            this.removeComponentLoader(container);
            container.classList.remove('loading');
            container.classList.add('loaded');
            container.removeAttribute('data-lazy');
        });
    }

    loadTableBatch(rows, startIndex, batchSize, callback) {
        const endIndex = Math.min(startIndex + batchSize, rows.length);
        
        for (let i = startIndex; i < endIndex; i++) {
            const row = rows[i];
            row.style.display = '';
            row.removeAttribute('data-lazy');
        }

        if (endIndex < rows.length) {
            setTimeout(() => {
                this.loadTableBatch(rows, endIndex, batchSize, callback);
            }, 50);
        } else {
            callback();
        }
    }

    loadLottieAnimation(container) {
        if (!window.lottie) {
            // Load Lottie library first
            this.loadLottieLibrary(() => {
                this.initializeLottieAnimation(container);
            });
        } else {
            this.initializeLottieAnimation(container);
        }
    }

    loadLottieLibrary(callback) {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js';
        script.onload = callback;
        document.head.appendChild(script);
    }

    initializeLottieAnimation(container) {
        const animationPath = container.dataset.animationPath;
        if (!animationPath) return;

        const animation = window.lottie.loadAnimation({
            container: container,
            renderer: 'svg',
            loop: container.dataset.loop === 'true',
            autoplay: container.dataset.autoplay === 'true',
            path: animationPath
        });

        container.lottieAnimation = animation;
        
        animation.addEventListener('DOMLoaded', () => {
            this.removeComponentLoader(container);
            container.classList.remove('loading');
            container.classList.add('loaded');
            container.removeAttribute('data-lazy');
        });
    }

    loadHeavyContent(container) {
        // Load heavy content with delay
        const delay = this.isLowEndDevice ? 1500 : 800;
        
        setTimeout(() => {
            // Show hidden content
            const hiddenContent = container.querySelectorAll('[data-hidden]');
            hiddenContent.forEach(element => {
                element.style.display = '';
                element.removeAttribute('data-hidden');
            });
            
            this.removeComponentLoader(container);
            container.classList.remove('loading');
            container.classList.add('loaded');
            container.removeAttribute('data-lazy');
        }, delay);
    }

    removeComponentLoader(component) {
        const loader = component.querySelector('.component-loader');
        if (loader) {
            loader.style.opacity = '0';
            setTimeout(() => {
                if (loader.parentNode) {
                    loader.parentNode.removeChild(loader);
                }
            }, 300);
        }
    }

    setupIntersectionObservers() {
        // Re-observe new elements added to DOM
        const observer = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // Check for new lazy images
                        if (node.matches && node.matches('img[data-src], [data-bg-src]')) {
                            this.imageObserver.observe(node);
                        }
                        
                        // Check for new lazy components
                        if (node.matches && node.matches('[data-lazy]')) {
                            this.componentObserver.observe(node);
                        }
                        
                        // Check children
                        const lazyImages = node.querySelectorAll && node.querySelectorAll('img[data-src], [data-bg-src]');
                        if (lazyImages) {
                            lazyImages.forEach(img => this.imageObserver.observe(img));
                        }
                        
                        const lazyComponents = node.querySelectorAll && node.querySelectorAll('[data-lazy]');
                        if (lazyComponents) {
                            lazyComponents.forEach(component => this.componentObserver.observe(component));
                        }
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    setupPreloadHints() {
        // Preload critical images on hover
        document.addEventListener('mouseenter', (e) => {
            const target = e.target.closest('[data-preload]');
            if (target && !target.dataset.preloaded) {
                this.preloadImage(target.dataset.preload);
                target.dataset.preloaded = 'true';
            }
        }, true);

        // Preload next page resources
        this.preloadNextPageResources();
    }

    preloadImage(src) {
        const img = new Image();
        img.src = src;
    }

    preloadNextPageResources() {
        // Preload likely next pages based on current page
        const currentPath = window.location.pathname;
        let nextPages = [];

        if (currentPath === '/' || currentPath === '/Home') {
            nextPages = ['/Home/Leaderboard', '/api/AllStocks'];
        } else if (currentPath === '/Home/Leaderboard') {
            nextPages = ['/Home', '/api/GetLeaderboard'];
        }

        nextPages.forEach(page => {
            const link = document.createElement('link');
            link.rel = 'prefetch';
            link.href = page;
            document.head.appendChild(link);
        });
    }

    monitorPerformance() {
        // Monitor loading performance
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                list.getEntries().forEach(entry => {
                    if (entry.entryType === 'measure') {
                        console.log(`Performance: ${entry.name} took ${entry.duration}ms`);
                    }
                });
            });

            observer.observe({ entryTypes: ['measure'] });
        }

        // Monitor memory usage
        if ('memory' in performance) {
            setInterval(() => {
                const memory = performance.memory;
                const usage = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
                
                if (usage > 0.8) {
                    console.warn('High memory usage detected:', usage);
                    this.optimizeMemoryUsage();
                }
            }, 30000);
        }
    }

    optimizeMemoryUsage() {
        // Unload non-visible images
        document.querySelectorAll('img.loaded').forEach(img => {
            if (!this.isElementVisible(img)) {
                const placeholder = img.dataset.src || img.src;
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMSIgaGVpZ2h0PSIxIiB2aWV3Qm94PSIwIDAgMSAxIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNGNUY1RjUiLz48L3N2Zz4=';
                img.dataset.src = placeholder;
                img.classList.remove('loaded');
            }
        });

        // Pause non-visible animations
        document.querySelectorAll('.lottie-container').forEach(container => {
            if (!this.isElementVisible(container) && container.lottieAnimation) {
                container.lottieAnimation.pause();
            }
        });
    }

    isElementVisible(element) {
        const rect = element.getBoundingClientRect();
        return rect.bottom >= 0 && rect.top <= window.innerHeight;
    }

    isSlowConnection() {
        const connection = navigator.connection;
        return connection && (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g');
    }

    supportsWebP() {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    }

    // Public methods
    loadAllVisible() {
        // Force load all visible lazy elements
        document.querySelectorAll('img[data-src], [data-bg-src]').forEach(img => {
            if (this.isElementVisible(img)) {
                this.loadImage(img);
            }
        });

        document.querySelectorAll('[data-lazy]').forEach(component => {
            if (this.isElementVisible(component)) {
                this.loadComponent(component);
            }
        });
    }

    preloadAll() {
        // Preload all lazy elements (use with caution)
        document.querySelectorAll('img[data-src], [data-bg-src]').forEach(img => {
            this.loadImage(img);
        });

        document.querySelectorAll('[data-lazy]').forEach(component => {
            this.loadComponent(component);
        });
    }

    destroy() {
        // Clean up observers
        if (this.imageObserver) {
            this.imageObserver.disconnect();
        }
        
        if (this.componentObserver) {
            this.componentObserver.disconnect();
        }
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize mobile lazy loader
    window.mobileLazyLoader = new MobileLazyLoader();
});

// Export for use in other modules
window.MobileLazyLoader = MobileLazyLoader;
// ==========================================================================
// SWIPE GESTURES - Swipe gesture support for charts and tables
// ==========================================================================

class SwipeGestureManager {
    constructor() {
        this.activeGestures = new Map();
        this.init();
    }

    init() {
        this.setupChartSwipes();
        this.setupTableSwipes();
        this.setupWatchlistSwipes();
    }

    setupChartSwipes() {
        const chartContainers = document.querySelectorAll('.chart-container, .stock-chart');
        
        chartContainers.forEach(container => {
            this.addChartSwipeSupport(container);
        });
    }

    addChartSwipeSupport(container) {
        const gesture = new ChartSwipeGesture(container);
        this.activeGestures.set(container, gesture);
    }

    setupTableSwipes() {
        const tables = document.querySelectorAll('.holdings-table, .leaderboard-table');
        
        tables.forEach(table => {
            this.addTableSwipeSupport(table);
        });
    }

    addTableSwipeSupport(table) {
        const gesture = new TableSwipeGesture(table);
        this.activeGestures.set(table, gesture);
    }

    setupWatchlistSwipes() {
        const watchlistItems = document.querySelectorAll('.watchlist-item');
        
        watchlistItems.forEach(item => {
            this.addWatchlistSwipeSupport(item);
        });
    }

    addWatchlistSwipeSupport(item) {
        const gesture = new WatchlistSwipeGesture(item);
        this.activeGestures.set(item, gesture);
    }
}

// ==========================================================================
// CHART SWIPE GESTURE
// ==========================================================================

class ChartSwipeGesture {
    constructor(container) {
        this.container = container;
        this.startX = 0;
        this.startY = 0;
        this.currentX = 0;
        this.currentY = 0;
        this.isDragging = false;
        this.timeframes = ['1D', '1W', '1M', '3M', '1Y', '5Y'];
        this.currentTimeframeIndex = 0;
        
        this.init();
    }

    init() {
        this.createTimeframeIndicator();
        this.bindEvents();
        this.addChartZoomSupport();
    }

    createTimeframeIndicator() {
        if (this.container.querySelector('.timeframe-indicator')) return;

        const indicator = document.createElement('div');
        indicator.className = 'timeframe-indicator';
        indicator.innerHTML = `
            <div class="timeframe-pills">
                ${this.timeframes.map((tf, index) => 
                    `<span class="timeframe-pill ${index === 0 ? 'active' : ''}" data-timeframe="${tf}">${tf}</span>`
                ).join('')}
            </div>
        `;
        
        this.container.appendChild(indicator);
        
        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .timeframe-indicator {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 10;
            }
            
            .timeframe-pills {
                display: flex;
                gap: 4px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 20px;
                padding: 4px;
            }
            
            .timeframe-pill {
                padding: 4px 8px;
                border-radius: 16px;
                color: white;
                font-size: 12px;
                cursor: pointer;
                transition: background-color 0.2s;
            }
            
            .timeframe-pill.active {
                background: var(--color-primary, #007bff);
            }
        `;
        document.head.appendChild(style);
    }

    bindEvents() {
        this.container.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        this.container.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.container.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });

        // Timeframe pill clicks
        this.container.addEventListener('click', (e) => {
            if (e.target.classList.contains('timeframe-pill')) {
                this.changeTimeframe(e.target.dataset.timeframe);
            }
        });
    }

    handleTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isDragging = false;
    }

    handleTouchMove(e) {
        if (!e.touches[0]) return;

        this.currentX = e.touches[0].clientX;
        this.currentY = e.touches[0].clientY;

        const deltaX = this.currentX - this.startX;
        const deltaY = this.currentY - this.startY;

        // Check if this is a horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
            this.isDragging = true;
            e.preventDefault(); // Prevent scrolling
        }
    }

    handleTouchEnd(e) {
        if (!this.isDragging) return;

        const deltaX = this.currentX - this.startX;
        const threshold = 50;

        if (Math.abs(deltaX) > threshold) {
            if (deltaX > 0) {
                this.previousTimeframe();
            } else {
                this.nextTimeframe();
            }
        }

        this.isDragging = false;
    }

    nextTimeframe() {
        if (this.currentTimeframeIndex < this.timeframes.length - 1) {
            this.currentTimeframeIndex++;
            this.updateTimeframe();
        }
    }

    previousTimeframe() {
        if (this.currentTimeframeIndex > 0) {
            this.currentTimeframeIndex--;
            this.updateTimeframe();
        }
    }

    changeTimeframe(timeframe) {
        const index = this.timeframes.indexOf(timeframe);
        if (index !== -1) {
            this.currentTimeframeIndex = index;
            this.updateTimeframe();
        }
    }

    updateTimeframe() {
        const pills = this.container.querySelectorAll('.timeframe-pill');
        pills.forEach((pill, index) => {
            pill.classList.toggle('active', index === this.currentTimeframeIndex);
        });

        // Show swipe hint
        this.showSwipeHint();

        // Emit event for chart update
        this.container.dispatchEvent(new CustomEvent('timeframechange', {
            detail: { 
                timeframe: this.timeframes[this.currentTimeframeIndex],
                index: this.currentTimeframeIndex
            }
        }));
    }

    showSwipeHint() {
        const hint = this.container.querySelector('.swipe-hint');
        if (hint) {
            hint.textContent = `Swipe to change timeframe (${this.timeframes[this.currentTimeframeIndex]})`;
            hint.classList.add('visible');
            
            setTimeout(() => {
                hint.classList.remove('visible');
            }, 2000);
        }
    }

    addChartZoomSupport() {
        let initialDistance = 0;
        let currentScale = 1;
        let initialCenter = { x: 0, y: 0 };
        let currentTranslate = { x: 0, y: 0 };
        
        this.container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                initialDistance = this.getDistance(e.touches[0], e.touches[1]);
                initialCenter = this.getCenter(e.touches[0], e.touches[1]);
            }
        }, { passive: true });

        this.container.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDistance = this.getDistance(e.touches[0], e.touches[1]);
                const currentCenter = this.getCenter(e.touches[0], e.touches[1]);
                
                const scale = currentDistance / initialDistance;
                currentScale = Math.min(Math.max(scale, 0.5), 3);
                
                // Calculate translation based on center point
                const deltaX = currentCenter.x - initialCenter.x;
                const deltaY = currentCenter.y - initialCenter.y;
                currentTranslate.x += deltaX;
                currentTranslate.y += deltaY;
                
                const chart = this.container.querySelector('canvas');
                if (chart) {
                    chart.style.transform = `scale(${currentScale}) translate(${currentTranslate.x}px, ${currentTranslate.y}px)`;
                }
                
                this.showZoomIndicator(currentScale);
            }
        }, { passive: false });

        this.container.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                // Reset or apply zoom
                const chart = this.container.querySelector('canvas');
                if (chart && currentScale !== 1) {
                    // Emit zoom event
                    this.container.dispatchEvent(new CustomEvent('chartzoom', {
                        detail: { 
                            scale: currentScale,
                            translate: currentTranslate
                        }
                    }));
                }
                this.hideZoomIndicator();
            }
        }, { passive: true });

        // Add zoom controls
        this.addZoomControls();
    }

    addZoomControls() {
        if (this.container.querySelector('.zoom-controls')) return;

        const controls = document.createElement('div');
        controls.className = 'zoom-controls';
        controls.innerHTML = `
            <button class="zoom-btn zoom-in" data-action="zoom-in">
                <i class="fas fa-plus"></i>
            </button>
            <button class="zoom-btn zoom-out" data-action="zoom-out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="zoom-btn zoom-reset" data-action="zoom-reset">
                <i class="fas fa-expand-arrows-alt"></i>
            </button>
        `;

        this.container.appendChild(controls);

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .zoom-controls {
                position: absolute;
                bottom: 60px;
                right: 10px;
                display: flex;
                flex-direction: column;
                gap: 8px;
                z-index: 10;
            }
            
            .zoom-btn {
                width: 44px;
                height: 44px;
                border: none;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                border-radius: 50%;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .zoom-btn:hover {
                background: rgba(0, 0, 0, 0.8);
                transform: scale(1.1);
            }
            
            .zoom-indicator {
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 14px;
                z-index: 10;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .zoom-indicator.visible {
                opacity: 1;
            }
        `;
        document.head.appendChild(style);

        // Bind zoom control events
        controls.addEventListener('click', (e) => {
            const btn = e.target.closest('.zoom-btn');
            if (btn) {
                const action = btn.dataset.action;
                this.handleZoomAction(action);
            }
        });
    }

    handleZoomAction(action) {
        const chart = this.container.querySelector('canvas');
        if (!chart) return;

        let newScale = 1;
        const currentTransform = chart.style.transform;
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        switch (action) {
            case 'zoom-in':
                newScale = Math.min(currentScale * 1.2, 3);
                break;
            case 'zoom-out':
                newScale = Math.max(currentScale / 1.2, 0.5);
                break;
            case 'zoom-reset':
                newScale = 1;
                break;
        }

        chart.style.transform = `scale(${newScale})`;
        this.showZoomIndicator(newScale);
        
        setTimeout(() => {
            this.hideZoomIndicator();
        }, 1500);

        // Emit zoom event
        this.container.dispatchEvent(new CustomEvent('chartzoom', {
            detail: { scale: newScale }
        }));
    }

    showZoomIndicator(scale) {
        let indicator = this.container.querySelector('.zoom-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'zoom-indicator';
            this.container.appendChild(indicator);
        }
        
        indicator.textContent = `${Math.round(scale * 100)}%`;
        indicator.classList.add('visible');
    }

    hideZoomIndicator() {
        const indicator = this.container.querySelector('.zoom-indicator');
        if (indicator) {
            indicator.classList.remove('visible');
        }
    }

    getCenter(touch1, touch2) {
        return {
            x: (touch1.clientX + touch2.clientX) / 2,
            y: (touch1.clientY + touch2.clientY) / 2
        };
    }

    getDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
}

// ==========================================================================
// TABLE SWIPE GESTURE
// ==========================================================================

class TableSwipeGesture {
    constructor(table) {
        this.table = table;
        this.startX = 0;
        this.currentX = 0;
        this.isDragging = false;
        
        this.init();
    }

    init() {
        this.bindEvents();
        this.addTableRowActions();
    }

    bindEvents() {
        this.table.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        this.table.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.table.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });
    }

    handleTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.isDragging = false;
    }

    handleTouchMove(e) {
        if (!e.touches[0]) return;

        this.currentX = e.touches[0].clientX;
        const deltaX = this.currentX - this.startX;

        // Allow horizontal scrolling for tables
        if (Math.abs(deltaX) > 10) {
            this.isDragging = true;
            // Don't prevent default - allow native scrolling
        }
    }

    handleTouchEnd(e) {
        if (this.isDragging) {
            // Add momentum scrolling effect
            this.addMomentumScrolling();
        }
        this.isDragging = false;
    }

    addMomentumScrolling() {
        // Add CSS class for momentum scrolling
        this.table.style.webkitOverflowScrolling = 'touch';
        this.table.style.scrollBehavior = 'smooth';
        
        // Add scroll indicators
        this.addScrollIndicators();
    }

    addScrollIndicators() {
        if (this.table.querySelector('.scroll-indicator')) return;

        // Create scroll indicator container
        const indicatorContainer = document.createElement('div');
        indicatorContainer.className = 'scroll-indicator-container';
        
        const indicator = document.createElement('div');
        indicator.className = 'scroll-indicator';
        
        const leftFade = document.createElement('div');
        leftFade.className = 'scroll-fade scroll-fade-left';
        
        const rightFade = document.createElement('div');
        rightFade.className = 'scroll-fade scroll-fade-right';
        
        indicatorContainer.appendChild(indicator);
        this.table.parentNode.appendChild(indicatorContainer);
        this.table.parentNode.appendChild(leftFade);
        this.table.parentNode.appendChild(rightFade);

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .scroll-indicator-container {
                position: relative;
                height: 3px;
                background: rgba(0, 0, 0, 0.1);
                border-radius: 2px;
                margin-top: 4px;
            }
            
            .scroll-indicator {
                height: 100%;
                background: var(--color-primary);
                border-radius: 2px;
                transition: width 0.2s ease;
                width: 0%;
            }
            
            .scroll-fade {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 20px;
                pointer-events: none;
                z-index: 1;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .scroll-fade-left {
                left: 0;
                background: linear-gradient(to right, var(--bg-card), transparent);
            }
            
            .scroll-fade-right {
                right: 0;
                background: linear-gradient(to left, var(--bg-card), transparent);
            }
            
            .scroll-fade.visible {
                opacity: 1;
            }
        `;
        document.head.appendChild(style);

        // Update indicator on scroll
        this.table.addEventListener('scroll', () => {
            const scrollPercent = (this.table.scrollLeft / (this.table.scrollWidth - this.table.clientWidth)) * 100;
            indicator.style.width = `${Math.min(scrollPercent, 100)}%`;
            
            // Show/hide fade indicators
            leftFade.classList.toggle('visible', this.table.scrollLeft > 10);
            rightFade.classList.toggle('visible', 
                this.table.scrollLeft < (this.table.scrollWidth - this.table.clientWidth - 10)
            );
        }, { passive: true });

        // Initial check
        const scrollPercent = (this.table.scrollLeft / (this.table.scrollWidth - this.table.clientWidth)) * 100;
        indicator.style.width = `${Math.min(scrollPercent, 100)}%`;
        
        rightFade.classList.toggle('visible', 
            this.table.scrollWidth > this.table.clientWidth
        );
    }

    addTableRowActions() {
        // Add swipe actions to table rows on mobile
        if (window.innerWidth > 768) return;

        const rows = this.table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            this.addRowSwipeSupport(row);
        });
    }

    addRowSwipeSupport(row) {
        let startX = 0;
        let currentX = 0;
        let isDragging = false;

        row.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = false;
        }, { passive: true });

        row.addEventListener('touchmove', (e) => {
            if (!e.touches[0]) return;
            
            currentX = e.touches[0].clientX;
            const deltaX = currentX - startX;

            if (Math.abs(deltaX) > 10) {
                isDragging = true;
                e.preventDefault();

                // Show row actions on left swipe
                if (deltaX < 0) {
                    row.style.transform = `translateX(${Math.max(deltaX, -80)}px)`;
                    this.showRowActions(row);
                }
            }
        }, { passive: false });

        row.addEventListener('touchend', () => {
            if (isDragging) {
                const deltaX = currentX - startX;
                
                if (deltaX < -40) {
                    // Keep actions visible
                    row.style.transform = 'translateX(-80px)';
                } else {
                    // Hide actions
                    row.style.transform = '';
                    this.hideRowActions(row);
                }
            }
            isDragging = false;
        }, { passive: true });
    }

    showRowActions(row) {
        if (row.querySelector('.row-actions')) return;

        const actions = document.createElement('div');
        actions.className = 'row-actions';
        actions.innerHTML = `
            <button class="action-btn view-btn" data-action="view">
                <i class="fas fa-eye"></i>
            </button>
            <button class="action-btn edit-btn" data-action="edit">
                <i class="fas fa-edit"></i>
            </button>
        `;
        
        row.appendChild(actions);

        // Bind action events
        actions.addEventListener('click', (e) => {
            const btn = e.target.closest('.action-btn');
            if (btn) {
                const action = btn.dataset.action;
                this.handleRowAction(row, action);
            }
        });
    }

    hideRowActions(row) {
        const actions = row.querySelector('.row-actions');
        if (actions) {
            actions.remove();
        }
    }

    handleRowAction(row, action) {
        // Emit custom event for row actions
        row.dispatchEvent(new CustomEvent('rowaction', {
            detail: { action, row },
            bubbles: true
        }));
        
        // Hide actions after action
        this.hideRowActions(row);
        row.style.transform = '';
    }
}

// ==========================================================================
// WATCHLIST SWIPE GESTURE
// ==========================================================================

class WatchlistSwipeGesture {
    constructor(item) {
        this.item = item;
        this.startX = 0;
        this.currentX = 0;
        this.isDragging = false;
        this.threshold = 80;
        
        this.init();
    }

    init() {
        this.createSwipeActions();
        this.bindEvents();
    }

    createSwipeActions() {
        if (this.item.querySelector('.swipe-actions')) return;

        const actions = document.createElement('div');
        actions.className = 'swipe-actions';
        actions.innerHTML = `
            <button class="action-btn delete-btn touch-target" data-action="remove">
                <i class="fas fa-trash"></i>
            </button>
            <button class="action-btn trade-btn touch-target" data-action="trade">
                <i class="fas fa-chart-line"></i>
            </button>
        `;
        
        this.item.appendChild(actions);
        
        // Bind action events
        actions.addEventListener('click', (e) => {
            const btn = e.target.closest('.action-btn');
            if (btn) {
                const action = btn.dataset.action;
                this.handleAction(action);
            }
        });
    }

    bindEvents() {
        this.item.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        this.item.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.item.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });
    }

    handleTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.isDragging = false;
    }

    handleTouchMove(e) {
        if (!e.touches[0]) return;

        this.currentX = e.touches[0].clientX;
        const deltaX = this.currentX - this.startX;

        if (Math.abs(deltaX) > 10) {
            this.isDragging = true;
            e.preventDefault();

            // Only allow left swipe to reveal actions
            if (deltaX < 0) {
                const progress = Math.min(Math.abs(deltaX) / this.threshold, 1);
                this.item.style.transform = `translateX(${deltaX}px)`;
                
                const actions = this.item.querySelector('.swipe-actions');
                if (actions) {
                    actions.style.opacity = progress;
                }
            }
        }
    }

    handleTouchEnd(e) {
        if (!this.isDragging) return;

        const deltaX = this.currentX - this.startX;
        const actions = this.item.querySelector('.swipe-actions');

        if (deltaX < -this.threshold) {
            // Show actions
            this.item.style.transform = `translateX(-${this.threshold}px)`;
            if (actions) {
                actions.classList.add('visible');
                actions.style.opacity = '1';
            }
        } else {
            // Hide actions
            this.hideActions();
        }

        this.isDragging = false;
    }

    hideActions() {
        this.item.style.transform = '';
        const actions = this.item.querySelector('.swipe-actions');
        if (actions) {
            actions.classList.remove('visible');
            actions.style.opacity = '0';
        }
    }

    handleAction(action) {
        const symbol = this.item.dataset.symbol || this.item.querySelector('.stock-symbol')?.textContent;
        
        switch (action) {
            case 'remove':
                this.removeFromWatchlist(symbol);
                break;
            case 'trade':
                this.openTradeModal(symbol);
                break;
        }
        
        this.hideActions();
    }

    removeFromWatchlist(symbol) {
        // Emit custom event
        this.item.dispatchEvent(new CustomEvent('removestock', {
            detail: { symbol },
            bubbles: true
        }));
    }

    openTradeModal(symbol) {
        // Emit custom event
        this.item.dispatchEvent(new CustomEvent('tradestock', {
            detail: { symbol },
            bubbles: true
        }));
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    new SwipeGestureManager();
});

// Export for use in other modules
window.SwipeGestureManager = SwipeGestureManager;
window.ChartSwipeGesture = ChartSwipeGesture;
window.TableSwipeGesture = TableSwipeGesture;
window.WatchlistSwipeGesture = WatchlistSwipeGesture;
            
// ==========================================================================
// MOBILE NAVIGATION - Mobile-optimized navigation and menu interactions
// ==========================================================================

class MobileNavigation {
    constructor() {
        this.init();
        this.bindEvents();
    }

    init() {
        this.createMobileElements();
        this.setupResponsiveNavigation();
    }

    createMobileElements() {
        // Create mobile menu toggle if it doesn't exist
        if (!document.querySelector('.mobile-menu-toggle')) {
            const toggle = document.createElement('button');
            toggle.className = 'mobile-menu-toggle';
            toggle.innerHTML = `
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            
            // Insert toggle into header
            const header = document.querySelector('.top-bar') || document.querySelector('header');
            if (header) {
                header.insertBefore(toggle, header.firstChild);
            }
        }

        // Add mobile classes to existing navigation
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) {
            sidebar.classList.add('mobile-nav');
        }
    }

    setupResponsiveNavigation() {
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        if (sidebar && mainContent) {
            // Add overlay for mobile
            const overlay = document.createElement('div');
            overlay.className = 'mobile-nav-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1040;
                opacity: 0;
                visibility: hidden;
                transition: all 0.25s ease-in-out;
            `;
            document.body.appendChild(overlay);
        }
    }

    bindEvents() {
        // Mobile menu toggle
        document.addEventListener('click', (e) => {
            if (e.target.closest('.mobile-menu-toggle')) {
                this.toggleMobileMenu();
            }
        });

        // Close mobile menu when clicking overlay
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('mobile-nav-overlay')) {
                this.closeMobileMenu();
            }
        });

        // Close mobile menu when clicking nav link
        document.addEventListener('click', (e) => {
            if (e.target.closest('.mobile-nav .nav-link')) {
                this.closeMobileMenu();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                this.closeMobileMenu();
            }
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closeMobileMenu();
            }
        });

        // Prevent body scroll when mobile menu is open
        document.addEventListener('touchmove', (e) => {
            if (document.body.classList.contains('mobile-nav-open')) {
                if (!e.target.closest('.mobile-nav')) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
    }

    toggleMobileMenu() {
        const isOpen = document.body.classList.contains('mobile-nav-open');
        if (isOpen) {
            this.closeMobileMenu();
        } else {
            this.openMobileMenu();
        }
    }

    openMobileMenu() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.mobile-nav-overlay');
        const hamburger = document.querySelector('.hamburger');

        if (sidebar) {
            sidebar.classList.add('active');
        }

        if (overlay) {
            overlay.style.opacity = '1';
            overlay.style.visibility = 'visible';
        }

        if (hamburger) {
            hamburger.classList.add('active');
        }

        document.body.classList.add('mobile-nav-open');
        document.body.style.overflow = 'hidden';

        // Focus management for accessibility
        const firstNavLink = sidebar?.querySelector('.nav-link');
        if (firstNavLink) {
            firstNavLink.focus();
        }
    }

    closeMobileMenu() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.mobile-nav-overlay');
        const hamburger = document.querySelector('.hamburger');

        if (sidebar) {
            sidebar.classList.remove('active');
        }

        if (overlay) {
            overlay.style.opacity = '0';
            overlay.style.visibility = 'hidden';
        }

        if (hamburger) {
            hamburger.classList.remove('active');
        }

        document.body.classList.remove('mobile-nav-open');
        document.body.style.overflow = '';
    }
}

// ==========================================================================
// TOUCH GESTURES - Touch gesture handling for mobile interactions
// ==========================================================================

class TouchGestureHandler {
    constructor() {
        this.startX = 0;
        this.startY = 0;
        this.currentX = 0;
        this.currentY = 0;
        this.isDragging = false;
        this.threshold = 50; // Minimum distance for swipe
        this.restraint = 100; // Maximum perpendicular distance
        this.allowedTime = 300; // Maximum time for swipe
        this.startTime = 0;

        this.init();
    }

    init() {
        this.bindSwipeEvents();
        this.bindPullToRefresh();
        this.bindLongPress();
    }

    bindSwipeEvents() {
        // Swipe gestures for tables and charts
        const swipeableElements = document.querySelectorAll('.table-mobile, .chart-container, .swipeable');
        
        swipeableElements.forEach(element => {
            this.addSwipeListeners(element);
        });
    }

    addSwipeListeners(element) {
        element.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e, element);
        }, { passive: true });

        element.addEventListener('touchmove', (e) => {
            this.handleTouchMove(e, element);
        }, { passive: false });

        element.addEventListener('touchend', (e) => {
            this.handleTouchEnd(e, element);
        }, { passive: true });
    }

    handleTouchStart(e, element) {
        const touch = e.touches[0];
        this.startX = touch.clientX;
        this.startY = touch.clientY;
        this.startTime = new Date().getTime();
        this.isDragging = false;

        element.classList.add('touch-active');
    }

    handleTouchMove(e, element) {
        if (!e.touches[0]) return;

        const touch = e.touches[0];
        this.currentX = touch.clientX;
        this.currentY = touch.clientY;

        const deltaX = this.currentX - this.startX;
        const deltaY = this.currentY - this.startY;

        // Check if this is a horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            this.isDragging = true;
            element.classList.add('swiping');

            // For horizontal scrollable elements, allow native scrolling
            if (element.scrollWidth > element.clientWidth) {
                return;
            }

            // Prevent vertical scrolling during horizontal swipe
            e.preventDefault();
        }
    }

    handleTouchEnd(e, element) {
        if (!this.isDragging) {
            element.classList.remove('touch-active');
            return;
        }

        const deltaX = this.currentX - this.startX;
        const deltaY = this.currentY - this.startY;
        const elapsedTime = new Date().getTime() - this.startTime;

        element.classList.remove('touch-active', 'swiping');

        // Check if swipe meets criteria
        if (elapsedTime <= this.allowedTime && 
            Math.abs(deltaX) >= this.threshold && 
            Math.abs(deltaY) <= this.restraint) {
            
            if (deltaX > 0) {
                this.handleSwipeRight(element);
            } else {
                this.handleSwipeLeft(element);
            }
        }

        this.isDragging = false;
    }

    handleSwipeLeft(element) {
        // Emit custom event
        element.dispatchEvent(new CustomEvent('swipeleft', {
            detail: { element }
        }));

        // Handle specific swipe actions
        if (element.classList.contains('watchlist-item')) {
            this.showSwipeActions(element);
        }
    }

    handleSwipeRight(element) {
        // Emit custom event
        element.dispatchEvent(new CustomEvent('swiperight', {
            detail: { element }
        }));

        // Handle specific swipe actions
        if (element.classList.contains('watchlist-item')) {
            this.hideSwipeActions(element);
        }
    }

    showSwipeActions(element) {
        const actions = element.querySelector('.swipe-actions');
        if (actions) {
            actions.classList.add('visible');
            element.style.transform = 'translateX(-80px)';
        }
    }

    hideSwipeActions(element) {
        const actions = element.querySelector('.swipe-actions');
        if (actions) {
            actions.classList.remove('visible');
            element.style.transform = '';
        }
    }

    bindPullToRefresh() {
        const refreshableElements = document.querySelectorAll('.pull-to-refresh');
        
        refreshableElements.forEach(element => {
            let startY = 0;
            let currentY = 0;
            let isPulling = false;

            element.addEventListener('touchstart', (e) => {
                if (element.scrollTop === 0) {
                    startY = e.touches[0].clientY;
                }
            }, { passive: true });

            element.addEventListener('touchmove', (e) => {
                if (element.scrollTop === 0 && startY) {
                    currentY = e.touches[0].clientY;
                    const pullDistance = currentY - startY;

                    if (pullDistance > 0) {
                        isPulling = true;
                        element.classList.add('pulling');
                        
                        if (pullDistance > 80) {
                            element.classList.add('ready-to-refresh');
                        } else {
                            element.classList.remove('ready-to-refresh');
                        }

                        // Prevent default scrolling
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            element.addEventListener('touchend', () => {
                if (isPulling && element.classList.contains('ready-to-refresh')) {
                    this.triggerRefresh(element);
                }

                element.classList.remove('pulling', 'ready-to-refresh');
                isPulling = false;
                startY = 0;
            }, { passive: true });
        });
    }

    triggerRefresh(element) {
        element.classList.add('refreshing');
        
        // Emit refresh event
        element.dispatchEvent(new CustomEvent('pullrefresh', {
            detail: { element }
        }));

        // Auto-hide after 2 seconds if not manually hidden
        setTimeout(() => {
            element.classList.remove('refreshing');
        }, 2000);
    }

    bindLongPress() {
        const longPressElements = document.querySelectorAll('.long-pressable');
        
        longPressElements.forEach(element => {
            let pressTimer;
            let startX, startY;

            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                
                element.classList.add('long-pressing');
                
                pressTimer = setTimeout(() => {
                    element.dispatchEvent(new CustomEvent('longpress', {
                        detail: { element }
                    }));
                    element.classList.remove('long-pressing');
                }, 800);
            }, { passive: true });

            element.addEventListener('touchmove', (e) => {
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = Math.abs(currentX - startX);
                const deltaY = Math.abs(currentY - startY);

                // Cancel long press if finger moves too much
                if (deltaX > 10 || deltaY > 10) {
                    clearTimeout(pressTimer);
                    element.classList.remove('long-pressing');
                }
            }, { passive: true });

            element.addEventListener('touchend', () => {
                clearTimeout(pressTimer);
                element.classList.remove('long-pressing');
            }, { passive: true });
        });
    }
}

// ==========================================================================
// MOBILE OPTIMIZATIONS - Performance and UX optimizations for mobile
// ==========================================================================

class MobileOptimizations {
    constructor() {
        this.init();
    }

    init() {
        this.setupViewportMeta();
        this.optimizeScrolling();
        this.handleOrientationChange();
        this.setupTouchFeedback();
        this.optimizeInputs();
        this.setupEnhancedTouchTargets();
        this.setupAccessibilityEnhancements();
        this.setupPerformanceOptimizations();
    }

    setupViewportMeta() {
        // Ensure proper viewport meta tag
        let viewport = document.querySelector('meta[name="viewport"]');
        if (!viewport) {
            viewport = document.createElement('meta');
            viewport.name = 'viewport';
            document.head.appendChild(viewport);
        }
        
        viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
    }

    optimizeScrolling() {
        // Add momentum scrolling for iOS
        const scrollableElements = document.querySelectorAll('.modal-body, .table-container, .chart-container');
        
        scrollableElements.forEach(element => {
            element.style.webkitOverflowScrolling = 'touch';
        });
    }

    handleOrientationChange() {
        window.addEventListener('orientationchange', () => {
            // Force repaint after orientation change
            setTimeout(() => {
                window.scrollTo(0, 0);
                
                // Trigger resize event for charts
                window.dispatchEvent(new Event('resize'));
            }, 100);
        });
    }

    setupTouchFeedback() {
        // Add touch feedback to interactive elements
        const interactiveElements = document.querySelectorAll('button, .btn, .nav-link, .card-clickable');
        
        interactiveElements.forEach(element => {
            if (!element.classList.contains('touch-feedback')) {
                element.classList.add('touch-feedback');
            }
        });
    }

    optimizeInputs() {
        // Prevent zoom on input focus for iOS
        const inputs = document.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            if (!input.classList.contains('no-zoom')) {
                input.classList.add('no-zoom');
            }
        });

        // Add proper input types for mobile keyboards
        const emailInputs = document.querySelectorAll('input[name*="email"], input[id*="email"]');
        emailInputs.forEach(input => {
            input.type = 'email';
        });

        const phoneInputs = document.querySelectorAll('input[name*="phone"], input[id*="phone"]');
        phoneInputs.forEach(input => {
            input.type = 'tel';
        });

        const numberInputs = document.querySelectorAll('input[name*="quantity"], input[name*="price"], input[name*="amount"]');
        numberInputs.forEach(input => {
            input.type = 'number';
            input.inputMode = 'decimal';
        });
    }

    setupEnhancedTouchTargets() {
        // Enhance all interactive elements with proper touch targets
        const interactiveElements = document.querySelectorAll(
            'button, .btn, a, input, select, textarea, .nav-link, .card-clickable, .dropdown-toggle'
        );
        
        interactiveElements.forEach(element => {
            // Ensure minimum touch target size
            const rect = element.getBoundingClientRect();
            if (rect.width < 44 || rect.height < 44) {
                element.classList.add('touch-target');
            }
            
            // Add touch feedback
            if (!element.classList.contains('touch-feedback')) {
                element.classList.add('touch-feedback');
            }
            
            // Add enhanced touch classes for mobile
            element.classList.add('btn-mobile-enhanced');
        });
        
        // Add mobile-optimized classes to existing components
        this.addMobileOptimizedClasses();
    }
    
    addMobileOptimizedClasses() {
        // Add mobile-optimized classes to existing elements
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => card.classList.add('card-mobile-optimized'));
        
        const forms = document.querySelectorAll('form');
        forms.forEach(form => form.classList.add('form-mobile-optimized'));
        
        const tables = document.querySelectorAll('.table');
        tables.forEach(table => table.classList.add('table-mobile-optimized'));
        
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => modal.classList.add('modal-mobile-optimized'));
        
        const searchContainers = document.querySelectorAll('.search-container');
        searchContainers.forEach(container => container.classList.add('search-mobile-optimized'));
        
        const dashboards = document.querySelectorAll('.dashboard');
        dashboards.forEach(dashboard => dashboard.classList.add('dashboard-mobile-optimized'));
        
        const navs = document.querySelectorAll('.sidebar, .nav');
        navs.forEach(nav => nav.classList.add('nav-mobile-optimized'));
    }

    setupAccessibilityEnhancements() {
        // Add proper ARIA labels for mobile screen readers
        const buttons = document.querySelectorAll('button:not([aria-label])');
        buttons.forEach(button => {
            const text = button.textContent.trim() || button.title || 'Button';
            button.setAttribute('aria-label', text);
        });

        // Enhance form labels
        const inputs = document.querySelectorAll('input:not([aria-label])');
        inputs.forEach(input => {
            const label = document.querySelector(`label[for="${input.id}"]`) || 
                         input.closest('.form-group')?.querySelector('label');
            if (label) {
                input.setAttribute('aria-label', label.textContent.trim());
            }
        });

        // Add role attributes for better navigation
        const navElements = document.querySelectorAll('.nav, .navbar, .sidebar');
        navElements.forEach(nav => {
            if (!nav.getAttribute('role')) {
                nav.setAttribute('role', 'navigation');
            }
        });
    }

    setupPerformanceOptimizations() {
        // Implement passive event listeners where possible
        const scrollElements = document.querySelectorAll('.modal-body, .table-container, .chart-container');
        scrollElements.forEach(element => {
            element.addEventListener('scroll', this.throttle(() => {
                // Update scroll indicators or other UI elements
                this.updateScrollIndicators(element);
            }, 16), { passive: true });
        });

        // Optimize animations for mobile
        if (window.innerWidth <= 768) {
            document.documentElement.style.setProperty('--transition-fast', '0.15s');
            document.documentElement.style.setProperty('--transition-normal', '0.25s');
        }
    }

    throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    updateScrollIndicators(element) {
        const indicator = element.querySelector('.scroll-indicator');
        if (indicator) {
            const scrollPercent = (element.scrollLeft / (element.scrollWidth - element.clientWidth)) * 100;
            indicator.style.width = `${scrollPercent}%`;
            indicator.classList.toggle('visible', element.scrollLeft > 0);
        }
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize mobile navigation
    new MobileNavigation();
    
    // Initialize touch gestures
    new TouchGestureHandler();
    
    // Initialize mobile optimizations
    new MobileOptimizations();
});

// Export for use in other modules
window.MobileNavigation = MobileNavigation;
window.TouchGestureHandler = TouchGestureHandler;
window.MobileOptimizations = MobileOptimizations;
// ==
========================================================================
// ENHANCED MOBILE NAVIGATION GESTURES
// ==========================================================================

class EnhancedMobileNavigation extends MobileNavigation {
    constructor() {
        super();
        this.setupSwipeNavigation();
        this.setupEdgeSwipe();
        this.setupNavigationGestures();
    }

    setupSwipeNavigation() {
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;
        let isDragging = false;

        document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            isDragging = false;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!e.touches[0]) return;

            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;

            const deltaX = currentX - startX;
            const deltaY = currentY - startY;

            // Check for horizontal swipe
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                isDragging = true;

                // Right swipe from left edge to open menu
                if (startX < 50 && deltaX > 100) {
                    this.openMobileMenu();
                }

                // Left swipe to close menu when open
                if (document.body.classList.contains('mobile-nav-open') && deltaX < -100) {
                    this.closeMobileMenu();
                }
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            isDragging = false;
        }, { passive: true });
    }

    setupEdgeSwipe() {
        // Enhanced edge swipe detection
        const edgeThreshold = 20;
        let edgeSwipeStarted = false;

        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            if (touch.clientX <= edgeThreshold) {
                edgeSwipeStarted = true;
                this.showEdgeSwipeIndicator();
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (edgeSwipeStarted && e.touches[0]) {
                const deltaX = e.touches[0].clientX - edgeThreshold;
                if (deltaX > 50) {
                    this.openMobileMenu();
                    edgeSwipeStarted = false;
                    this.hideEdgeSwipeIndicator();
                }
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            edgeSwipeStarted = false;
            this.hideEdgeSwipeIndicator();
        }, { passive: true });
    }

    showEdgeSwipeIndicator() {
        let indicator = document.querySelector('.edge-swipe-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'edge-swipe-indicator';
            indicator.style.cssText = `
                position: fixed;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 4px;
                height: 60px;
                background: var(--color-primary);
                border-radius: 0 4px 4px 0;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.2s ease;
            `;
            document.body.appendChild(indicator);
        }
        indicator.style.opacity = '0.7';
    }

    hideEdgeSwipeIndicator() {
        const indicator = document.querySelector('.edge-swipe-indicator');
        if (indicator) {
            indicator.style.opacity = '0';
        }
    }

    setupNavigationGestures() {
        // Add haptic-like feedback for navigation actions
        const navLinks = document.querySelectorAll('.nav-link');
        navLinks.forEach(link => {
            link.addEventListener('touchstart', () => {
                link.classList.add('haptic-light');
            }, { passive: true });

            link.addEventListener('touchend', () => {
                setTimeout(() => {
                    link.classList.remove('haptic-light');
                }, 150);
            }, { passive: true });
        });

        // Enhanced menu toggle with gesture feedback
        const menuToggle = document.querySelector('.mobile-menu-toggle');
        if (menuToggle) {
            let pressTimer;
            
            menuToggle.addEventListener('touchstart', () => {
                menuToggle.classList.add('haptic-medium');
                
                // Long press to show navigation shortcuts
                pressTimer = setTimeout(() => {
                    this.showNavigationShortcuts();
                }, 800);
            }, { passive: true });

            menuToggle.addEventListener('touchend', () => {
                clearTimeout(pressTimer);
                setTimeout(() => {
                    menuToggle.classList.remove('haptic-medium');
                }, 200);
            }, { passive: true });
        }
    }

    showNavigationShortcuts() {
        // Create navigation shortcuts overlay
        const shortcuts = document.createElement('div');
        shortcuts.className = 'navigation-shortcuts';
        shortcuts.innerHTML = `
            <div class="shortcuts-container">
                <div class="shortcut-item" data-action="dashboard">
                    <i class="fas fa-chart-line"></i>
                    <span>Dashboard</span>
                </div>
                <div class="shortcut-item" data-action="watchlist">
                    <i class="fas fa-eye"></i>
                    <span>Watchlist</span>
                </div>
                <div class="shortcut-item" data-action="leaderboard">
                    <i class="fas fa-trophy"></i>
                    <span>Leaderboard</span>
                </div>
                <div class="shortcut-item" data-action="profile">
                    <i class="fas fa-user"></i>
                    <span>Profile</span>
                </div>
            </div>
        `;

        shortcuts.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        `;

        const container = shortcuts.querySelector('.shortcuts-container');
        container.style.cssText = `
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            padding: 40px;
        `;

        const items = shortcuts.querySelectorAll('.shortcut-item');
        items.forEach(item => {
            item.style.cssText = `
                background: var(--bg-card);
                border-radius: 16px;
                padding: 24px;
                text-align: center;
                cursor: pointer;
                transition: all 0.2s ease;
                min-height: 100px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;

            item.addEventListener('click', () => {
                const action = item.dataset.action;
                this.handleShortcutAction(action);
                document.body.removeChild(shortcuts);
            });
        });

        document.body.appendChild(shortcuts);

        // Close on background click
        shortcuts.addEventListener('click', (e) => {
            if (e.target === shortcuts) {
                document.body.removeChild(shortcuts);
            }
        });
    }

    handleShortcutAction(action) {
        const routes = {
            dashboard: '/Home',
            watchlist: '/Home#watchlist',
            leaderboard: '/Home/Leaderboard',
            profile: '/User/Profile'
        };

        if (routes[action]) {
            window.location.href = routes[action];
        }
    }
}

// ==========================================================================
// ENHANCED TOUCH FEEDBACK SYSTEM
// ==========================================================================

class EnhancedTouchFeedback {
    constructor() {
        this.init();
    }

    init() {
        this.setupRippleEffect();
        this.setupHapticFeedback();
        this.setupTouchStates();
    }

    setupRippleEffect() {
        document.addEventListener('touchstart', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target && !target.classList.contains('no-ripple')) {
                this.createRipple(target, e.touches[0]);
            }
        }, { passive: true });
    }

    createRipple(element, touch) {
        const rect = element.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = touch.clientX - rect.left - size / 2;
        const y = touch.clientY - rect.top - size / 2;

        const ripple = document.createElement('div');
        ripple.className = 'ripple-effect';
        ripple.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            left: ${x}px;
            top: ${y}px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: scale(0);
            animation: ripple-animation 0.6s ease-out;
            pointer-events: none;
            z-index: 1;
        `;

        // Ensure element has relative positioning
        if (getComputedStyle(element).position === 'static') {
            element.style.position = 'relative';
        }

        element.appendChild(ripple);

        // Add CSS animation if not exists
        if (!document.querySelector('#ripple-styles')) {
            const style = document.createElement('style');
            style.id = 'ripple-styles';
            style.textContent = `
                @keyframes ripple-animation {
                    to {
                        transform: scale(2);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Remove ripple after animation
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.parentNode.removeChild(ripple);
            }
        }, 600);
    }

    setupHapticFeedback() {
        // Visual haptic feedback for different interaction types
        const lightElements = document.querySelectorAll('.btn-sm, .nav-link');
        const mediumElements = document.querySelectorAll('.btn, .card-clickable');
        const heavyElements = document.querySelectorAll('.btn-lg, .fab');

        lightElements.forEach(el => el.classList.add('haptic-light'));
        mediumElements.forEach(el => el.classList.add('haptic-medium'));
        heavyElements.forEach(el => el.classList.add('haptic-heavy'));
    }

    setupTouchStates() {
        // Enhanced touch states for better feedback
        document.addEventListener('touchstart', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target) {
                target.classList.add('touch-active');
            }
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target) {
                setTimeout(() => {
                    target.classList.remove('touch-active');
                }, 150);
            }
        }, { passive: true });

        document.addEventListener('touchcancel', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target) {
                target.classList.remove('touch-active');
            }
        }, { passive: true });
    }
}

// ==========================================================================
// MOBILE PERFORMANCE MONITOR
// ==========================================================================

class MobilePerformanceMonitor {
    constructor() {
        this.init();
    }

    init() {
        this.monitorScrollPerformance();
        this.optimizeAnimations();
        this.setupLazyLoading();
    }

    monitorScrollPerformance() {
        let ticking = false;

        const updateScrollElements = () => {
            // Update scroll-dependent elements
            const scrollableElements = document.querySelectorAll('.scrollable');
            scrollableElements.forEach(element => {
                this.updateScrollIndicators(element);
            });
            ticking = false;
        };

        document.addEventListener('scroll', () => {
            if (!ticking) {
                requestAnimationFrame(updateScrollElements);
                ticking = true;
            }
        }, { passive: true });
    }

    updateScrollIndicators(element) {
        const indicator = element.querySelector('.scroll-indicator');
        if (indicator) {
            const scrollPercent = (element.scrollTop / (element.scrollHeight - element.clientHeight)) * 100;
            indicator.style.width = `${Math.min(scrollPercent, 100)}%`;
            indicator.classList.toggle('visible', element.scrollTop > 0);
        }
    }

    optimizeAnimations() {
        // Reduce animations on low-end devices
        if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
            document.documentElement.style.setProperty('--transition-fast', '0.1s');
            document.documentElement.style.setProperty('--transition-normal', '0.2s');
        }

        // Pause animations when page is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                document.body.classList.add('animations-paused');
            } else {
                document.body.classList.remove('animations-paused');
            }
        });
    }

    setupLazyLoading() {
        // Lazy load images and heavy content
        const images = document.querySelectorAll('img[data-src]');
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.add('loaded');
                    imageObserver.unobserve(img);
                }
            });
        });

        images.forEach(img => imageObserver.observe(img));
    }
}

// ==========================================================================
// INITIALIZATION - Enhanced Mobile Features
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Replace basic mobile navigation with enhanced version
    if (window.innerWidth <= 768) {
        new EnhancedMobileNavigation();
        new EnhancedTouchFeedback();
        new MobilePerformanceMonitor();
    }
});
// ==========================================================================
// ORIENTATION HANDLER - Handle orientation changes and adaptive layouts
// ==========================================================================

class OrientationHandler {
    constructor() {
        this.currentOrientation = this.getOrientation();
        this.isTransitioning = false;
        this.transitionTimeout = null;
        
        this.init();
    }

    init() {
        this.bindEvents();
        this.applyInitialClasses();
        this.setupViewportHeightFix();
    }

    bindEvents() {
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            this.handleOrientationChange();
        });

        // Handle resize as fallback
        window.addEventListener('resize', () => {
            this.handleResize();
        });

        // Handle visual viewport changes (for keyboard)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                this.handleViewportResize();
            });
        }

        // Handle device motion for better orientation detection
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => {
                this.handleDeviceOrientation(e);
            });
        }
    }

    getOrientation() {
        // Use screen.orientation if available
        if (screen.orientation) {
            return screen.orientation.angle;
        }
        
        // Fallback to window.orientation
        if (window.orientation !== undefined) {
            return window.orientation;
        }
        
        // Fallback to aspect ratio
        return window.innerWidth > window.innerHeight ? 90 : 0;
    }

    isPortrait() {
        const orientation = this.getOrientation();
        return orientation === 0 || orientation === 180;
    }

    isLandscape() {
        const orientation = this.getOrientation();
        return orientation === 90 || orientation === -90;
    }

    handleOrientationChange() {
        if (this.isTransitioning) return;
        
        this.isTransitioning = true;
        
        // Add transition class
        document.body.classList.add('orientation-transition');
        
        // Clear any existing timeout
        if (this.transitionTimeout) {
            clearTimeout(this.transitionTimeout);
        }
        
        // Wait for orientation to stabilize
        this.transitionTimeout = setTimeout(() => {
            this.updateOrientation();
        }, 100);
    }

    handleResize() {
        // Debounce resize events
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
        }
        
        this.resizeTimeout = setTimeout(() => {
            const newOrientation = this.getOrientation();
            if (newOrientation !== this.currentOrientation) {
                this.updateOrientation();
            }
        }, 150);
    }

    handleViewportResize() {
        // Handle keyboard show/hide
        const viewport = window.visualViewport;
        const isKeyboardOpen = viewport.height < window.innerHeight * 0.75;
        
        document.body.classList.toggle('keyboard-open', isKeyboardOpen);
        
        // Adjust elements for keyboard
        if (isKeyboardOpen) {
            this.adjustForKeyboard();
        } else {
            this.restoreFromKeyboard();
        }
    }

    handleDeviceOrientation(event) {
        // Use device orientation for more accurate detection
        const { alpha, beta, gamma } = event;
        
        // Determine orientation based on device tilt
        let orientation;
        if (Math.abs(gamma) > Math.abs(beta)) {
            orientation = gamma > 0 ? 90 : -90;
        } else {
            orientation = beta > 0 ? 180 : 0;
        }
        
        if (orientation !== this.currentOrientation) {
            this.currentOrientation = orientation;
            this.updateOrientationClasses();
        }
    }

    updateOrientation() {
        const newOrientation = this.getOrientation();
        
        if (newOrientation !== this.currentOrientation) {
            this.currentOrientation = newOrientation;
            this.updateOrientationClasses();
        }
        
        // Update viewport height
        this.updateViewportHeight();
        
        // Notify components of orientation change
        this.notifyComponents();
        
        // Remove transition class after animation
        setTimeout(() => {
            document.body.classList.remove('orientation-transition');
            this.isTransitioning = false;
        }, 300);
    }

    updateOrientationClasses() {
        const body = document.body;
        
        // Remove existing orientation classes
        body.classList.remove('portrait', 'landscape', 'landscape-left', 'landscape-right');
        
        // Add new orientation classes
        if (this.isPortrait()) {
            body.classList.add('portrait');
        } else if (this.isLandscape()) {
            body.classList.add('landscape');
            
            // Add specific landscape direction
            if (this.currentOrientation === 90) {
                body.classList.add('landscape-left');
            } else if (this.currentOrientation === -90) {
                body.classList.add('landscape-right');
            }
        }
        
        // Add device-specific classes
        this.addDeviceSpecificClasses();
    }

    addDeviceSpecificClasses() {
        const body = document.body;
        const { innerWidth, innerHeight } = window;
        
        // Small screen detection
        if (innerHeight <= 667 && innerWidth <= 375) {
            body.classList.add('small-screen-optimize');
        } else {
            body.classList.remove('small-screen-optimize');
        }
        
        // Tall screen detection
        if (innerHeight >= 800) {
            body.classList.add('tall-screen-optimize');
        } else {
            body.classList.remove('tall-screen-optimize');
        }
        
        // Foldable device detection
        if (window.screen && window.screen.isExtended) {
            body.classList.add('foldable-device');
        }
    }

    applyInitialClasses() {
        this.updateOrientationClasses();
        
        // Add adaptive classes to components
        this.addAdaptiveClasses();
    }

    addAdaptiveClasses() {
        // Add classes to tables
        document.querySelectorAll('table, .table-container').forEach(element => {
            element.classList.add('table-orientation-adaptive');
        });
        
        // Add classes to forms
        document.querySelectorAll('form, .form-container').forEach(element => {
            element.classList.add('form-orientation-adaptive');
        });
        
        // Add classes to charts
        document.querySelectorAll('.chart-container').forEach(element => {
            element.classList.add('chart-orientation-adaptive');
        });
        
        // Add classes to notifications
        document.querySelectorAll('.toast, .alert').forEach(element => {
            element.classList.add('notification-orientation-adaptive');
        });
    }

    setupViewportHeightFix() {
        // Fix for mobile browsers that change viewport height
        const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        };
        
        setViewportHeight();
        window.addEventListener('resize', setViewportHeight);
    }

    updateViewportHeight() {
        // Update CSS custom property for viewport height
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        
        // Update elements that use viewport height
        document.querySelectorAll('.viewport-height-adaptive').forEach(element => {
            element.style.height = `${window.innerHeight}px`;
        });
    }

    adjustForKeyboard() {
        // Adjust modals for keyboard
        document.querySelectorAll('.modal.show').forEach(modal => {
            const modalBody = modal.querySelector('.modal-body');
            if (modalBody) {
                modalBody.style.paddingBottom = '50vh';
            }
        });
        
        // Adjust bottom sheets
        document.querySelectorAll('.bottom-sheet.active').forEach(sheet => {
            sheet.style.transform = 'translateY(-30vh)';
        });
        
        // Adjust FAB
        document.querySelectorAll('.fab').forEach(fab => {
            fab.style.bottom = '60vh';
        });
    }

    restoreFromKeyboard() {
        // Restore modal padding
        document.querySelectorAll('.modal .modal-body').forEach(modalBody => {
            modalBody.style.paddingBottom = '';
        });
        
        // Restore bottom sheets
        document.querySelectorAll('.bottom-sheet').forEach(sheet => {
            sheet.style.transform = '';
        });
        
        // Restore FAB
        document.querySelectorAll('.fab').forEach(fab => {
            fab.style.bottom = '';
        });
    }

    notifyComponents() {
        // Notify charts to resize
        window.dispatchEvent(new Event('resize'));
        
        // Notify custom components
        document.dispatchEvent(new CustomEvent('orientationchange', {
            detail: {
                orientation: this.currentOrientation,
                isPortrait: this.isPortrait(),
                isLandscape: this.isLandscape()
            }
        }));
        
        // Resize charts specifically
        this.resizeCharts();
        
        // Recalculate table layouts
        this.recalculateTableLayouts();
        
        // Update modal layouts
        this.updateModalLayouts();
    }

    resizeCharts() {
        // Resize Chart.js charts
        if (window.Chart) {
            Object.values(window.Chart.instances).forEach(chart => {
                if (chart && chart.resize) {
                    setTimeout(() => chart.resize(), 100);
                }
            });
        }
        
        // Resize custom charts
        document.querySelectorAll('canvas[data-chart]').forEach(canvas => {
            if (canvas.chart && canvas.chart.resize) {
                setTimeout(() => canvas.chart.resize(), 100);
            }
        });
    }

    recalculateTableLayouts() {
        // Force table reflow
        document.querySelectorAll('.table-responsive').forEach(container => {
            const display = container.style.display;
            container.style.display = 'none';
            container.offsetHeight; // Trigger reflow
            container.style.display = display;
        });
        
        // Update mobile table cards
        if (window.innerWidth <= 768) {
            document.querySelectorAll('.mobile-table-card').forEach(card => {
                card.classList.add('orientation-animate');
                setTimeout(() => {
                    card.classList.remove('orientation-animate');
                }, 300);
            });
        }
    }

    updateModalLayouts() {
        // Update modal sizes and positions
        document.querySelectorAll('.modal.show').forEach(modal => {
            const dialog = modal.querySelector('.modal-dialog');
            if (dialog) {
                // Force recalculation
                dialog.style.transform = 'none';
                dialog.offsetHeight; // Trigger reflow
                dialog.style.transform = '';
            }
        });
    }

    // Public methods
    getCurrentOrientation() {
        return this.currentOrientation;
    }

    isCurrentlyPortrait() {
        return this.isPortrait();
    }

    isCurrentlyLandscape() {
        return this.isLandscape();
    }

    forceUpdate() {
        this.updateOrientation();
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize orientation handler
    window.orientationHandler = new OrientationHandler();
});

// Export for use in other modules
window.OrientationHandler = OrientationHandler;