/**
 * Accessibility Manager - Comprehensive accessibility support for SuperStock
 * Handles ARIA labels, keyboard navigation, focus management, and screen reader support
 */

class AccessibilityManager {
    constructor() {
        this.focusableElements = [
            'a[href]',
            'button:not([disabled])',
            'input:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            '[tabindex]:not([tabindex="-1"])',
            '[role="button"]:not([disabled])',
            '[role="link"]:not([disabled])'
        ].join(', ');
        
        this.init();
    }

    init() {
        this.setupKeyboardNavigation();
        this.setupFocusManagement();
        this.setupAriaLiveRegions();
        this.setupSkipLinks();
        this.enhanceFormAccessibility();
        this.setupModalAccessibility();
        this.setupTableAccessibility();
        this.setupNotificationAccessibility();
        this.setupChartAccessibility();
    }

    /**
     * Setup keyboard navigation for the entire application
     */
    setupKeyboardNavigation() {
        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Alt + M: Main navigation
            if (e.altKey && e.key === 'm') {
                e.preventDefault();
                this.focusMainNavigation();
                this.announceToScreenReader('Main navigation focused');
            }
            
            // Alt + C: Main content
            if (e.altKey && e.key === 'c') {
                e.preventDefault();
                this.focusMainContent();
                this.announceToScreenReader('Main content focused');
            }
            
            // Alt + S: Search
            if (e.altKey && e.key === 's') {
                e.preventDefault();
                this.focusSearch();
                this.announceToScreenReader('Search focused');
            }
            
            // Escape: Close modals/dropdowns
            if (e.key === 'Escape') {
                this.handleEscapeKey();
            }
        });

        // Enhanced tab navigation
        this.setupTabNavigation();
        
        // Arrow key navigation for menus and tables
        this.setupArrowKeyNavigation();
    }

    /**
     * Setup tab navigation with proper focus indicators
     */
    setupTabNavigation() {
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                document.body.classList.add('keyboard-navigation');
                
                // Remove mouse navigation class after a delay
                setTimeout(() => {
                    document.body.classList.remove('mouse-navigation');
                }, 100);
            }
        });

        document.addEventListener('mousedown', () => {
            document.body.classList.add('mouse-navigation');
            document.body.classList.remove('keyboard-navigation');
        });
    }

    /**
     * Setup arrow key navigation for menus and data tables
     */
    setupArrowKeyNavigation() {
        // Navigation menu arrow keys
        const navMenu = document.querySelector('.nav-menu');
        if (navMenu) {
            navMenu.addEventListener('keydown', (e) => {
                const items = navMenu.querySelectorAll('.nav-link');
                const currentIndex = Array.from(items).indexOf(document.activeElement);
                
                if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    const nextIndex = (currentIndex + 1) % items.length;
                    items[nextIndex].focus();
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                    e.preventDefault();
                    const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                    items[prevIndex].focus();
                }
            });
        }

        // Table navigation
        this.setupTableNavigation();
    }

    /**
     * Setup table keyboard navigation
     */
    setupTableNavigation() {
        const tables = document.querySelectorAll('table, .table-container');
        
        tables.forEach(table => {
            table.addEventListener('keydown', (e) => {
                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(e.key)) {
                    return;
                }
                
                e.preventDefault();
                this.navigateTable(e, table);
            });
        });
    }

    /**
     * Navigate within tables using arrow keys
     */
    navigateTable(event, table) {
        const cells = table.querySelectorAll('td, th, [role="gridcell"], [role="columnheader"]');
        const currentCell = document.activeElement.closest('td, th, [role="gridcell"], [role="columnheader"]');
        
        if (!currentCell) return;
        
        const currentIndex = Array.from(cells).indexOf(currentCell);
        const rows = table.querySelectorAll('tr, [role="row"]');
        const currentRow = currentCell.closest('tr, [role="row"]');
        const currentRowIndex = Array.from(rows).indexOf(currentRow);
        const cellsInRow = currentRow.querySelectorAll('td, th, [role="gridcell"], [role="columnheader"]');
        const cellInRowIndex = Array.from(cellsInRow).indexOf(currentCell);
        
        let targetCell = null;
        
        switch (event.key) {
            case 'ArrowRight':
                targetCell = cells[currentIndex + 1];
                break;
            case 'ArrowLeft':
                targetCell = cells[currentIndex - 1];
                break;
            case 'ArrowDown':
                if (currentRowIndex < rows.length - 1) {
                    const nextRow = rows[currentRowIndex + 1];
                    const nextRowCells = nextRow.querySelectorAll('td, th, [role="gridcell"], [role="columnheader"]');
                    targetCell = nextRowCells[Math.min(cellInRowIndex, nextRowCells.length - 1)];
                }
                break;
            case 'ArrowUp':
                if (currentRowIndex > 0) {
                    const prevRow = rows[currentRowIndex - 1];
                    const prevRowCells = prevRow.querySelectorAll('td, th, [role="gridcell"], [role="columnheader"]');
                    targetCell = prevRowCells[Math.min(cellInRowIndex, prevRowCells.length - 1)];
                }
                break;
            case 'Home':
                targetCell = cellsInRow[0];
                break;
            case 'End':
                targetCell = cellsInRow[cellsInRow.length - 1];
                break;
        }
        
        if (targetCell) {
            const focusableElement = targetCell.querySelector(this.focusableElements) || targetCell;
            if (focusableElement.tabIndex === undefined || focusableElement.tabIndex < 0) {
                focusableElement.tabIndex = 0;
            }
            focusableElement.focus();
        }
    }

    /**
     * Setup focus management for modals and dynamic content
     */
    setupFocusManagement() {
        // Store focus before modal opens
        document.addEventListener('show.bs.modal', (e) => {
            this.previousFocus = document.activeElement;
            
            // Set up focus trap for modal
            setTimeout(() => {
                this.setupFocusTrap(e.target);
                this.focusFirstElement(e.target);
            }, 100);
        });

        // Restore focus when modal closes
        document.addEventListener('hidden.bs.modal', () => {
            if (this.previousFocus) {
                this.previousFocus.focus();
                this.previousFocus = null;
            }
        });
    }

    /**
     * Setup focus trap for modals
     */
    setupFocusTrap(modal) {
        const focusableElements = modal.querySelectorAll(this.focusableElements);
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        modal.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                if (e.shiftKey) {
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }
        });
    }

    /**
     * Focus the first focusable element in a container
     */
    focusFirstElement(container) {
        const firstFocusable = container.querySelector(this.focusableElements);
        if (firstFocusable) {
            firstFocusable.focus();
        }
    }

    /**
     * Setup ARIA live regions for dynamic content updates
     */
    setupAriaLiveRegions() {
        // Create live regions if they don't exist
        if (!document.getElementById('aria-live-polite')) {
            const politeRegion = document.createElement('div');
            politeRegion.id = 'aria-live-polite';
            politeRegion.setAttribute('aria-live', 'polite');
            politeRegion.setAttribute('aria-atomic', 'true');
            politeRegion.className = 'sr-only';
            document.body.appendChild(politeRegion);
        }

        if (!document.getElementById('aria-live-assertive')) {
            const assertiveRegion = document.createElement('div');
            assertiveRegion.id = 'aria-live-assertive';
            assertiveRegion.setAttribute('aria-live', 'assertive');
            assertiveRegion.setAttribute('aria-atomic', 'true');
            assertiveRegion.className = 'sr-only';
            document.body.appendChild(assertiveRegion);
        }
    }

    /**
     * Announce messages to screen readers
     */
    announceToScreenReader(message, priority = 'polite') {
        const liveRegion = document.getElementById(`aria-live-${priority}`);
        if (liveRegion) {
            liveRegion.textContent = message;
            
            // Clear after announcement
            setTimeout(() => {
                liveRegion.textContent = '';
            }, 1000);
        }
    }

    /**
     * Setup skip links for keyboard navigation
     */
    setupSkipLinks() {
        const skipLinks = document.createElement('div');
        skipLinks.className = 'skip-links';
        skipLinks.innerHTML = `
            <a href="#main-content" class="skip-link">Skip to main content</a>
            <a href="#main-navigation" class="skip-link">Skip to navigation</a>
            <a href="#search" class="skip-link">Skip to search</a>
        `;
        
        document.body.insertBefore(skipLinks, document.body.firstChild);
    }

    /**
     * Enhance form accessibility
     */
    enhanceFormAccessibility() {
        const forms = document.querySelectorAll('form');
        
        forms.forEach(form => {
            // Associate labels with inputs
            const inputs = form.querySelectorAll('input, select, textarea');
            inputs.forEach(input => {
                if (!input.getAttribute('aria-label') && !input.getAttribute('aria-labelledby')) {
                    const label = form.querySelector(`label[for="${input.id}"]`);
                    if (label) {
                        input.setAttribute('aria-labelledby', label.id || this.generateId('label'));
                        if (!label.id) {
                            label.id = input.getAttribute('aria-labelledby');
                        }
                    }
                }
                
                // Add required indicators
                if (input.required) {
                    input.setAttribute('aria-required', 'true');
                }
                
                // Add invalid state handling
                input.addEventListener('invalid', () => {
                    input.setAttribute('aria-invalid', 'true');
                });
                
                input.addEventListener('input', () => {
                    if (input.checkValidity()) {
                        input.removeAttribute('aria-invalid');
                    }
                });
            });
        });
    }

    /**
     * Setup modal accessibility
     */
    setupModalAccessibility() {
        const modals = document.querySelectorAll('.modal');
        
        modals.forEach(modal => {
            // Ensure proper ARIA attributes
            if (!modal.getAttribute('role')) {
                modal.setAttribute('role', 'dialog');
            }
            
            if (!modal.getAttribute('aria-modal')) {
                modal.setAttribute('aria-modal', 'true');
            }
            
            // Add aria-labelledby if modal has a title
            const title = modal.querySelector('.modal-title, h1, h2, h3, h4, h5, h6');
            if (title && !modal.getAttribute('aria-labelledby')) {
                if (!title.id) {
                    title.id = this.generateId('modal-title');
                }
                modal.setAttribute('aria-labelledby', title.id);
            }
        });
    }

    /**
     * Setup table accessibility
     */
    setupTableAccessibility() {
        const tables = document.querySelectorAll('table');
        
        tables.forEach(table => {
            // Add table role if not present
            if (!table.getAttribute('role')) {
                table.setAttribute('role', 'table');
            }
            
            // Add caption if not present
            if (!table.querySelector('caption') && !table.getAttribute('aria-label')) {
                const sectionTitle = table.closest('.dashboard-section')?.querySelector('.section-title');
                if (sectionTitle) {
                    table.setAttribute('aria-label', sectionTitle.textContent.trim());
                }
            }
            
            // Enhance headers
            const headers = table.querySelectorAll('th');
            headers.forEach(header => {
                if (!header.getAttribute('scope')) {
                    header.setAttribute('scope', 'col');
                }
            });
            
            // Make table focusable for keyboard navigation
            if (table.tabIndex === undefined || table.tabIndex < 0) {
                table.tabIndex = 0;
            }
        });
    }

    /**
     * Setup notification accessibility
     */
    setupNotificationAccessibility() {
        // Observe for new notifications
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.classList?.contains('toast') || node.classList?.contains('notification')) {
                            this.enhanceNotification(node);
                        }
                    }
                });
            });
        });
        
        observer.observe(document.body, { childList: true, subtree: true });
    }

    /**
     * Enhance notification accessibility
     */
    enhanceNotification(notification) {
        // Add ARIA attributes
        notification.setAttribute('role', 'alert');
        notification.setAttribute('aria-live', 'assertive');
        
        // Make focusable
        notification.tabIndex = 0;
        
        // Auto-focus for important notifications
        if (notification.classList.contains('error') || notification.classList.contains('warning')) {
            notification.focus();
        }
        
        // Announce to screen reader
        const message = notification.textContent || notification.innerText;
        this.announceToScreenReader(message, 'assertive');
    }

    /**
     * Setup chart accessibility
     */
    setupChartAccessibility() {
        const charts = document.querySelectorAll('canvas[id*="chart"], .chart-container');
        
        charts.forEach(chart => {
            // Add ARIA label
            if (!chart.getAttribute('aria-label')) {
                chart.setAttribute('aria-label', 'Stock price chart');
            }
            
            // Add role
            chart.setAttribute('role', 'img');
            
            // Make focusable
            if (chart.tabIndex === undefined || chart.tabIndex < 0) {
                chart.tabIndex = 0;
            }
            
            // Add keyboard interaction for charts
            chart.addEventListener('keydown', (e) => {
                this.handleChartKeyboard(e, chart);
            });
        });
    }

    /**
     * Handle keyboard interaction for charts
     */
    handleChartKeyboard(event, chart) {
        const chartInstance = Chart.getChart(chart);
        if (!chartInstance) return;
        
        switch (event.key) {
            case 'ArrowLeft':
                event.preventDefault();
                this.announceToScreenReader('Moving to previous data point');
                break;
            case 'ArrowRight':
                event.preventDefault();
                this.announceToScreenReader('Moving to next data point');
                break;
            case 'Enter':
            case ' ':
                event.preventDefault();
                this.announceChartData(chartInstance);
                break;
        }
    }

    /**
     * Announce chart data to screen reader
     */
    announceChartData(chartInstance) {
        const data = chartInstance.data;
        if (data && data.datasets && data.datasets.length > 0) {
            const dataset = data.datasets[0];
            const latestValue = dataset.data[dataset.data.length - 1];
            const message = `Current stock price: ${latestValue}`;
            this.announceToScreenReader(message, 'assertive');
        }
    }

    /**
     * Focus main navigation
     */
    focusMainNavigation() {
        const nav = document.querySelector('#main-navigation, .nav-menu, .sidebar');
        if (nav) {
            const firstLink = nav.querySelector('a, button');
            if (firstLink) {
                firstLink.focus();
            }
        }
    }

    /**
     * Focus main content
     */
    focusMainContent() {
        const main = document.querySelector('#main-content, main, .main-content');
        if (main) {
            if (main.tabIndex === undefined || main.tabIndex < 0) {
                main.tabIndex = -1;
            }
            main.focus();
        }
    }

    /**
     * Focus search input
     */
    focusSearch() {
        const search = document.querySelector('#search, .search-input, input[type="search"]');
        if (search) {
            search.focus();
        }
    }

    /**
     * Handle escape key press
     */
    handleEscapeKey() {
        // Close open modals
        const openModal = document.querySelector('.modal.show');
        if (openModal) {
            const modal = bootstrap.Modal.getInstance(openModal);
            if (modal) {
                modal.hide();
            }
            return;
        }
        
        // Close open dropdowns
        const openDropdown = document.querySelector('.dropdown-menu.show');
        if (openDropdown) {
            const dropdown = bootstrap.Dropdown.getInstance(openDropdown.previousElementSibling);
            if (dropdown) {
                dropdown.hide();
            }
            return;
        }
        
        // Close mobile navigation
        const sidebar = document.querySelector('.sidebar.show');
        if (sidebar) {
            sidebar.classList.remove('show');
            document.body.classList.remove('sidebar-open');
        }
    }

    /**
     * Generate unique ID
     */
    generateId(prefix = 'element') {
        return `${prefix}-${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Check color contrast ratio
     */
    checkColorContrast(foreground, background) {
        // Convert colors to RGB
        const fgRgb = this.hexToRgb(foreground);
        const bgRgb = this.hexToRgb(background);
        
        if (!fgRgb || !bgRgb) return false;
        
        // Calculate relative luminance
        const fgLuminance = this.getRelativeLuminance(fgRgb);
        const bgLuminance = this.getRelativeLuminance(bgRgb);
        
        // Calculate contrast ratio
        const lighter = Math.max(fgLuminance, bgLuminance);
        const darker = Math.min(fgLuminance, bgLuminance);
        const contrast = (lighter + 0.05) / (darker + 0.05);
        
        // WCAG AA requires 4.5:1 for normal text, 3:1 for large text
        return contrast >= 4.5;
    }

    /**
     * Convert hex color to RGB
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    /**
     * Calculate relative luminance
     */
    getRelativeLuminance(rgb) {
        const { r, g, b } = rgb;
        const [rs, gs, bs] = [r, g, b].map(c => {
            c = c / 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        });
        return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
    }

    /**
     * Validate accessibility compliance
     */
    validateAccessibility() {
        const issues = [];
        
        // Check for missing alt text on images
        const images = document.querySelectorAll('img');
        images.forEach((img, index) => {
            if (!img.alt && !img.getAttribute('aria-label')) {
                issues.push(`Image ${index + 1} missing alt text`);
            }
        });
        
        // Check for missing form labels
        const inputs = document.querySelectorAll('input, select, textarea');
        inputs.forEach((input, index) => {
            if (!input.getAttribute('aria-label') && !input.getAttribute('aria-labelledby') && !document.querySelector(`label[for="${input.id}"]`)) {
                issues.push(`Form input ${index + 1} missing label`);
            }
        });
        
        // Check for missing headings structure
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        let previousLevel = 0;
        headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            if (level > previousLevel + 1) {
                issues.push(`Heading level skipped at heading ${index + 1}`);
            }
            previousLevel = level;
        });
        
        return issues;
    }
}

// Initialize accessibility manager when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.accessibilityManager = new AccessibilityManager();
});

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AccessibilityManager;
}
/**
 * Accessibility Validation Suite
 * Comprehensive validation and compliance testing
 */

class AccessibilityValidator {
    constructor() {
        this.validationResults = [];
        this.wcagGuidelines = this.initializeWCAGGuidelines();
        this.colorContrastThresholds = {
            normal: { AA: 4.5, AAA: 7 },
            large: { AA: 3, AAA: 4.5 }
        };
    }

    /**
     * Initialize WCAG 2.1 guidelines for validation
     */
    initializeWCAGGuidelines() {
        return {
            '1.1.1': 'Non-text Content',
            '1.3.1': 'Info and Relationships',
            '1.3.2': 'Meaningful Sequence',
            '1.4.3': 'Contrast (Minimum)',
            '1.4.6': 'Contrast (Enhanced)',
            '2.1.1': 'Keyboard',
            '2.1.2': 'No Keyboard Trap',
            '2.4.1': 'Bypass Blocks',
            '2.4.2': 'Page Titled',
            '2.4.3': 'Focus Order',
            '2.4.6': 'Headings and Labels',
            '2.4.7': 'Focus Visible',
            '3.1.1': 'Language of Page',
            '3.2.1': 'On Focus',
            '3.2.2': 'On Input',
            '3.3.1': 'Error Identification',
            '3.3.2': 'Labels or Instructions',
            '4.1.1': 'Parsing',
            '4.1.2': 'Name, Role, Value'
        };
    }

    /**
     * Run comprehensive WCAG compliance validation
     */
    async validateWCAGCompliance() {
        console.log('🔍 Starting WCAG 2.1 compliance validation...');
        
        const validation = {
            timestamp: new Date().toISOString(),
            url: window.location.href,
            level: 'AA', // Testing for AA compliance
            guidelines: {},
            summary: {
                total: 0,
                passed: 0,
                failed: 0,
                warnings: 0
            }
        };

        // Validate each WCAG guideline
        for (const [guideline, description] of Object.entries(this.wcagGuidelines)) {
            const result = await this.validateGuideline(guideline, description);
            validation.guidelines[guideline] = result;
            validation.summary.total++;
            
            if (result.status === 'pass') {
                validation.summary.passed++;
            } else if (result.status === 'fail') {
                validation.summary.failed++;
            } else {
                validation.summary.warnings++;
            }
        }

        this.validationResults.push(validation);
        this.displayValidationResults(validation);
        
        return validation;
    }

    /**
     * Validate specific WCAG guideline
     */
    async validateGuideline(guideline, description) {
        const result = {
            guideline,
            description,
            status: 'pass',
            issues: [],
            recommendations: []
        };

        switch (guideline) {
            case '1.1.1':
                return this.validateNonTextContent(result);
            case '1.3.1':
                return this.validateInfoAndRelationships(result);
            case '1.3.2':
                return this.validateMeaningfulSequence(result);
            case '1.4.3':
                return await this.validateColorContrast(result, 'AA');
            case '1.4.6':
                return await this.validateColorContrast(result, 'AAA');
            case '2.1.1':
                return this.validateKeyboardAccess(result);
            case '2.1.2':
                return this.validateNoKeyboardTrap(result);
            case '2.4.1':
                return this.validateBypassBlocks(result);
            case '2.4.2':
                return this.validatePageTitled(result);
            case '2.4.3':
                return this.validateFocusOrder(result);
            case '2.4.6':
                return this.validateHeadingsAndLabels(result);
            case '2.4.7':
                return this.validateFocusVisible(result);
            case '3.1.1':
                return this.validateLanguageOfPage(result);
            case '3.2.1':
                return this.validateOnFocus(result);
            case '3.2.2':
                return this.validateOnInput(result);
            case '3.3.1':
                return this.validateErrorIdentification(result);
            case '3.3.2':
                return this.validateLabelsOrInstructions(result);
            case '4.1.1':
                return this.validateParsing(result);
            case '4.1.2':
                return this.validateNameRoleValue(result);
            default:
                result.status = 'warning';
                result.issues.push('Guideline validation not implemented');
                return result;
        }
    }

    /**
     * Validate 1.1.1 Non-text Content
     */
    validateNonTextContent(result) {
        const images = document.querySelectorAll('img');
        const decorativeImages = document.querySelectorAll('img[alt=""], img[role="presentation"]');
        
        images.forEach((img, index) => {
            const hasAlt = img.hasAttribute('alt');
            const hasAriaLabel = img.hasAttribute('aria-label');
            const hasAriaLabelledby = img.hasAttribute('aria-labelledby');
            const isDecorative = img.getAttribute('alt') === '' || img.getAttribute('role') === 'presentation';
            
            if (!hasAlt && !hasAriaLabel && !hasAriaLabelledby && !isDecorative) {
                result.status = 'fail';
                result.issues.push(`Image ${index + 1} missing alternative text`);
                result.recommendations.push('Add alt attribute or aria-label to provide alternative text');
            }
        });

        // Check other non-text content
        const videos = document.querySelectorAll('video');
        videos.forEach((video, index) => {
            const hasTrack = video.querySelector('track[kind="captions"], track[kind="subtitles"]');
            if (!hasTrack) {
                result.status = 'warning';
                result.issues.push(`Video ${index + 1} may need captions or subtitles`);
                result.recommendations.push('Add caption tracks for video content');
            }
        });

        return result;
    }

    /**
     * Validate 1.3.1 Info and Relationships
     */
    validateInfoAndRelationships(result) {
        // Check form labels
        const inputs = document.querySelectorAll('input:not([type="hidden"]), select, textarea');
        inputs.forEach((input, index) => {
            const hasLabel = input.getAttribute('aria-label') || 
                           input.getAttribute('aria-labelledby') || 
                           document.querySelector(`label[for="${input.id}"]`);
            
            if (!hasLabel) {
                result.status = 'fail';
                result.issues.push(`Form control ${index + 1} missing label relationship`);
                result.recommendations.push('Associate form controls with labels using for/id or aria-labelledby');
            }
        });

        // Check table headers
        const tables = document.querySelectorAll('table');
        tables.forEach((table, index) => {
            const headers = table.querySelectorAll('th');
            const cells = table.querySelectorAll('td');
            
            if (headers.length === 0 && cells.length > 0) {
                result.status = 'fail';
                result.issues.push(`Table ${index + 1} missing header cells`);
                result.recommendations.push('Use th elements for table headers');
            }
        });

        return result;
    }

    /**
     * Validate 1.3.2 Meaningful Sequence
     */
    validateMeaningfulSequence(result) {
        // Check heading order
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        let previousLevel = 0;
        
        headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            
            if (level > previousLevel + 1) {
                result.status = 'warning';
                result.issues.push(`Heading level skipped at position ${index + 1} (${heading.tagName})`);
                result.recommendations.push('Use heading levels in sequential order');
            }
            
            previousLevel = level;
        });

        // Check tab order
        const focusableElements = document.querySelectorAll('[tabindex]');
        focusableElements.forEach((element, index) => {
            const tabIndex = parseInt(element.getAttribute('tabindex'));
            if (tabIndex > 0) {
                result.status = 'warning';
                result.issues.push(`Element ${index + 1} uses positive tabindex (${tabIndex})`);
                result.recommendations.push('Avoid positive tabindex values; use document order instead');
            }
        });

        return result;
    }

    /**
     * Validate color contrast (1.4.3 and 1.4.6)
     */
    async validateColorContrast(result, level) {
        const textElements = document.querySelectorAll('p, span, div, a, button, h1, h2, h3, h4, h5, h6, label, li, td, th');
        const threshold = level === 'AAA' ? this.colorContrastThresholds.normal.AAA : this.colorContrastThresholds.normal.AA;
        
        for (let i = 0; i < Math.min(textElements.length, 50); i++) { // Limit to 50 elements for performance
            const element = textElements[i];
            const computedStyle = window.getComputedStyle(element);
            const color = computedStyle.color;
            const backgroundColor = this.getEffectiveBackgroundColor(element);
            
            if (color && backgroundColor) {
                const contrast = this.calculateColorContrast(color, backgroundColor);
                const fontSize = parseFloat(computedStyle.fontSize);
                const fontWeight = computedStyle.fontWeight;
                const isLargeText = fontSize >= 18 || (fontSize >= 14 && (fontWeight === 'bold' || parseInt(fontWeight) >= 700));
                
                const requiredContrast = isLargeText ? 
                    (level === 'AAA' ? this.colorContrastThresholds.large.AAA : this.colorContrastThresholds.large.AA) :
                    threshold;
                
                if (contrast < requiredContrast) {
                    result.status = 'fail';
                    result.issues.push(`Element ${i + 1} has insufficient color contrast: ${contrast.toFixed(2)}:1 (required: ${requiredContrast}:1)`);
                    result.recommendations.push(`Increase color contrast to meet ${level} standards`);
                }
            }
        }

        return result;
    }

    /**
     * Calculate color contrast ratio
     */
    calculateColorContrast(color1, color2) {
        const rgb1 = this.parseColor(color1);
        const rgb2 = this.parseColor(color2);
        
        if (!rgb1 || !rgb2) return 21; // Return max contrast if parsing fails
        
        const l1 = this.getRelativeLuminance(rgb1);
        const l2 = this.getRelativeLuminance(rgb2);
        
        const lighter = Math.max(l1, l2);
        const darker = Math.min(l1, l2);
        
        return (lighter + 0.05) / (darker + 0.05);
    }

    /**
     * Parse color string to RGB values
     */
    parseColor(colorStr) {
        const div = document.createElement('div');
        div.style.color = colorStr;
        document.body.appendChild(div);
        const computedColor = window.getComputedStyle(div).color;
        document.body.removeChild(div);
        
        const match = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            return {
                r: parseInt(match[1]),
                g: parseInt(match[2]),
                b: parseInt(match[3])
            };
        }
        return null;
    }

    /**
     * Get relative luminance for color contrast calculation
     */
    getRelativeLuminance(rgb) {
        const { r, g, b } = rgb;
        const [rs, gs, bs] = [r, g, b].map(c => {
            c = c / 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        });
        return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
    }

    /**
     * Get effective background color of element
     */
    getEffectiveBackgroundColor(element) {
        let current = element;
        while (current && current !== document.body) {
            const bgColor = window.getComputedStyle(current).backgroundColor;
            if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
                return bgColor;
            }
            current = current.parentElement;
        }
        return 'rgb(255, 255, 255)'; // Default to white
    }

    /**
     * Validate 2.1.1 Keyboard Access
     */
    validateKeyboardAccess(result) {
        const interactiveElements = document.querySelectorAll('a, button, input, select, textarea, [onclick], [onkeydown], [role="button"], [role="link"]');
        
        interactiveElements.forEach((element, index) => {
            const tabIndex = element.getAttribute('tabindex');
            const isNativelyFocusable = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(element.tagName);
            
            if (!isNativelyFocusable && (tabIndex === null || tabIndex === '-1')) {
                result.status = 'fail';
                result.issues.push(`Interactive element ${index + 1} (${element.tagName}) not keyboard accessible`);
                result.recommendations.push('Add tabindex="0" to custom interactive elements');
            }
        });

        return result;
    }

    /**
     * Validate 2.1.2 No Keyboard Trap
     */
    validateNoKeyboardTrap(result) {
        const modals = document.querySelectorAll('.modal, [role="dialog"], [role="alertdialog"]');
        
        modals.forEach((modal, index) => {
            if (modal.style.display !== 'none' && !modal.hidden) {
                const focusableElements = modal.querySelectorAll('a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
                
                if (focusableElements.length === 0) {
                    result.status = 'fail';
                    result.issues.push(`Modal ${index + 1} has no focusable elements - potential keyboard trap`);
                    result.recommendations.push('Ensure modals have focusable elements and proper focus management');
                }
            }
        });

        return result;
    }

    /**
     * Validate 2.4.1 Bypass Blocks
     */
    validateBypassBlocks(result) {
        const skipLinks = document.querySelectorAll('a[href^="#"]');
        const hasSkipToMain = Array.from(skipLinks).some(link => 
            link.textContent.toLowerCase().includes('skip') && 
            (link.textContent.toLowerCase().includes('main') || link.textContent.toLowerCase().includes('content'))
        );
        
        if (!hasSkipToMain) {
            result.status = 'fail';
            result.issues.push('No skip link found for main content');
            result.recommendations.push('Add skip link to main content area');
        }

        return result;
    }

    /**
     * Validate 2.4.2 Page Titled
     */
    validatePageTitled(result) {
        const title = document.querySelector('title');
        
        if (!title || !title.textContent.trim()) {
            result.status = 'fail';
            result.issues.push('Page missing title or title is empty');
            result.recommendations.push('Add descriptive page title');
        } else if (title.textContent.trim().length < 3) {
            result.status = 'warning';
            result.issues.push('Page title may be too short');
            result.recommendations.push('Use descriptive page titles');
        }

        return result;
    }

    /**
     * Validate 2.4.3 Focus Order
     */
    validateFocusOrder(result) {
        const focusableElements = document.querySelectorAll('a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
        
        let hasPositiveTabIndex = false;
        focusableElements.forEach((element, index) => {
            const tabIndex = parseInt(element.getAttribute('tabindex')) || 0;
            if (tabIndex > 0) {
                hasPositiveTabIndex = true;
                result.status = 'warning';
                result.issues.push(`Element ${index + 1} uses positive tabindex (${tabIndex})`);
            }
        });

        if (hasPositiveTabIndex) {
            result.recommendations.push('Avoid positive tabindex values; use logical document order');
        }

        return result;
    }

    /**
     * Validate 2.4.6 Headings and Labels
     */
    validateHeadingsAndLabels(result) {
        // Check headings
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach((heading, index) => {
            if (!heading.textContent.trim()) {
                result.status = 'fail';
                result.issues.push(`Heading ${index + 1} (${heading.tagName}) is empty`);
                result.recommendations.push('Provide descriptive heading text');
            }
        });

        // Check labels
        const labels = document.querySelectorAll('label');
        labels.forEach((label, index) => {
            if (!label.textContent.trim() && !label.getAttribute('aria-label')) {
                result.status = 'fail';
                result.issues.push(`Label ${index + 1} is empty`);
                result.recommendations.push('Provide descriptive label text');
            }
        });

        return result;
    }

    /**
     * Validate 2.4.7 Focus Visible
     */
    validateFocusVisible(result) {
        // This is a simplified check - proper testing would require actual focus events
        const focusableElements = document.querySelectorAll('a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
        
        focusableElements.forEach((element, index) => {
            const computedStyle = window.getComputedStyle(element);
            const outlineStyle = computedStyle.getPropertyValue('outline-style');
            const outlineWidth = computedStyle.getPropertyValue('outline-width');
            
            if (outlineStyle === 'none' || outlineWidth === '0px') {
                // Check for alternative focus indicators
                const hasBoxShadow = computedStyle.getPropertyValue('box-shadow') !== 'none';
                const hasBorder = computedStyle.getPropertyValue('border-width') !== '0px';
                
                if (!hasBoxShadow && !hasBorder) {
                    result.status = 'warning';
                    result.issues.push(`Element ${index + 1} may lack visible focus indicator`);
                    result.recommendations.push('Ensure all focusable elements have visible focus indicators');
                }
            }
        });

        return result;
    }

    /**
     * Validate remaining guidelines (simplified implementations)
     */
    validateLanguageOfPage(result) {
        const html = document.documentElement;
        if (!html.getAttribute('lang')) {
            result.status = 'fail';
            result.issues.push('Page missing language declaration');
            result.recommendations.push('Add lang attribute to html element');
        }
        return result;
    }

    validateOnFocus(result) {
        // This would require dynamic testing - simplified check
        result.status = 'warning';
        result.issues.push('Manual testing required for focus behavior');
        result.recommendations.push('Test that focus events do not cause unexpected context changes');
        return result;
    }

    validateOnInput(result) {
        // This would require dynamic testing - simplified check
        result.status = 'warning';
        result.issues.push('Manual testing required for input behavior');
        result.recommendations.push('Test that input changes do not cause unexpected context changes');
        return result;
    }

    validateErrorIdentification(result) {
        const forms = document.querySelectorAll('form');
        forms.forEach((form, index) => {
            const errorElements = form.querySelectorAll('.error, [role="alert"], .invalid');
            if (errorElements.length === 0) {
                result.status = 'warning';
                result.issues.push(`Form ${index + 1} may lack error identification mechanism`);
                result.recommendations.push('Implement clear error identification for form validation');
            }
        });
        return result;
    }

    validateLabelsOrInstructions(result) {
        const requiredInputs = document.querySelectorAll('input[required], select[required], textarea[required]');
        requiredInputs.forEach((input, index) => {
            const hasRequiredIndicator = input.getAttribute('aria-required') === 'true' ||
                                       input.closest('label')?.textContent.includes('*') ||
                                       input.getAttribute('aria-describedby');
            
            if (!hasRequiredIndicator) {
                result.status = 'warning';
                result.issues.push(`Required field ${index + 1} may lack clear indication`);
                result.recommendations.push('Clearly indicate required form fields');
            }
        });
        return result;
    }

    validateParsing(result) {
        // Basic HTML validation - would need more sophisticated parsing
        const duplicateIds = this.findDuplicateIds();
        if (duplicateIds.length > 0) {
            result.status = 'fail';
            result.issues.push(`Duplicate IDs found: ${duplicateIds.join(', ')}`);
            result.recommendations.push('Ensure all IDs are unique');
        }
        return result;
    }

    validateNameRoleValue(result) {
        const customElements = document.querySelectorAll('[role]');
        customElements.forEach((element, index) => {
            const role = element.getAttribute('role');
            const hasName = element.getAttribute('aria-label') || 
                          element.getAttribute('aria-labelledby') ||
                          element.textContent.trim();
            
            if (!hasName && ['button', 'link', 'menuitem'].includes(role)) {
                result.status = 'fail';
                result.issues.push(`Element ${index + 1} with role="${role}" missing accessible name`);
                result.recommendations.push('Provide accessible names for interactive elements');
            }
        });
        return result;
    }

    /**
     * Find duplicate IDs in the document
     */
    findDuplicateIds() {
        const ids = {};
        const duplicates = [];
        
        document.querySelectorAll('[id]').forEach(element => {
            const id = element.id;
            if (ids[id]) {
                if (!duplicates.includes(id)) {
                    duplicates.push(id);
                }
            } else {
                ids[id] = true;
            }
        });
        
        return duplicates;
    }

    /**
     * Display validation results
     */
    displayValidationResults(validation) {
        console.group('📋 WCAG 2.1 Compliance Validation Results');
        console.log('Timestamp:', validation.timestamp);
        console.log('URL:', validation.url);
        console.log('Level:', validation.level);
        
        console.group('📊 Summary');
        console.log('Total Guidelines Tested:', validation.summary.total);
        console.log('✅ Passed:', validation.summary.passed);
        console.log('❌ Failed:', validation.summary.failed);
        console.log('⚠️ Warnings:', validation.summary.warnings);
        console.groupEnd();
        
        // Display failed guidelines
        const failedGuidelines = Object.entries(validation.guidelines).filter(([_, result]) => result.status === 'fail');
        if (failedGuidelines.length > 0) {
            console.group('❌ Failed Guidelines');
            failedGuidelines.forEach(([guideline, result]) => {
                console.group(`${guideline}: ${result.description}`);
                result.issues.forEach(issue => console.log('Issue:', issue));
                result.recommendations.forEach(rec => console.log('Recommendation:', rec));
                console.groupEnd();
            });
            console.groupEnd();
        }
        
        // Display warnings
        const warningGuidelines = Object.entries(validation.guidelines).filter(([_, result]) => result.status === 'warning');
        if (warningGuidelines.length > 0) {
            console.group('⚠️ Warnings');
            warningGuidelines.forEach(([guideline, result]) => {
                console.group(`${guideline}: ${result.description}`);
                result.issues.forEach(issue => console.log('Issue:', issue));
                result.recommendations.forEach(rec => console.log('Recommendation:', rec));
                console.groupEnd();
            });
            console.groupEnd();
        }
        
        console.groupEnd();
        
        // Overall compliance status
        const compliancePercentage = (validation.summary.passed / validation.summary.total * 100).toFixed(1);
        if (validation.summary.failed === 0) {
            console.log(`🎉 WCAG 2.1 ${validation.level} Compliance: ${compliancePercentage}% (No critical failures)`);
        } else {
            console.warn(`⚠️ WCAG 2.1 ${validation.level} Compliance: ${compliancePercentage}% (${validation.summary.failed} critical failures)`);
        }
    }

    /**
     * Export validation results
     */
    exportValidationResults() {
        if (this.validationResults.length === 0) {
            console.warn('No validation results available. Run validation first.');
            return null;
        }
        
        const latestResults = this.validationResults[this.validationResults.length - 1];
        const dataStr = JSON.stringify(latestResults, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `wcag-validation-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        return latestResults;
    }
}

// Initialize validator when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.accessibilityValidator = new AccessibilityValidator();
    
    // Add keyboard shortcut for WCAG validation (Ctrl+Alt+W)
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.altKey && e.key === 'w') {
            e.preventDefault();
            window.accessibilityValidator.validateWCAGCompliance();
        }
    });
});

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AccessibilityValidator;
}
/**
 * Keyboard Navigation Testing Suite
 * Comprehensive keyboard accessibility testing
 */

class KeyboardNavigationTester {
    constructor() {
        this.testResults = [];
        this.focusableSelectors = [
            'a[href]',
            'button:not([disabled])',
            'input:not([disabled]):not([type="hidden"])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            '[tabindex]:not([tabindex="-1"])',
            '[contenteditable="true"]',
            'audio[controls]',
            'video[controls]',
            'details summary',
            '[role="button"]',
            '[role="link"]',
            '[role="menuitem"]',
            '[role="tab"]'
        ];
        this.currentFocusIndex = -1;
        this.focusableElements = [];
        this.isTestingActive = false;
    }

    /**
     * Run comprehensive keyboard navigation tests
     */
    async runKeyboardTests() {
        console.log('⌨️ Starting keyboard navigation tests...');
        
        const testResults = {
            timestamp: new Date().toISOString(),
            url: window.location.href,
            tests: {}
        };

        // Test 1: Focus order and tab sequence
        testResults.tests.focusOrder = await this.testFocusOrder();
        
        // Test 2: Keyboard traps
        testResults.tests.keyboardTraps = await this.testKeyboardTraps();
        
        // Test 3: Skip links functionality
        testResults.tests.skipLinks = await this.testSkipLinks();
        
        // Test 4: Modal focus management
        testResults.tests.modalFocus = await this.testModalFocus();
        
        // Test 5: Custom interactive elements
        testResults.tests.customElements = await this.testCustomInteractiveElements();
        
        // Test 6: Keyboard shortcuts
        testResults.tests.keyboardShortcuts = await this.testKeyboardShortcuts();
        
        // Test 7: Focus visibility
        testResults.tests.focusVisibility = await this.testFocusVisibility();

        this.testResults.push(testResults);
        this.displayKeyboardTestResults(testResults);
        
        return testResults;
    }

    /**
     * Test focus order and tab sequence
     */
    async testFocusOrder() {
        const test = {
            name: 'Focus Order and Tab Sequence',
            status: 'pass',
            issues: [],
            focusableElements: 0,
            tabIndexIssues: 0
        };

        this.focusableElements = Array.from(document.querySelectorAll(this.focusableSelectors.join(', ')));
        test.focusableElements = this.focusableElements.length;

        // Check for positive tabindex values
        this.focusableElements.forEach((element, index) => {
            const tabIndex = parseInt(element.getAttribute('tabindex')) || 0;
            
            if (tabIndex > 0) {
                test.tabIndexIssues++;
                test.status = 'warning';
                test.issues.push({
                    element: this.getElementDescription(element),
                    issue: `Positive tabindex (${tabIndex}) found`,
                    recommendation: 'Use tabindex="0" or rely on natural document order'
                });
            }
        });

        // Check for logical focus order
        const visualOrder = this.getVisualOrder(this.focusableElements);
        const domOrder = this.focusableElements;
        
        for (let i = 0; i < Math.min(visualOrder.length, domOrder.length); i++) {
            if (visualOrder[i] !== domOrder[i]) {
                test.status = 'warning';
                test.issues.push({
                    element: this.getElementDescription(domOrder[i]),
                    issue: 'Focus order may not match visual order',
                    recommendation: 'Ensure tab order follows logical visual flow'
                });
                break; // Only report first mismatch to avoid spam
            }
        }

        return test;
    }

    /**
     * Test for keyboard traps
     */
    async testKeyboardTraps() {
        const test = {
            name: 'Keyboard Traps',
            status: 'pass',
            issues: [],
            modalsFound: 0,
            trapsDetected: 0
        };

        const modals = document.querySelectorAll('.modal, [role="dialog"], [role="alertdialog"]');
        test.modalsFound = modals.length;

        modals.forEach((modal, index) => {
            const isVisible = this.isElementVisible(modal);
            
            if (isVisible) {
                const focusableInModal = modal.querySelectorAll(this.focusableSelectors.join(', '));
                
                if (focusableInModal.length === 0) {
                    test.trapsDetected++;
                    test.status = 'fail';
                    test.issues.push({
                        element: `Modal ${index + 1}`,
                        issue: 'Modal has no focusable elements - potential keyboard trap',
                        recommendation: 'Ensure modals contain focusable elements and proper focus management'
                    });
                }
                
                // Check if modal has close mechanism
                const closeButton = modal.querySelector('[data-bs-dismiss="modal"], .btn-close, .close');
                if (!closeButton) {
                    test.status = 'warning';
                    test.issues.push({
                        element: `Modal ${index + 1}`,
                        issue: 'Modal may lack keyboard-accessible close mechanism',
                        recommendation: 'Provide keyboard-accessible way to close modal (Escape key or close button)'
                    });
                }
            }
        });

        return test;
    }

    /**
     * Test skip links functionality
     */
    async testSkipLinks() {
        const test = {
            name: 'Skip Links',
            status: 'pass',
            issues: [],
            skipLinksFound: 0,
            workingSkipLinks: 0
        };

        const skipLinks = document.querySelectorAll('a[href^="#"]');
        const potentialSkipLinks = Array.from(skipLinks).filter(link => 
            link.textContent.toLowerCase().includes('skip') ||
            link.textContent.toLowerCase().includes('jump') ||
            link.classList.contains('skip-link')
        );

        test.skipLinksFound = potentialSkipLinks.length;

        if (potentialSkipLinks.length === 0) {
            test.status = 'warning';
            test.issues.push({
                element: 'Page',
                issue: 'No skip links found',
                recommendation: 'Add skip links to help keyboard users bypass repetitive content'
            });
        }

        potentialSkipLinks.forEach((link, index) => {
            const targetId = link.getAttribute('href').substring(1);
            const target = document.getElementById(targetId);
            
            if (!target) {
                test.status = 'fail';
                test.issues.push({
                    element: `Skip link ${index + 1}`,
                    issue: `Target element with ID "${targetId}" not found`,
                    recommendation: 'Ensure skip link targets exist and have proper IDs'
                });
            } else {
                test.workingSkipLinks++;
                
                // Check if target is focusable
                const isTargetFocusable = target.getAttribute('tabindex') !== null || 
                                        this.focusableSelectors.some(selector => target.matches(selector));
                
                if (!isTargetFocusable) {
                    test.status = 'warning';
                    test.issues.push({
                        element: `Skip link ${index + 1} target`,
                        issue: 'Skip link target may not be focusable',
                        recommendation: 'Add tabindex="-1" to skip link targets to ensure they can receive focus'
                    });
                }
            }
        });

        return test;
    }

    /**
     * Test modal focus management
     */
    async testModalFocus() {
        const test = {
            name: 'Modal Focus Management',
            status: 'pass',
            issues: [],
            modalsFound: 0
        };

        const modals = document.querySelectorAll('.modal, [role="dialog"], [role="alertdialog"]');
        test.modalsFound = modals.length;

        modals.forEach((modal, index) => {
            // Check for proper ARIA attributes
            if (!modal.getAttribute('aria-labelledby') && !modal.getAttribute('aria-label')) {
                test.status = 'warning';
                test.issues.push({
                    element: `Modal ${index + 1}`,
                    issue: 'Modal missing accessible name (aria-labelledby or aria-label)',
                    recommendation: 'Add aria-labelledby pointing to modal title or aria-label'
                });
            }

            // Check for aria-modal attribute
            if (modal.getAttribute('aria-modal') !== 'true') {
                test.status = 'warning';
                test.issues.push({
                    element: `Modal ${index + 1}`,
                    issue: 'Modal missing aria-modal="true" attribute',
                    recommendation: 'Add aria-modal="true" to indicate modal behavior'
                });
            }

            // Check for proper role
            const role = modal.getAttribute('role');
            if (!role || !['dialog', 'alertdialog'].includes(role)) {
                test.status = 'warning';
                test.issues.push({
                    element: `Modal ${index + 1}`,
                    issue: 'Modal missing proper role attribute',
                    recommendation: 'Add role="dialog" or role="alertdialog" to modal'
                });
            }
        });

        return test;
    }

    /**
     * Test custom interactive elements
     */
    async testCustomInteractiveElements() {
        const test = {
            name: 'Custom Interactive Elements',
            status: 'pass',
            issues: [],
            customElementsFound: 0
        };

        // Find elements with click handlers that aren't naturally focusable
        const clickableElements = document.querySelectorAll('[onclick], [data-toggle], [data-bs-toggle]');
        
        clickableElements.forEach((element, index) => {
            const isNativelyFocusable = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(element.tagName);
            const hasTabIndex = element.hasAttribute('tabindex');
            const hasRole = element.hasAttribute('role');
            
            if (!isNativelyFocusable) {
                test.customElementsFound++;
                
                if (!hasTabIndex || element.getAttribute('tabindex') === '-1') {
                    test.status = 'fail';
                    test.issues.push({
                        element: this.getElementDescription(element),
                        issue: 'Interactive element not keyboard accessible',
                        recommendation: 'Add tabindex="0" to make element focusable'
                    });
                }
                
                if (!hasRole) {
                    test.status = 'warning';
                    test.issues.push({
                        element: this.getElementDescription(element),
                        issue: 'Interactive element missing role attribute',
                        recommendation: 'Add appropriate role (button, link, etc.)'
                    });
                }
                
                // Check for keyboard event handlers
                const hasKeyHandler = element.hasAttribute('onkeydown') || 
                                    element.hasAttribute('onkeyup') || 
                                    element.hasAttribute('onkeypress');
                
                if (!hasKeyHandler) {
                    test.status = 'warning';
                    test.issues.push({
                        element: this.getElementDescription(element),
                        issue: 'Interactive element may lack keyboard event handling',
                        recommendation: 'Add keyboard event handlers (Enter/Space keys)'
                    });
                }
            }
        });

        return test;
    }

    /**
     * Test keyboard shortcuts
     */
    async testKeyboardShortcuts() {
        const test = {
            name: 'Keyboard Shortcuts',
            status: 'pass',
            issues: [],
            shortcutsFound: 0
        };

        // Look for elements with accesskey attributes
        const elementsWithAccessKey = document.querySelectorAll('[accesskey]');
        test.shortcutsFound = elementsWithAccessKey.length;

        elementsWithAccessKey.forEach((element, index) => {
            const accessKey = element.getAttribute('accesskey');
            
            // Check for conflicts with browser shortcuts
            const conflictingKeys = ['f', 'h', 'r', 't', 'n', 'w', 'l', 'd'];
            if (conflictingKeys.includes(accessKey.toLowerCase())) {
                test.status = 'warning';
                test.issues.push({
                    element: this.getElementDescription(element),
                    issue: `Access key "${accessKey}" may conflict with browser shortcuts`,
                    recommendation: 'Use non-conflicting access keys or avoid accesskey attribute'
                });
            }
        });

        return test;
    }

    /**
     * Test focus visibility
     */
    async testFocusVisibility() {
        const test = {
            name: 'Focus Visibility',
            status: 'pass',
            issues: [],
            elementsChecked: 0,
            elementsWithoutIndicator: 0
        };

        // Test a sample of focusable elements
        const sampleElements = this.focusableElements.slice(0, 20); // Test first 20 elements
        test.elementsChecked = sampleElements.length;

        for (const element of sampleElements) {
            try {
                // Temporarily focus the element to check its focus styles
                const originalFocus = document.activeElement;
                element.focus();
                
                await new Promise(resolve => setTimeout(resolve, 50)); // Allow styles to apply
                
                const computedStyle = window.getComputedStyle(element);
                const hasFocusIndicator = this.checkFocusIndicator(computedStyle);
                
                if (!hasFocusIndicator) {
                    test.elementsWithoutIndicator++;
                    test.status = 'warning';
                    test.issues.push({
                        element: this.getElementDescription(element),
                        issue: 'Element may lack visible focus indicator',
                        recommendation: 'Add visible focus styles (outline, box-shadow, border, etc.)'
                    });
                }
                
                // Restore original focus
                if (originalFocus && originalFocus.focus) {
                    originalFocus.focus();
                }
            } catch (error) {
                // Element might not be focusable in current state
                console.warn('Could not test focus for element:', element);
            }
        }

        return test;
    }

    /**
     * Check if element has visible focus indicator
     */
    checkFocusIndicator(computedStyle) {
        // Check outline
        const outlineStyle = computedStyle.getPropertyValue('outline-style');
        const outlineWidth = computedStyle.getPropertyValue('outline-width');
        const outlineColor = computedStyle.getPropertyValue('outline-color');
        
        if (outlineStyle !== 'none' && outlineWidth !== '0px' && outlineColor !== 'transparent') {
            return true;
        }
        
        // Check box-shadow
        const boxShadow = computedStyle.getPropertyValue('box-shadow');
        if (boxShadow && boxShadow !== 'none') {
            return true;
        }
        
        // Check border changes
        const borderWidth = computedStyle.getPropertyValue('border-width');
        const borderStyle = computedStyle.getPropertyValue('border-style');
        const borderColor = computedStyle.getPropertyValue('border-color');
        
        if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent') {
            return true;
        }
        
        // Check background color changes
        const backgroundColor = computedStyle.getPropertyValue('background-color');
        if (backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent') {
            return true;
        }
        
        return false;
    }

    /**
     * Get visual order of elements (simplified)
     */
    getVisualOrder(elements) {
        return elements.sort((a, b) => {
            const rectA = a.getBoundingClientRect();
            const rectB = b.getBoundingClientRect();
            
            // Sort by top position first, then left position
            if (Math.abs(rectA.top - rectB.top) > 10) {
                return rectA.top - rectB.top;
            }
            return rectA.left - rectB.left;
        });
    }

    /**
     * Check if element is visible
     */
    isElementVisible(element) {
        const style = window.getComputedStyle(element);
        const rect = element.getBoundingClientRect();
        
        return style.display !== 'none' &&
               style.visibility !== 'hidden' &&
               style.opacity !== '0' &&
               rect.width > 0 &&
               rect.height > 0;
    }

    /**
     * Get element description for reporting
     */
    getElementDescription(element) {
        let description = element.tagName.toLowerCase();
        
        if (element.id) {
            description += `#${element.id}`;
        }
        
        if (element.className) {
            description += `.${element.className.split(' ').join('.')}`;
        }
        
        if (element.textContent && element.textContent.trim()) {
            const text = element.textContent.trim().substring(0, 30);
            description += ` ("${text}${element.textContent.length > 30 ? '...' : ''}")`;
        }
        
        return description;
    }

    /**
     * Display keyboard test results
     */
    displayKeyboardTestResults(results) {
        console.group('⌨️ Keyboard Navigation Test Results');
        console.log('Timestamp:', results.timestamp);
        console.log('URL:', results.url);
        
        Object.entries(results.tests).forEach(([testName, testResult]) => {
            const status = testResult.status === 'pass' ? '✅' : 
                          testResult.status === 'warning' ? '⚠️' : '❌';
            
            console.group(`${status} ${testResult.name}`);
            console.log('Status:', testResult.status);
            
            // Display test-specific metrics
            if (testResult.focusableElements !== undefined) {
                console.log('Focusable elements found:', testResult.focusableElements);
            }
            if (testResult.modalsFound !== undefined) {
                console.log('Modals found:', testResult.modalsFound);
            }
            if (testResult.skipLinksFound !== undefined) {
                console.log('Skip links found:', testResult.skipLinksFound);
            }
            
            if (testResult.issues.length > 0) {
                console.group('Issues Found');
                testResult.issues.forEach(issue => {
                    console.group(issue.element);
                    console.log('Issue:', issue.issue);
                    console.log('Recommendation:', issue.recommendation);
                    console.groupEnd();
                });
                console.groupEnd();
            }
            
            console.groupEnd();
        });
        
        console.groupEnd();
        
        // Summary
        const totalTests = Object.keys(results.tests).length;
        const passedTests = Object.values(results.tests).filter(test => test.status === 'pass').length;
        const failedTests = Object.values(results.tests).filter(test => test.status === 'fail').length;
        
        console.log(`📊 Keyboard Navigation Summary: ${passedTests}/${totalTests} tests passed`);
        if (failedTests > 0) {
            console.warn(`⚠️ ${failedTests} critical keyboard navigation issues found`);
        }
    }

    /**
     * Start interactive keyboard testing mode
     */
    startInteractiveTest() {
        if (this.isTestingActive) {
            console.log('Interactive testing already active');
            return;
        }
        
        this.isTestingActive = true;
        this.currentFocusIndex = -1;
        this.focusableElements = Array.from(document.querySelectorAll(this.focusableSelectors.join(', ')));
        
        console.log('🎮 Interactive keyboard testing started');
        console.log('Use Tab/Shift+Tab to navigate, or press Ctrl+Alt+K to stop');
        console.log(`Found ${this.focusableElements.length} focusable elements`);
        
        this.addInteractiveTestListeners();
    }

    /**
     * Stop interactive keyboard testing mode
     */
    stopInteractiveTest() {
        this.isTestingActive = false;
        this.removeInteractiveTestListeners();
        console.log('🛑 Interactive keyboard testing stopped');
    }

    /**
     * Add event listeners for interactive testing
     */
    addInteractiveTestListeners() {
        this.interactiveKeyHandler = (e) => {
            if (e.ctrlKey && e.altKey && e.key === 'k') {
                e.preventDefault();
                this.stopInteractiveTest();
                return;
            }
            
            if (e.key === 'Tab') {
                this.logFocusChange(e);
            }
        };
        
        this.interactiveFocusHandler = (e) => {
            this.logElementFocus(e.target);
        };
        
        document.addEventListener('keydown', this.interactiveKeyHandler);
        document.addEventListener('focus', this.interactiveFocusHandler, true);
    }

    /**
     * Remove event listeners for interactive testing
     */
    removeInteractiveTestListeners() {
        if (this.interactiveKeyHandler) {
            document.removeEventListener('keydown', this.interactiveKeyHandler);
        }
        if (this.interactiveFocusHandler) {
            document.removeEventListener('focus', this.interactiveFocusHandler, true);
        }
    }

    /**
     * Log focus changes during interactive testing
     */
    logFocusChange(event) {
        const direction = event.shiftKey ? 'backward' : 'forward';
        console.log(`🔄 Tab navigation (${direction})`);
    }

    /**
     * Log element focus during interactive testing
     */
    logElementFocus(element) {
        const description = this.getElementDescription(element);
        const rect = element.getBoundingClientRect();
        
        console.log(`🎯 Focus: ${description}`);
        console.log(`   Position: ${Math.round(rect.left)}, ${Math.round(rect.top)}`);
        console.log(`   Size: ${Math.round(rect.width)} x ${Math.round(rect.height)}`);
        
        // Check focus visibility
        const computedStyle = window.getComputedStyle(element);
        const hasFocusIndicator = this.checkFocusIndicator(computedStyle);
        
        if (!hasFocusIndicator) {
            console.warn('   ⚠️ No visible focus indicator detected');
        }
    }

    /**
     * Export keyboard test results
     */
    exportResults() {
        if (this.testResults.length === 0) {
            console.warn('No test results available. Run keyboard tests first.');
            return null;
        }
        
        const latestResults = this.testResults[this.testResults.length - 1];
        const dataStr = JSON.stringify(latestResults, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `keyboard-navigation-test-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        return latestResults;
    }
}

// Initialize keyboard navigation tester when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.keyboardNavigationTester = new KeyboardNavigationTester();
    
    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Ctrl+Alt+K for keyboard testing
        if (e.ctrlKey && e.altKey && e.key === 'k') {
            e.preventDefault();
            if (window.keyboardNavigationTester.isTestingActive) {
                window.keyboardNavigationTester.stopInteractiveTest();
            } else {
                window.keyboardNavigationTester.runKeyboardTests();
            }
        }
        
        // Ctrl+Alt+I for interactive testing
        if (e.ctrlKey && e.altKey && e.key === 'i') {
            e.preventDefault();
            window.keyboardNavigationTester.startInteractiveTest();
        }
    });
});

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = KeyboardNavigationTester;
}
/**
 * Screen Reader Compatibility Testing Suite
 * Tests for screen reader accessibility and ARIA implementation
 */

class ScreenReaderTester {
    constructor() {
        this.testResults = [];
        this.ariaRoles = [
            'alert', 'alertdialog', 'application', 'article', 'banner', 'button',
            'cell', 'checkbox', 'columnheader', 'combobox', 'complementary',
            'contentinfo', 'dialog', 'directory', 'document', 'feed', 'figure',
            'form', 'grid', 'gridcell', 'group', 'heading', 'img', 'link',
            'list', 'listbox', 'listitem', 'log', 'main', 'marquee', 'math',
            'menu', 'menubar', 'menuitem', 'menuitemcheckbox', 'menuitemradio',
            'navigation', 'none', 'note', 'option', 'presentation', 'progressbar',
            'radio', 'radiogroup', 'region', 'row', 'rowgroup', 'rowheader',
            'scrollbar', 'search', 'searchbox', 'separator', 'slider', 'spinbutton',
            'status', 'switch', 'tab', 'table', 'tablist', 'tabpanel', 'term',
            'textbox', 'timer', 'toolbar', 'tooltip', 'tree', 'treegrid',
            'treeitem'
        ];
        this.landmarkRoles = ['banner', 'complementary', 'contentinfo', 'form', 'main', 'navigation', 'region', 'search'];
    }

    /**
     * Run comprehensive screen reader compatibility tests
     */
    async runScreenReaderTests() {
        console.log('🔊 Starting screen reader compatibility tests...');
        
        const testResults = {
            timestamp: new Date().toISOString(),
            url: window.location.href,
            tests: {}
        };

        // Test 1: ARIA landmarks and structure
        testResults.tests.landmarks = await this.testLandmarks();
        
        // Test 2: ARIA labels and descriptions
        testResults.tests.ariaLabels = await this.testAriaLabels();
        
        // Test 3: ARIA live regions
        testResults.tests.liveRegions = await this.testLiveRegions();
        
        // Test 4: ARIA states and properties
        testResults.tests.ariaStates = await this.testAriaStates();
        
        // Test 5: Semantic HTML structure
        testResults.tests.semanticStructure = await this.testSemanticStructure();
        
        // Test 6: Form accessibility
        testResults.tests.formAccessibility = await this.testFormAccessibility();
        
        // Test 7: Table accessibility
        testResults.tests.tableAccessibility = await this.testTableAccessibility();
        
        // Test 8: Image accessibility
        testResults.tests.imageAccessibility = await this.testImageAccessibility();
        
        // Test 9: Link accessibility
        testResults.tests.linkAccessibility = await this.testLinkAccessibility();

        this.testResults.push(testResults);
        this.displayScreenReaderResults(testResults);
        
        return testResults;
    }

    /**
     * Test ARIA landmarks and page structure
     */
    async testLandmarks() {
        const test = {
            name: 'ARIA Landmarks and Page Structure',
            status: 'pass',
            issues: [],
            landmarksFound: {},
            totalLandmarks: 0
        };

        // Check for essential landmarks
        const essentialLandmarks = {
            main: 'main, [role="main"]',
            navigation: 'nav, [role="navigation"]',
            banner: 'header, [role="banner"]',
            contentinfo: 'footer, [role="contentinfo"]'
        };

        Object.entries(essentialLandmarks).forEach(([landmark, selector]) => {
            const elements = document.querySelectorAll(selector);
            test.landmarksFound[landmark] = elements.length;
            test.totalLandmarks += elements.length;

            if (elements.length === 0) {
                const severity = landmark === 'main' ? 'fail' : 'warning';
                if (test.status !== 'fail') test.status = severity;
                
                test.issues.push({
                    type: 'missing_landmark',
                    landmark: landmark,
                    severity: severity,
                    message: `Missing ${landmark} landmark`,
                    recommendation: `Add ${landmark === 'main' ? '<main>' : landmark === 'navigation' ? '<nav>' : landmark === 'banner' ? '<header>' : '<footer>'} element or role="${landmark}"`
                });
            } else if (elements.length > 1 && landmark !== 'navigation') {
                test.status = 'warning';
                test.issues.push({
                    type: 'multiple_landmarks',
                    landmark: landmark,
                    severity: 'warning',
                    message: `Multiple ${landmark} landmarks found (${elements.length})`,
                    recommendation: `Consider using only one ${landmark} landmark or add aria-label to distinguish them`
                });
            }
        });

        // Check for proper landmark labeling
        const labeledLandmarks = document.querySelectorAll('[role="region"], nav, aside, section');
        labeledLandmarks.forEach((element, index) => {
            const hasLabel = element.getAttribute('aria-label') || element.getAttribute('aria-labelledby');
            const role = element.getAttribute('role') || element.tagName.toLowerCase();
            
            if ((role === 'region' || element.tagName === 'SECTION') && !hasLabel) {
                test.status = 'warning';
                test.issues.push({
                    type: 'unlabeled_landmark',
                    element: this.getElementDescription(element),
                    severity: 'warning',
                    message: `${role} landmark missing accessible name`,
                    recommendation: 'Add aria-label or aria-labelledby to identify the purpose of this landmark'
                });
            }
        });

        return test;
    }

    /**
     * Test ARIA labels and descriptions
     */
    async testAriaLabels() {
        const test = {
            name: 'ARIA Labels and Descriptions',
            status: 'pass',
            issues: [],
            elementsChecked: 0,
            labelIssues: 0
        };

        // Check elements with aria-labelledby
        const labelledByElements = document.querySelectorAll('[aria-labelledby]');
        labelledByElements.forEach((element, index) => {
            test.elementsChecked++;
            const labelIds = element.getAttribute('aria-labelledby').split(' ');
            
            labelIds.forEach(labelId => {
                const labelElement = document.getElementById(labelId.trim());
                if (!labelElement) {
                    test.labelIssues++;
                    test.status = 'fail';
                    test.issues.push({
                        type: 'broken_labelledby',
                        element: this.getElementDescription(element),
                        severity: 'fail',
                        message: `aria-labelledby references non-existent ID: ${labelId}`,
                        recommendation: 'Ensure all IDs referenced by aria-labelledby exist'
                    });
                }
            });
        });

        // Check elements with aria-describedby
        const describedByElements = document.querySelectorAll('[aria-describedby]');
        describedByElements.forEach((element, index) => {
            test.elementsChecked++;
            const descriptionIds = element.getAttribute('aria-describedby').split(' ');
            
            descriptionIds.forEach(descId => {
                const descElement = document.getElementById(descId.trim());
                if (!descElement) {
                    test.labelIssues++;
                    test.status = 'fail';
                    test.issues.push({
                        type: 'broken_describedby',
                        element: this.getElementDescription(element),
                        severity: 'fail',
                        message: `aria-describedby references non-existent ID: ${descId}`,
                        recommendation: 'Ensure all IDs referenced by aria-describedby exist'
                    });
                }
            });
        });

        // Check interactive elements for accessible names
        const interactiveElements = document.querySelectorAll('button, a, input[type="button"], input[type="submit"], [role="button"], [role="link"]');
        interactiveElements.forEach((element, index) => {
            test.elementsChecked++;
            const hasAccessibleName = this.getAccessibleName(element);
            
            if (!hasAccessibleName) {
                test.labelIssues++;
                test.status = 'fail';
                test.issues.push({
                    type: 'missing_accessible_name',
                    element: this.getElementDescription(element),
                    severity: 'fail',
                    message: 'Interactive element missing accessible name',
                    recommendation: 'Add aria-label, aria-labelledby, or visible text content'
                });
            }
        });

        return test;
    }

    /**
     * Test ARIA live regions
     */
    async testLiveRegions() {
        const test = {
            name: 'ARIA Live Regions',
            status: 'pass',
            issues: [],
            liveRegionsFound: 0,
            recommendedRegions: 0
        };

        const liveRegions = document.querySelectorAll('[aria-live]');
        test.liveRegionsFound = liveRegions.length;

        // Check for recommended live regions
        const politeRegion = document.getElementById('aria-live-polite') || document.querySelector('[aria-live="polite"]');
        const assertiveRegion = document.getElementById('aria-live-assertive') || document.querySelector('[aria-live="assertive"]');

        if (politeRegion) test.recommendedRegions++;
        if (assertiveRegion) test.recommendedRegions++;

        if (!politeRegion) {
            test.status = 'warning';
            test.issues.push({
                type: 'missing_live_region',
                severity: 'warning',
                message: 'No polite live region found for status updates',
                recommendation: 'Add a polite live region for non-urgent announcements'
            });
        }

        if (!assertiveRegion) {
            test.status = 'warning';
            test.issues.push({
                type: 'missing_live_region',
                severity: 'warning',
                message: 'No assertive live region found for urgent announcements',
                recommendation: 'Add an assertive live region for urgent announcements'
            });
        }

        // Check live region implementation
        liveRegions.forEach((region, index) => {
            const ariaLive = region.getAttribute('aria-live');
            const ariaAtomic = region.getAttribute('aria-atomic');
            const ariaRelevant = region.getAttribute('aria-relevant');

            if (!['polite', 'assertive', 'off'].includes(ariaLive)) {
                test.status = 'warning';
                test.issues.push({
                    type: 'invalid_live_value',
                    element: this.getElementDescription(region),
                    severity: 'warning',
                    message: `Invalid aria-live value: ${ariaLive}`,
                    recommendation: 'Use "polite", "assertive", or "off" for aria-live'
                });
            }

            // Check if live region is properly positioned (usually off-screen)
            const rect = region.getBoundingClientRect();
            const style = window.getComputedStyle(region);
            
            if (rect.width > 1 && rect.height > 1 && style.position !== 'absolute' && style.position !== 'fixed') {
                test.status = 'warning';
                test.issues.push({
                    type: 'visible_live_region',
                    element: this.getElementDescription(region),
                    severity: 'warning',
                    message: 'Live region may be visible to sighted users',
                    recommendation: 'Consider positioning live regions off-screen for screen reader only announcements'
                });
            }
        });

        return test;
    }

    /**
     * Test ARIA states and properties
     */
    async testAriaStates() {
        const test = {
            name: 'ARIA States and Properties',
            status: 'pass',
            issues: [],
            elementsChecked: 0,
            stateIssues: 0
        };

        // Check expandable elements
        const expandableElements = document.querySelectorAll('[aria-expanded]');
        expandableElements.forEach((element, index) => {
            test.elementsChecked++;
            const expanded = element.getAttribute('aria-expanded');
            
            if (!['true', 'false'].includes(expanded)) {
                test.stateIssues++;
                test.status = 'fail';
                test.issues.push({
                    type: 'invalid_aria_expanded',
                    element: this.getElementDescription(element),
                    severity: 'fail',
                    message: `Invalid aria-expanded value: ${expanded}`,
                    recommendation: 'Use "true" or "false" for aria-expanded'
                });
            }
        });

        // Check checked elements
        const checkedElements = document.querySelectorAll('[aria-checked]');
        checkedElements.forEach((element, index) => {
            test.elementsChecked++;
            const checked = element.getAttribute('aria-checked');
            
            if (!['true', 'false', 'mixed'].includes(checked)) {
                test.stateIssues++;
                test.status = 'fail';
                test.issues.push({
                    type: 'invalid_aria_checked',
                    element: this.getElementDescription(element),
                    severity: 'fail',
                    message: `Invalid aria-checked value: ${checked}`,
                    recommendation: 'Use "true", "false", or "mixed" for aria-checked'
                });
            }
        });

        // Check disabled elements
        const disabledElements = document.querySelectorAll('[aria-disabled]');
        disabledElements.forEach((element, index) => {
            test.elementsChecked++;
            const disabled = element.getAttribute('aria-disabled');
            
            if (!['true', 'false'].includes(disabled)) {
                test.stateIssues++;
                test.status = 'fail';
                test.issues.push({
                    type: 'invalid_aria_disabled',
                    element: this.getElementDescription(element),
                    severity: 'fail',
                    message: `Invalid aria-disabled value: ${disabled}`,
                    recommendation: 'Use "true" or "false" for aria-disabled'
                });
            }
        });

        // Check hidden elements
        const hiddenElements = document.querySelectorAll('[aria-hidden]');
        hiddenElements.forEach((element, index) => {
            test.elementsChecked++;
            const hidden = element.getAttribute('aria-hidden');
            
            if (!['true', 'false'].includes(hidden)) {
                test.stateIssues++;
                test.status = 'fail';
                test.issues.push({
                    type: 'invalid_aria_hidden',
                    element: this.getElementDescription(element),
                    severity: 'fail',
                    message: `Invalid aria-hidden value: ${hidden}`,
                    recommendation: 'Use "true" or "false" for aria-hidden'
                });
            }

            // Check if focusable elements are hidden
            const focusableChildren = element.querySelectorAll('a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (hidden === 'true' && focusableChildren.length > 0) {
                test.stateIssues++;
                test.status = 'warning';
                test.issues.push({
                    type: 'hidden_focusable_content',
                    element: this.getElementDescription(element),
                    severity: 'warning',
                    message: 'Element with aria-hidden="true" contains focusable content',
                    recommendation: 'Remove focusable elements from aria-hidden containers or use different hiding method'
                });
            }
        });

        return test;
    }

    /**
     * Test semantic HTML structure
     */
    async testSemanticStructure() {
        const test = {
            name: 'Semantic HTML Structure',
            status: 'pass',
            issues: [],
            headingStructure: [],
            semanticElements: 0
        };

        // Check heading structure
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        let previousLevel = 0;
        
        headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            test.headingStructure.push({ level, text: heading.textContent.trim().substring(0, 50) });
            
            if (index === 0 && level !== 1) {
                test.status = 'warning';
                test.issues.push({
                    type: 'no_h1',
                    severity: 'warning',
                    message: 'Page does not start with h1 heading',
                    recommendation: 'Use h1 for the main page heading'
                });
            }
            
            if (level > previousLevel + 1) {
                test.status = 'warning';
                test.issues.push({
                    type: 'skipped_heading_level',
                    element: `${heading.tagName} (${heading.textContent.trim().substring(0, 30)})`,
                    severity: 'warning',
                    message: `Heading level skipped from h${previousLevel} to h${level}`,
                    recommendation: 'Use heading levels in sequential order'
                });
            }
            
            if (!heading.textContent.trim()) {
                test.status = 'fail';
                test.issues.push({
                    type: 'empty_heading',
                    element: heading.tagName,
                    severity: 'fail',
                    message: 'Empty heading found',
                    recommendation: 'Provide descriptive heading text'
                });
            }
            
            previousLevel = level;
        });

        // Check for semantic elements
        const semanticElements = document.querySelectorAll('main, nav, aside, section, article, header, footer');
        test.semanticElements = semanticElements.length;

        if (test.semanticElements === 0) {
            test.status = 'warning';
            test.issues.push({
                type: 'no_semantic_elements',
                severity: 'warning',
                message: 'No HTML5 semantic elements found',
                recommendation: 'Use semantic elements like main, nav, section, article for better structure'
            });
        }

        // Check for proper list structure
        const lists = document.querySelectorAll('ul, ol');
        lists.forEach((list, index) => {
            const listItems = list.children;
            let hasNonListItems = false;
            
            Array.from(listItems).forEach(child => {
                if (child.tagName !== 'LI') {
                    hasNonListItems = true;
                }
            });
            
            if (hasNonListItems) {
                test.status = 'warning';
                test.issues.push({
                    type: 'invalid_list_structure',
                    element: `${list.tagName} #${index + 1}`,
                    severity: 'warning',
                    message: 'List contains non-list-item children',
                    recommendation: 'Only use li elements as direct children of ul/ol'
                });
            }
        });

        return test;
    }

    /**
     * Test form accessibility
     */
    async testFormAccessibility() {
        const test = {
            name: 'Form Accessibility',
            status: 'pass',
            issues: [],
            formsFound: 0,
            inputsChecked: 0,
            labelIssues: 0
        };

        const forms = document.querySelectorAll('form');
        test.formsFound = forms.length;

        forms.forEach((form, formIndex) => {
            // Check form has accessible name
            const formName = form.getAttribute('aria-label') || 
                           form.getAttribute('aria-labelledby') ||
                           form.querySelector('legend, h1, h2, h3, h4, h5, h6');
            
            if (!formName && forms.length > 1) {
                test.status = 'warning';
                test.issues.push({
                    type: 'unlabeled_form',
                    element: `Form #${formIndex + 1}`,
                    severity: 'warning',
                    message: 'Form missing accessible name',
                    recommendation: 'Add aria-label or associate with heading'
                });
            }

            // Check form inputs
            const inputs = form.querySelectorAll('input:not([type="hidden"]), select, textarea');
            inputs.forEach((input, inputIndex) => {
                test.inputsChecked++;
                
                const hasLabel = this.hasFormLabel(input);
                if (!hasLabel) {
                    test.labelIssues++;
                    test.status = 'fail';
                    test.issues.push({
                        type: 'missing_form_label',
                        element: this.getElementDescription(input),
                        severity: 'fail',
                        message: 'Form input missing label',
                        recommendation: 'Associate input with label using for/id or aria-labelledby'
                    });
                }

                // Check required field indication
                if (input.hasAttribute('required')) {
                    const hasRequiredIndicator = input.getAttribute('aria-required') === 'true' ||
                                               input.getAttribute('aria-describedby') ||
                                               this.hasRequiredIndicator(input);
                    
                    if (!hasRequiredIndicator) {
                        test.status = 'warning';
                        test.issues.push({
                            type: 'missing_required_indicator',
                            element: this.getElementDescription(input),
                            severity: 'warning',
                            message: 'Required field not clearly indicated',
                            recommendation: 'Add aria-required="true" or visual indicator for required fields'
                        });
                    }
                }
            });
        });

        return test;
    }

    /**
     * Test table accessibility
     */
    async testTableAccessibility() {
        const test = {
            name: 'Table Accessibility',
            status: 'pass',
            issues: [],
            tablesFound: 0,
            dataTablesFound: 0
        };

        const tables = document.querySelectorAll('table');
        test.tablesFound = tables.length;

        tables.forEach((table, index) => {
            const rows = table.querySelectorAll('tr');
            const headers = table.querySelectorAll('th');
            const cells = table.querySelectorAll('td');

            if (cells.length > 0) {
                test.dataTablesFound++;

                // Check for caption or accessible name
                const hasCaption = table.querySelector('caption') || 
                                 table.getAttribute('aria-label') ||
                                 table.getAttribute('aria-labelledby');
                
                if (!hasCaption) {
                    test.status = 'warning';
                    test.issues.push({
                        type: 'missing_table_caption',
                        element: `Table #${index + 1}`,
                        severity: 'warning',
                        message: 'Table missing caption or accessible name',
                        recommendation: 'Add caption element or aria-label to describe table purpose'
                    });
                }

                // Check for headers
                if (headers.length === 0) {
                    test.status = 'fail';
                    test.issues.push({
                        type: 'missing_table_headers',
                        element: `Table #${index + 1}`,
                        severity: 'fail',
                        message: 'Data table missing header cells',
                        recommendation: 'Use th elements for table headers'
                    });
                }

                // Check header scope attributes
                headers.forEach((header, headerIndex) => {
                    if (!header.getAttribute('scope') && !header.getAttribute('id')) {
                        test.status = 'warning';
                        test.issues.push({
                            type: 'missing_header_scope',
                            element: `Table #${index + 1}, Header #${headerIndex + 1}`,
                            severity: 'warning',
                            message: 'Table header missing scope attribute',
                            recommendation: 'Add scope="col" or scope="row" to table headers'
                        });
                    }
                });

                // Check for complex table structure
                const hasRowspan = table.querySelector('[rowspan]');
                const hasColspan = table.querySelector('[colspan]');
                
                if ((hasRowspan || hasColspan) && !table.querySelector('[headers]')) {
                    test.status = 'warning';
                    test.issues.push({
                        type: 'complex_table_structure',
                        element: `Table #${index + 1}`,
                        severity: 'warning',
                        message: 'Complex table may need headers attribute for cell associations',
                        recommendation: 'Use headers attribute to associate cells with headers in complex tables'
                    });
                }
            }
        });

        return test;
    }

    /**
     * Test image accessibility
     */
    async testImageAccessibility() {
        const test = {
            name: 'Image Accessibility',
            status: 'pass',
            issues: [],
            imagesFound: 0,
            decorativeImages: 0,
            missingAlt: 0
        };

        const images = document.querySelectorAll('img');
        test.imagesFound = images.length;

        images.forEach((img, index) => {
            const hasAlt = img.hasAttribute('alt');
            const altText = img.getAttribute('alt');
            const isDecorative = altText === '' || img.getAttribute('role') === 'presentation';
            
            if (isDecorative) {
                test.decorativeImages++;
            }

            if (!hasAlt) {
                test.missingAlt++;
                test.status = 'fail';
                test.issues.push({
                    type: 'missing_alt_attribute',
                    element: `Image #${index + 1} (${img.src ? img.src.split('/').pop() : 'no src'})`,
                    severity: 'fail',
                    message: 'Image missing alt attribute',
                    recommendation: 'Add alt attribute (empty for decorative images, descriptive for informative images)'
                });
            } else if (altText && altText.length > 125) {
                test.status = 'warning';
                test.issues.push({
                    type: 'long_alt_text',
                    element: `Image #${index + 1}`,
                    severity: 'warning',
                    message: 'Alt text is very long (>125 characters)',
                    recommendation: 'Consider using shorter alt text and longdesc or aria-describedby for detailed descriptions'
                });
            }

            // Check for redundant alt text
            if (altText && (altText.toLowerCase().includes('image of') || altText.toLowerCase().includes('picture of'))) {
                test.status = 'warning';
                test.issues.push({
                    type: 'redundant_alt_text',
                    element: `Image #${index + 1}`,
                    severity: 'warning',
                    message: 'Alt text contains redundant phrases',
                    recommendation: 'Remove phrases like "image of" or "picture of" from alt text'
                });
            }
        });

        return test;
    }

    /**
     * Test link accessibility
     */
    async testLinkAccessibility() {
        const test = {
            name: 'Link Accessibility',
            status: 'pass',
            issues: [],
            linksFound: 0,
            ambiguousLinks: 0,
            emptyLinks: 0
        };

        const links = document.querySelectorAll('a[href]');
        test.linksFound = links.length;

        const linkTexts = new Map();

        links.forEach((link, index) => {
            const linkText = this.getAccessibleName(link);
            
            if (!linkText) {
                test.emptyLinks++;
                test.status = 'fail';
                test.issues.push({
                    type: 'empty_link',
                    element: `Link #${index + 1} (${link.href})`,
                    severity: 'fail',
                    message: 'Link has no accessible text',
                    recommendation: 'Add visible text, aria-label, or alt text for image links'
                });
            } else {
                // Check for ambiguous link text
                const ambiguousTexts = ['click here', 'read more', 'more', 'here', 'link', 'continue'];
                if (ambiguousTexts.some(text => linkText.toLowerCase().includes(text))) {
                    test.ambiguousLinks++;
                    test.status = 'warning';
                    test.issues.push({
                        type: 'ambiguous_link_text',
                        element: `Link #${index + 1}: "${linkText}"`,
                        severity: 'warning',
                        message: 'Link text may be ambiguous out of context',
                        recommendation: 'Use descriptive link text that makes sense when read alone'
                    });
                }

                // Track duplicate link texts
                if (linkTexts.has(linkText)) {
                    linkTexts.set(linkText, linkTexts.get(linkText) + 1);
                } else {
                    linkTexts.set(linkText, 1);
                }
            }

            // Check for new window links
            const opensNewWindow = link.target === '_blank' || 
                                 link.getAttribute('onclick')?.includes('window.open');
            
            if (opensNewWindow) {
                const hasWarning = link.getAttribute('aria-describedby') ||
                                 linkText.includes('opens in new window') ||
                                 linkText.includes('external link');
                
                if (!hasWarning) {
                    test.status = 'warning';
                    test.issues.push({
                        type: 'new_window_no_warning',
                        element: `Link #${index + 1}: "${linkText}"`,
                        severity: 'warning',
                        message: 'Link opens new window without warning',
                        recommendation: 'Indicate that link opens in new window (aria-describedby or text)'
                    });
                }
            }
        });

        // Report duplicate link texts with different destinations
        linkTexts.forEach((count, text) => {
            if (count > 1) {
                const linksWithSameText = Array.from(links).filter(link => 
                    this.getAccessibleName(link) === text
                );
                
                const uniqueDestinations = new Set(linksWithSameText.map(link => link.href));
                
                if (uniqueDestinations.size > 1) {
                    test.status = 'warning';
                    test.issues.push({
                        type: 'duplicate_link_text',
                        element: `"${text}" (${count} links)`,
                        severity: 'warning',
                        message: 'Multiple links with same text but different destinations',
                        recommendation: 'Make link text more specific or add aria-describedby to distinguish links'
                    });
                }
            }
        });

        return test;
    }

    /**
     * Get accessible name for an element
     */
    getAccessibleName(element) {
        // Check aria-label
        const ariaLabel = element.getAttribute('aria-label');
        if (ariaLabel) return ariaLabel.trim();

        // Check aria-labelledby
        const ariaLabelledby = element.getAttribute('aria-labelledby');
        if (ariaLabelledby) {
            const labelElements = ariaLabelledby.split(' ')
                .map(id => document.getElementById(id.trim()))
                .filter(el => el);
            
            if (labelElements.length > 0) {
                return labelElements.map(el => el.textContent).join(' ').trim();
            }
        }

        // Check visible text content
        const textContent = element.textContent?.trim();
        if (textContent) return textContent;

        // Check for image alt text (for image links)
        const img = element.querySelector('img');
        if (img && img.alt) return img.alt.trim();

        // Check title attribute (last resort)
        const title = element.getAttribute('title');
        if (title) return title.trim();

        return '';
    }

    /**
     * Check if form input has proper label
     */
    hasFormLabel(input) {
        // Check for aria-label
        if (input.getAttribute('aria-label')) return true;

        // Check for aria-labelledby
        if (input.getAttribute('aria-labelledby')) return true;

        // Check for associated label
        if (input.id) {
            const label = document.querySelector(`label[for="${input.id}"]`);
            if (label) return true;
        }

        // Check for wrapping label
        const parentLabel = input.closest('label');
        if (parentLabel) return true;

        // Check for placeholder (not ideal but sometimes used)
        if (input.getAttribute('placeholder')) return true;

        return false;
    }

    /**
     * Check if input has required field indicator
     */
    hasRequiredIndicator(input) {
        const label = document.querySelector(`label[for="${input.id}"]`) || input.closest('label');
        if (label && (label.textContent.includes('*') || label.textContent.includes('required'))) {
            return true;
        }

        const describedBy = input.getAttribute('aria-describedby');
        if (describedBy) {
            const description = document.getElementById(describedBy);
            if (description && description.textContent.toLowerCase().includes('required')) {
                return true;
            }
        }

        return false;
    }

    /**
     * Get element description for reporting
     */
    getElementDescription(element) {
        let description = element.tagName.toLowerCase();
        
        if (element.id) {
            description += `#${element.id}`;
        }
        
        if (element.className) {
            const classes = element.className.split(' ').filter(c => c.trim()).slice(0, 2);
            if (classes.length > 0) {
                description += `.${classes.join('.')}`;
            }
        }
        
        const text = element.textContent?.trim();
        if (text && text.length > 0) {
            const shortText = text.substring(0, 30);
            description += ` ("${shortText}${text.length > 30 ? '...' : ''}")`;
        }
        
        return description;
    }

    /**
     * Display screen reader test results
     */
    displayScreenReaderResults(results) {
        console.group('🔊 Screen Reader Compatibility Test Results');
        console.log('Timestamp:', results.timestamp);
        console.log('URL:', results.url);
        
        Object.entries(results.tests).forEach(([testName, testResult]) => {
            const status = testResult.status === 'pass' ? '✅' : 
                          testResult.status === 'warning' ? '⚠️' : '❌';
            
            console.group(`${status} ${testResult.name}`);
            console.log('Status:', testResult.status);
            
            // Display test-specific metrics
            if (testResult.landmarksFound) {
                console.log('Landmarks found:', testResult.landmarksFound);
            }
            if (testResult.elementsChecked !== undefined) {
                console.log('Elements checked:', testResult.elementsChecked);
            }
            if (testResult.liveRegionsFound !== undefined) {
                console.log('Live regions found:', testResult.liveRegionsFound);
            }
            
            if (testResult.issues.length > 0) {
                console.group(`Issues Found (${testResult.issues.length})`);
                testResult.issues.forEach(issue => {
                    const severity = issue.severity === 'fail' ? '❌' : '⚠️';
                    console.group(`${severity} ${issue.type || 'Issue'}`);
                    if (issue.element) console.log('Element:', issue.element);
                    console.log('Message:', issue.message);
                    console.log('Recommendation:', issue.recommendation);
                    console.groupEnd();
                });
                console.groupEnd();
            }
            
            console.groupEnd();
        });
        
        console.groupEnd();
        
        // Summary
        const totalTests = Object.keys(results.tests).length;
        const passedTests = Object.values(results.tests).filter(test => test.status === 'pass').length;
        const failedTests = Object.values(results.tests).filter(test => test.status === 'fail').length;
        
        console.log(`📊 Screen Reader Compatibility Summary: ${passedTests}/${totalTests} tests passed`);
        if (failedTests > 0) {
            console.warn(`⚠️ ${failedTests} critical screen reader compatibility issues found`);
        }
    }

    /**
     * Export screen reader test results
     */
    exportResults() {
        if (this.testResults.length === 0) {
            console.warn('No test results available. Run screen reader tests first.');
            return null;
        }
        
        const latestResults = this.testResults[this.testResults.length - 1];
        const dataStr = JSON.stringify(latestResults, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `screen-reader-test-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        return latestResults;
    }
}

// Initialize screen reader tester when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.screenReaderTester = new ScreenReaderTester();
    
    // Add keyboard shortcut for screen reader testing (Ctrl+Alt+S)
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.altKey && e.key === 's') {
            e.preventDefault();
            window.screenReaderTester.runScreenReaderTests();
        }
    });
});

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ScreenReaderTester;
}
/**
 * Accessibility Testing Suite
 * Automated accessibility testing with axe-core and manual testing helpers
 */

class AccessibilityTesting {
    constructor() {
        this.testResults = [];
        this.isAxeLoaded = false;
        this.loadAxeCore();
    }

    /**
     * Load axe-core library for automated testing
     */
    async loadAxeCore() {
        try {
            // Check if axe is already loaded
            if (typeof axe !== 'undefined') {
                this.isAxeLoaded = true;
                return;
            }

            // Load axe-core from CDN
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/axe-core@4.8.2/axe.min.js';
            script.onload = () => {
                this.isAxeLoaded = true;
                console.log('axe-core loaded successfully');
            };
            script.onerror = () => {
                console.warn('Failed to load axe-core from CDN');
                this.isAxeLoaded = false;
            };
            document.head.appendChild(script);
        } catch (error) {
            console.error('Error loading axe-core:', error);
            this.isAxeLoaded = false;
        }
    }

    /**
     * Run comprehensive accessibility audit
     */
    async runFullAudit() {
        console.log('🔍 Starting comprehensive accessibility audit...');
        
        const results = {
            timestamp: new Date().toISOString(),
            url: window.location.href,
            userAgent: navigator.userAgent,
            tests: {}
        };

        // Run automated tests with axe-core
        if (this.isAxeLoaded && typeof axe !== 'undefined') {
            results.tests.automated = await this.runAxeTests();
        } else {
            results.tests.automated = { error: 'axe-core not available' };
        }

        // Run manual validation tests
        results.tests.manual = this.runManualTests();
        
        // Run keyboard navigation tests
        results.tests.keyboard = this.testKeyboardNavigation();
        
        // Run color contrast tests
        results.tests.colorContrast = this.testColorContrast();
        
        // Run screen reader compatibility tests
        results.tests.screenReader = this.testScreenReaderCompatibility();

        this.testResults.push(results);
        this.displayResults(results);
        
        return results;
    }

    /**
     * Run automated accessibility tests using axe-core
     */
    async runAxeTests() {
        if (!this.isAxeLoaded || typeof axe === 'undefined') {
            return { error: 'axe-core not loaded' };
        }

        try {
            const results = await axe.run(document, {
                rules: {
                    // Enable all rules
                    'color-contrast': { enabled: true },
                    'keyboard-navigation': { enabled: true },
                    'focus-order-semantics': { enabled: true },
                    'aria-valid-attr': { enabled: true },
                    'aria-valid-attr-value': { enabled: true },
                    'aria-labelledby': { enabled: true },
                    'aria-describedby': { enabled: true },
                    'button-name': { enabled: true },
                    'form-field-multiple-labels': { enabled: true },
                    'heading-order': { enabled: true },
                    'image-alt': { enabled: true },
                    'input-image-alt': { enabled: true },
                    'label': { enabled: true },
                    'link-name': { enabled: true },
                    'list': { enabled: true },
                    'listitem': { enabled: true },
                    'meta-viewport': { enabled: true },
                    'region': { enabled: true },
                    'skip-link': { enabled: true },
                    'tabindex': { enabled: true }
                }
            });

            return {
                violations: results.violations.map(violation => ({
                    id: violation.id,
                    impact: violation.impact,
                    description: violation.description,
                    help: violation.help,
                    helpUrl: violation.helpUrl,
                    nodes: violation.nodes.length,
                    elements: violation.nodes.map(node => ({
                        target: node.target,
                        html: node.html.substring(0, 200) + (node.html.length > 200 ? '...' : ''),
                        failureSummary: node.failureSummary
                    }))
                })),
                passes: results.passes.length,
                incomplete: results.incomplete.length,
                inapplicable: results.inapplicable.length
            };
        } catch (error) {
            return { error: error.message };
        }
    }

    /**
     * Run manual accessibility validation tests
     */
    runManualTests() {
        const tests = [];

        // Test 1: Check for missing alt text on images
        tests.push(this.testImageAltText());
        
        // Test 2: Check form labels
        tests.push(this.testFormLabels());
        
        // Test 3: Check heading structure
        tests.push(this.testHeadingStructure());
        
        // Test 4: Check ARIA attributes
        tests.push(this.testAriaAttributes());
        
        // Test 5: Check semantic HTML
        tests.push(this.testSemanticHTML());
        
        // Test 6: Check focus indicators
        tests.push(this.testFocusIndicators());

        return tests;
    }

    /**
     * Test image alt text
     */
    testImageAltText() {
        const images = document.querySelectorAll('img');
        const issues = [];
        
        images.forEach((img, index) => {
            if (!img.alt && !img.getAttribute('aria-label') && !img.getAttribute('aria-labelledby')) {
                // Check if image is decorative
                if (!img.getAttribute('role') || img.getAttribute('role') !== 'presentation') {
                    issues.push({
                        element: img,
                        message: `Image ${index + 1} missing alt text`,
                        severity: 'error'
                    });
                }
            }
        });

        return {
            name: 'Image Alt Text',
            passed: issues.length === 0,
            issues: issues,
            total: images.length
        };
    }

    /**
     * Test form labels
     */
    testFormLabels() {
        const inputs = document.querySelectorAll('input, select, textarea');
        const issues = [];
        
        inputs.forEach((input, index) => {
            const hasLabel = input.getAttribute('aria-label') || 
                           input.getAttribute('aria-labelledby') || 
                           document.querySelector(`label[for="${input.id}"]`);
            
            if (!hasLabel && input.type !== 'hidden' && input.type !== 'submit' && input.type !== 'button') {
                issues.push({
                    element: input,
                    message: `Form input ${index + 1} missing label`,
                    severity: 'error'
                });
            }
        });

        return {
            name: 'Form Labels',
            passed: issues.length === 0,
            issues: issues,
            total: inputs.length
        };
    }

    /**
     * Test heading structure
     */
    testHeadingStructure() {
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        const issues = [];
        let previousLevel = 0;
        
        headings.forEach((heading, index) => {
            const level = parseInt(heading.tagName.charAt(1));
            
            if (level > previousLevel + 1) {
                issues.push({
                    element: heading,
                    message: `Heading level skipped at heading ${index + 1} (${heading.tagName})`,
                    severity: 'warning'
                });
            }
            
            previousLevel = level;
        });

        return {
            name: 'Heading Structure',
            passed: issues.length === 0,
            issues: issues,
            total: headings.length
        };
    }

    /**
     * Test ARIA attributes
     */
    testAriaAttributes() {
        const elementsWithAria = document.querySelectorAll('[aria-labelledby], [aria-describedby]');
        const issues = [];
        
        elementsWithAria.forEach((element, index) => {
            const labelledBy = element.getAttribute('aria-labelledby');
            const describedBy = element.getAttribute('aria-describedby');
            
            if (labelledBy && !document.getElementById(labelledBy)) {
                issues.push({
                    element: element,
                    message: `Element ${index + 1} references non-existent aria-labelledby ID: ${labelledBy}`,
                    severity: 'error'
                });
            }
            
            if (describedBy && !document.getElementById(describedBy)) {
                issues.push({
                    element: element,
                    message: `Element ${index + 1} references non-existent aria-describedby ID: ${describedBy}`,
                    severity: 'error'
                });
            }
        });

        return {
            name: 'ARIA Attributes',
            passed: issues.length === 0,
            issues: issues,
            total: elementsWithAria.length
        };
    }

    /**
     * Test semantic HTML
     */
    testSemanticHTML() {
        const issues = [];
        
        // Check for main landmark
        const main = document.querySelector('main, [role="main"]');
        if (!main) {
            issues.push({
                element: document.body,
                message: 'Page missing main landmark',
                severity: 'error'
            });
        }
        
        // Check for navigation landmarks
        const nav = document.querySelector('nav, [role="navigation"]');
        if (!nav) {
            issues.push({
                element: document.body,
                message: 'Page missing navigation landmark',
                severity: 'warning'
            });
        }
        
        // Check for proper button usage
        const divButtons = document.querySelectorAll('div[onclick], span[onclick]');
        divButtons.forEach((element, index) => {
            if (!element.getAttribute('role') || element.getAttribute('role') !== 'button') {
                issues.push({
                    element: element,
                    message: `Element ${index + 1} acts as button but lacks proper semantics`,
                    severity: 'warning'
                });
            }
        });

        return {
            name: 'Semantic HTML',
            passed: issues.length === 0,
            issues: issues,
            total: divButtons.length + 2 // +2 for main and nav checks
        };
    }

    /**
     * Test focus indicators
     */
    testFocusIndicators() {
        const focusableElements = document.querySelectorAll('a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
        const issues = [];
        
        // This is a simplified test - in practice, you'd need to actually focus elements and check computed styles
        focusableElements.forEach((element, index) => {
            const computedStyle = window.getComputedStyle(element, ':focus');
            const hasOutline = computedStyle.outline !== 'none' && computedStyle.outline !== '0px';
            const hasBoxShadow = computedStyle.boxShadow !== 'none';
            
            if (!hasOutline && !hasBoxShadow) {
                // This is a basic check - more sophisticated testing would be needed
                issues.push({
                    element: element,
                    message: `Element ${index + 1} may lack visible focus indicator`,
                    severity: 'warning'
                });
            }
        });

        return {
            name: 'Focus Indicators',
            passed: issues.length === 0,
            issues: issues,
            total: focusableElements.length
        };
    }

    /**
     * Test keyboard navigation
     */
    testKeyboardNavigation() {
        const tests = [];
        
        // Test tab order
        tests.push(this.testTabOrder());
        
        // Test keyboard traps
        tests.push(this.testKeyboardTraps());
        
        // Test skip links
        tests.push(this.testSkipLinks());

        return tests;
    }

    /**
     * Test tab order
     */
    testTabOrder() {
        const focusableElements = Array.from(document.querySelectorAll(
            'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        ));
        
        const issues = [];
        let previousTabIndex = -1;
        
        focusableElements.forEach((element, index) => {
            const tabIndex = parseInt(element.getAttribute('tabindex')) || 0;
            
            if (tabIndex > 0 && tabIndex < previousTabIndex) {
                issues.push({
                    element: element,
                    message: `Element ${index + 1} has out-of-order tabindex: ${tabIndex}`,
                    severity: 'warning'
                });
            }
            
            if (tabIndex > 0) {
                previousTabIndex = tabIndex;
            }
        });

        return {
            name: 'Tab Order',
            passed: issues.length === 0,
            issues: issues,
            total: focusableElements.length
        };
    }

    /**
     * Test keyboard traps
     */
    testKeyboardTraps() {
        const modals = document.querySelectorAll('.modal, [role="dialog"]');
        const issues = [];
        
        modals.forEach((modal, index) => {
            const focusableElements = modal.querySelectorAll('a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
            
            if (focusableElements.length === 0) {
                issues.push({
                    element: modal,
                    message: `Modal ${index + 1} has no focusable elements`,
                    severity: 'error'
                });
            }
        });

        return {
            name: 'Keyboard Traps',
            passed: issues.length === 0,
            issues: issues,
            total: modals.length
        };
    }

    /**
     * Test skip links
     */
    testSkipLinks() {
        const skipLinks = document.querySelectorAll('.skip-link, a[href^="#"]:first-child');
        const issues = [];
        
        if (skipLinks.length === 0) {
            issues.push({
                element: document.body,
                message: 'Page missing skip links for keyboard navigation',
                severity: 'warning'
            });
        }

        return {
            name: 'Skip Links',
            passed: issues.length === 0,
            issues: issues,
            total: skipLinks.length
        };
    }

    /**
     * Test color contrast
     */
    testColorContrast() {
        const textElements = document.querySelectorAll('p, span, div, a, button, h1, h2, h3, h4, h5, h6, label, li');
        const issues = [];
        
        textElements.forEach((element, index) => {
            const computedStyle = window.getComputedStyle(element);
            const color = computedStyle.color;
            const backgroundColor = computedStyle.backgroundColor;
            
            // This is a simplified check - proper contrast testing requires more sophisticated color analysis
            if (color === backgroundColor) {
                issues.push({
                    element: element,
                    message: `Element ${index + 1} may have insufficient color contrast`,
                    severity: 'warning'
                });
            }
        });

        return [{
            name: 'Color Contrast',
            passed: issues.length === 0,
            issues: issues,
            total: textElements.length
        }];
    }

    /**
     * Test screen reader compatibility
     */
    testScreenReaderCompatibility() {
        const tests = [];
        
        // Test ARIA live regions
        tests.push(this.testAriaLiveRegions());
        
        // Test landmark regions
        tests.push(this.testLandmarkRegions());
        
        // Test table accessibility
        tests.push(this.testTableAccessibility());

        return tests;
    }

    /**
     * Test ARIA live regions
     */
    testAriaLiveRegions() {
        const liveRegions = document.querySelectorAll('[aria-live]');
        const issues = [];
        
        // Check if essential live regions exist
        const politeRegion = document.getElementById('aria-live-polite');
        const assertiveRegion = document.getElementById('aria-live-assertive');
        
        if (!politeRegion) {
            issues.push({
                element: document.body,
                message: 'Missing polite ARIA live region for announcements',
                severity: 'warning'
            });
        }
        
        if (!assertiveRegion) {
            issues.push({
                element: document.body,
                message: 'Missing assertive ARIA live region for urgent announcements',
                severity: 'warning'
            });
        }

        return {
            name: 'ARIA Live Regions',
            passed: issues.length === 0,
            issues: issues,
            total: liveRegions.length + 2
        };
    }

    /**
     * Test landmark regions
     */
    testLandmarkRegions() {
        const landmarks = {
            main: document.querySelector('main, [role="main"]'),
            navigation: document.querySelector('nav, [role="navigation"]'),
            banner: document.querySelector('header, [role="banner"]'),
            contentinfo: document.querySelector('footer, [role="contentinfo"]')
        };
        
        const issues = [];
        
        Object.entries(landmarks).forEach(([landmark, element]) => {
            if (!element) {
                issues.push({
                    element: document.body,
                    message: `Missing ${landmark} landmark`,
                    severity: landmark === 'main' ? 'error' : 'warning'
                });
            }
        });

        return {
            name: 'Landmark Regions',
            passed: issues.length === 0,
            issues: issues,
            total: Object.keys(landmarks).length
        };
    }

    /**
     * Test table accessibility
     */
    testTableAccessibility() {
        const tables = document.querySelectorAll('table');
        const issues = [];
        
        tables.forEach((table, index) => {
            // Check for caption or aria-label
            const hasCaption = table.querySelector('caption') || table.getAttribute('aria-label');
            if (!hasCaption) {
                issues.push({
                    element: table,
                    message: `Table ${index + 1} missing caption or aria-label`,
                    severity: 'warning'
                });
            }
            
            // Check for proper header structure
            const headers = table.querySelectorAll('th');
            headers.forEach((header, headerIndex) => {
                if (!header.getAttribute('scope')) {
                    issues.push({
                        element: header,
                        message: `Table ${index + 1} header ${headerIndex + 1} missing scope attribute`,
                        severity: 'warning'
                    });
                }
            });
        });

        return {
            name: 'Table Accessibility',
            passed: issues.length === 0,
            issues: issues,
            total: tables.length
        };
    }

    /**
     * Display test results in console and optionally in UI
     */
    displayResults(results) {
        console.group('🔍 Accessibility Audit Results');
        console.log('Timestamp:', results.timestamp);
        console.log('URL:', results.url);
        
        // Display automated test results
        if (results.tests.automated && !results.tests.automated.error) {
            console.group('🤖 Automated Tests (axe-core)');
            console.log('Violations:', results.tests.automated.violations.length);
            console.log('Passes:', results.tests.automated.passes);
            console.log('Incomplete:', results.tests.automated.incomplete);
            
            if (results.tests.automated.violations.length > 0) {
                console.group('❌ Violations');
                results.tests.automated.violations.forEach(violation => {
                    console.group(`${violation.impact?.toUpperCase() || 'UNKNOWN'}: ${violation.id}`);
                    console.log('Description:', violation.description);
                    console.log('Help:', violation.help);
                    console.log('Elements affected:', violation.nodes);
                    console.log('More info:', violation.helpUrl);
                    console.groupEnd();
                });
                console.groupEnd();
            }
            console.groupEnd();
        }
        
        // Display manual test results
        console.group('👤 Manual Tests');
        results.tests.manual.forEach(test => {
            const status = test.passed ? '✅' : '❌';
            console.group(`${status} ${test.name}`);
            console.log('Passed:', test.passed);
            console.log('Total elements checked:', test.total);
            if (test.issues.length > 0) {
                console.log('Issues found:', test.issues.length);
                test.issues.forEach(issue => {
                    console.log(`${issue.severity?.toUpperCase()}: ${issue.message}`);
                });
            }
            console.groupEnd();
        });
        console.groupEnd();
        
        // Display keyboard navigation results
        console.group('⌨️ Keyboard Navigation Tests');
        results.tests.keyboard.forEach(test => {
            const status = test.passed ? '✅' : '❌';
            console.group(`${status} ${test.name}`);
            console.log('Passed:', test.passed);
            if (test.issues.length > 0) {
                test.issues.forEach(issue => {
                    console.log(`${issue.severity?.toUpperCase()}: ${issue.message}`);
                });
            }
            console.groupEnd();
        });
        console.groupEnd();
        
        console.groupEnd();
        
        // Create summary
        const totalViolations = (results.tests.automated?.violations?.length || 0) +
                              results.tests.manual.reduce((sum, test) => sum + test.issues.length, 0) +
                              results.tests.keyboard.reduce((sum, test) => sum + test.issues.length, 0);
        
        if (totalViolations === 0) {
            console.log('🎉 No accessibility issues found!');
        } else {
            console.warn(`⚠️ Found ${totalViolations} accessibility issues that need attention.`);
        }
    }

    /**
     * Generate accessibility report
     */
    generateReport() {
        if (this.testResults.length === 0) {
            console.warn('No test results available. Run an audit first.');
            return null;
        }
        
        const latestResults = this.testResults[this.testResults.length - 1];
        
        const report = {
            summary: {
                timestamp: latestResults.timestamp,
                url: latestResults.url,
                totalIssues: 0,
                criticalIssues: 0,
                warningIssues: 0
            },
            details: latestResults.tests
        };
        
        // Calculate issue counts
        if (latestResults.tests.automated && latestResults.tests.automated.violations) {
            latestResults.tests.automated.violations.forEach(violation => {
                report.summary.totalIssues++;
                if (violation.impact === 'critical' || violation.impact === 'serious') {
                    report.summary.criticalIssues++;
                } else {
                    report.summary.warningIssues++;
                }
            });
        }
        
        latestResults.tests.manual.forEach(test => {
            test.issues.forEach(issue => {
                report.summary.totalIssues++;
                if (issue.severity === 'error') {
                    report.summary.criticalIssues++;
                } else {
                    report.summary.warningIssues++;
                }
            });
        });
        
        return report;
    }

    /**
     * Export results as JSON
     */
    exportResults() {
        const report = this.generateReport();
        if (!report) return;
        
        const dataStr = JSON.stringify(report, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `accessibility-report-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
    }
}

// Initialize accessibility testing when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.accessibilityTesting = new AccessibilityTesting();
    
    // Add keyboard shortcut for quick testing (Ctrl+Alt+A)
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.altKey && e.key === 'a') {
            e.preventDefault();
            window.accessibilityTesting.runFullAudit();
        }
    });
});

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AccessibilityTesting;
}