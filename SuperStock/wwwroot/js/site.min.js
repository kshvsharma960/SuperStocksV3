/**
 * Lottie Animation Manager
 * Handles loading states, success/error feedback, and empty state animations
 */
class LottieManager {
    constructor() {
        this.animations = new Map();
        this.animationPaths = {
            loading: '/assets/lottie/loading.json',
            success: '/assets/lottie/success.json',
            error: '/assets/lottie/error.json',
            emptyState: '/assets/lottie/empty-state.json'
        };
    }

    /**
     * Create and play a loading animation
     * @param {HTMLElement|string} container - Container element or selector
     * @param {Object} options - Animation options
     */
    showLoading(container, options = {}) {
        const element = typeof container === 'string' ? document.querySelector(container) : container;
        if (!element) return null;

        // Clear existing content
        element.innerHTML = '';
        
        // Create animation container
        const animationContainer = document.createElement('div');
        animationContainer.className = 'lottie-loading-container';
        animationContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: ${options.minHeight || '100px'};
            padding: 20px;
        `;

        // Create Lottie container
        const lottieContainer = document.createElement('div');
        lottieContainer.className = 'lottie-animation';
        lottieContainer.style.cssText = `
            width: ${options.width || '60px'};
            height: ${options.height || '60px'};
        `;

        animationContainer.appendChild(lottieContainer);

        // Add loading text if provided
        if (options.text) {
            const textElement = document.createElement('div');
            textElement.className = 'lottie-text';
            textElement.textContent = options.text;
            textElement.style.cssText = `
                margin-top: 12px;
                color: var(--text-muted, #6c757d);
                font-size: 14px;
                text-align: center;
            `;
            animationContainer.appendChild(textElement);
        }

        element.appendChild(animationContainer);

        // Load and play animation
        const animation = lottie.loadAnimation({
            container: lottieContainer,
            renderer: 'svg',
            loop: true,
            autoplay: true,
            path: this.animationPaths.loading
        });

        const animationId = this.generateId();
        this.animations.set(animationId, {
            animation,
            container: element,
            type: 'loading'
        });

        return animationId;
    }

    /**
     * Show success animation with optional message
     * @param {HTMLElement|string} container - Container element or selector
     * @param {Object} options - Animation options
     */
    showSuccess(container, options = {}) {
        return this.showFeedback(container, 'success', {
            message: options.message || 'Success!',
            duration: options.duration || 2000,
            ...options
        });
    }

    /**
     * Show error animation with optional message
     * @param {HTMLElement|string} container - Container element or selector
     * @param {Object} options - Animation options
     */
    showError(container, options = {}) {
        return this.showFeedback(container, 'error', {
            message: options.message || 'Error occurred',
            duration: options.duration || 3000,
            ...options
        });
    }

    /**
     * Show empty state animation
     * @param {HTMLElement|string} container - Container element or selector
     * @param {Object} options - Animation options
     */
    showEmptyState(container, options = {}) {
        const element = typeof container === 'string' ? document.querySelector(container) : container;
        if (!element) return null;

        // Clear existing content
        element.innerHTML = '';
        
        // Create empty state container
        const emptyContainer = document.createElement('div');
        emptyContainer.className = 'lottie-empty-state';
        emptyContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: ${options.minHeight || '200px'};
            padding: 40px 20px;
            text-align: center;
        `;

        // Create Lottie container
        const lottieContainer = document.createElement('div');
        lottieContainer.className = 'lottie-animation';
        lottieContainer.style.cssText = `
            width: ${options.width || '120px'};
            height: ${options.height || '120px'};
            margin-bottom: 20px;
        `;

        emptyContainer.appendChild(lottieContainer);

        // Add title
        if (options.title) {
            const titleElement = document.createElement('h3');
            titleElement.className = 'empty-state-title';
            titleElement.textContent = options.title;
            titleElement.style.cssText = `
                margin: 0 0 8px 0;
                color: var(--text-primary, #212529);
                font-size: 18px;
                font-weight: 600;
            `;
            emptyContainer.appendChild(titleElement);
        }

        // Add message
        if (options.message) {
            const messageElement = document.createElement('p');
            messageElement.className = 'empty-state-message';
            messageElement.textContent = options.message;
            messageElement.style.cssText = `
                margin: 0 0 20px 0;
                color: var(--text-muted, #6c757d);
                font-size: 14px;
                line-height: 1.5;
                max-width: 300px;
            `;
            emptyContainer.appendChild(messageElement);
        }

        // Add action button if provided
        if (options.actionText && options.actionCallback) {
            const actionButton = document.createElement('button');
            actionButton.className = 'btn btn-primary btn-sm';
            actionButton.textContent = options.actionText;
            actionButton.onclick = options.actionCallback;
            emptyContainer.appendChild(actionButton);
        }

        element.appendChild(emptyContainer);

        // Load and play animation
        const animation = lottie.loadAnimation({
            container: lottieContainer,
            renderer: 'svg',
            loop: true,
            autoplay: true,
            path: this.animationPaths.emptyState
        });

        const animationId = this.generateId();
        this.animations.set(animationId, {
            animation,
            container: element,
            type: 'emptyState'
        });

        return animationId;
    }

    /**
     * Show feedback animation (success/error)
     * @private
     */
    showFeedback(container, type, options) {
        const element = typeof container === 'string' ? document.querySelector(container) : container;
        if (!element) return null;

        // Create feedback container
        const feedbackContainer = document.createElement('div');
        feedbackContainer.className = `lottie-feedback lottie-${type}`;
        feedbackContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        `;

        // Create Lottie container
        const lottieContainer = document.createElement('div');
        lottieContainer.className = 'lottie-animation';
        lottieContainer.style.cssText = `
            width: ${options.width || '50px'};
            height: ${options.height || '50px'};
            margin-bottom: 12px;
        `;

        feedbackContainer.appendChild(lottieContainer);

        // Add message
        if (options.message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'feedback-message';
            messageElement.textContent = options.message;
            messageElement.style.cssText = `
                color: ${type === 'success' ? 'var(--success-color, #28a745)' : 'var(--danger-color, #dc3545)'};
                font-size: 14px;
                font-weight: 500;
            `;
            feedbackContainer.appendChild(messageElement);
        }

        // If replacing content, clear it first
        if (options.replace !== false) {
            element.innerHTML = '';
        }
        element.appendChild(feedbackContainer);

        // Load and play animation
        const animation = lottie.loadAnimation({
            container: lottieContainer,
            renderer: 'svg',
            loop: false,
            autoplay: true,
            path: this.animationPaths[type]
        });

        const animationId = this.generateId();
        this.animations.set(animationId, {
            animation,
            container: element,
            type
        });

        // Auto-remove after duration
        if (options.duration > 0) {
            setTimeout(() => {
                this.remove(animationId);
                if (options.onComplete) {
                    options.onComplete();
                }
            }, options.duration);
        }

        return animationId;
    }

    /**
     * Remove animation by ID
     * @param {string} animationId - Animation ID to remove
     */
    remove(animationId) {
        const animationData = this.animations.get(animationId);
        if (animationData) {
            animationData.animation.destroy();
            
            // Remove the animation container
            const lottieContainer = animationData.container.querySelector('.lottie-loading-container, .lottie-feedback, .lottie-empty-state');
            if (lottieContainer) {
                lottieContainer.remove();
            }
            
            this.animations.delete(animationId);
        }
    }

    /**
     * Remove all animations
     */
    removeAll() {
        this.animations.forEach((animationData, id) => {
            this.remove(id);
        });
    }

    /**
     * Create loading overlay for entire page or specific element
     * @param {HTMLElement|string} container - Container element or selector (defaults to body)
     * @param {Object} options - Overlay options
     */
    showLoadingOverlay(container = document.body, options = {}) {
        const element = typeof container === 'string' ? document.querySelector(container) : container;
        if (!element) return null;

        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'lottie-loading-overlay';
        overlay.style.cssText = `
            position: ${element === document.body ? 'fixed' : 'absolute'};
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(2px);
        `;

        // Create content container
        const contentContainer = document.createElement('div');
        contentContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        `;

        // Create Lottie container
        const lottieContainer = document.createElement('div');
        lottieContainer.style.cssText = `
            width: ${options.width || '80px'};
            height: ${options.height || '80px'};
        `;

        contentContainer.appendChild(lottieContainer);

        // Add loading text
        if (options.text) {
            const textElement = document.createElement('div');
            textElement.textContent = options.text;
            textElement.style.cssText = `
                margin-top: 16px;
                color: var(--text-primary, #212529);
                font-size: 16px;
                font-weight: 500;
            `;
            contentContainer.appendChild(textElement);
        }

        overlay.appendChild(contentContainer);
        element.appendChild(overlay);

        // Load animation
        const animation = lottie.loadAnimation({
            container: lottieContainer,
            renderer: 'svg',
            loop: true,
            autoplay: true,
            path: this.animationPaths.loading
        });

        const animationId = this.generateId();
        this.animations.set(animationId, {
            animation,
            container: element,
            overlay,
            type: 'overlay'
        });

        return animationId;
    }

    /**
     * Remove loading overlay
     * @param {string} animationId - Animation ID
     */
    removeOverlay(animationId) {
        const animationData = this.animations.get(animationId);
        if (animationData && animationData.type === 'overlay') {
            animationData.animation.destroy();
            if (animationData.overlay) {
                animationData.overlay.remove();
            }
            this.animations.delete(animationId);
        }
    }

    /**
     * Generate unique animation ID
     * @private
     */
    generateId() {
        return 'lottie_' + Math.random().toString(36).substr(2, 9);
    }
}

// Create global instance
window.lottieManager = new LottieManager();

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LottieManager;
}
/**
 * Micro-Interactions Manager
 * Handles hover effects, button animations, focus indicators, and smooth transitions
 */
class MicroInteractionsManager {
    constructor() {
        this.init();
    }

    init() {
        this.setupButtonInteractions();
        this.setupCardInteractions();
        this.setupFormInteractions();
        this.setupModalInteractions();
        this.setupDropdownInteractions();
        this.setupTableInteractions();
        this.setupNavigationInteractions();
        this.setupKeyboardNavigation();
        this.initializeRippleEffect();
    }

    /**
     * Setup button hover effects and click animations
     */
    setupButtonInteractions() {
        // Add hover and click effects to all buttons
        document.addEventListener('click', (e) => {
            const button = e.target.closest('button, .btn, .btn-link');
            if (button && !button.disabled) {
                this.addClickFeedback(button);
            }
        });

        // Add hover effects
        document.addEventListener('mouseover', (e) => {
            const button = e.target.closest('button, .btn, .btn-link');
            if (button && !button.disabled) {
                this.addHoverEffect(button);
            }
        });

        document.addEventListener('mouseout', (e) => {
            const button = e.target.closest('button, .btn, .btn-link');
            if (button) {
                this.removeHoverEffect(button);
            }
        });
    }

    /**
     * Add click feedback animation to buttons
     */
    addClickFeedback(element) {
        // Add click animation class
        element.classList.add('btn-clicked');
        
        // Create ripple effect
        this.createRipple(element, event);
        
        // Remove animation class after animation completes
        setTimeout(() => {
            element.classList.remove('btn-clicked');
        }, 200);
    }

    /**
     * Add hover effect to interactive elements
     */
    addHoverEffect(element) {
        if (!element.classList.contains('no-hover')) {
            element.classList.add('btn-hover');
        }
    }

    /**
     * Remove hover effect
     */
    removeHoverEffect(element) {
        element.classList.remove('btn-hover');
    }

    /**
     * Setup card hover and interaction effects
     */
    setupCardInteractions() {
        // Add hover effects to cards
        document.addEventListener('mouseover', (e) => {
            const card = e.target.closest('.card, .summary-card, .watchlist-item, .table-row');
            if (card && !card.classList.contains('no-hover')) {
                card.classList.add('card-hover');
            }
        });

        document.addEventListener('mouseout', (e) => {
            const card = e.target.closest('.card, .summary-card, .watchlist-item, .table-row');
            if (card) {
                card.classList.remove('card-hover');
            }
        });

        // Add click effects to clickable cards
        document.addEventListener('click', (e) => {
            const clickableCard = e.target.closest('.card[data-clickable], .watchlist-item, .table-row[data-clickable]');
            if (clickableCard) {
                this.addCardClickEffect(clickableCard);
            }
        });
    }

    /**
     * Add click effect to cards
     */
    addCardClickEffect(card) {
        card.classList.add('card-clicked');
        setTimeout(() => {
            card.classList.remove('card-clicked');
        }, 150);
    }

    /**
     * Setup form input interactions and focus effects
     */
    setupFormInteractions() {
        // Enhanced focus effects for form inputs
        document.addEventListener('focusin', (e) => {
            const input = e.target.closest('input, select, textarea');
            if (input) {
                this.addInputFocus(input);
            }
        });

        document.addEventListener('focusout', (e) => {
            const input = e.target.closest('input, select, textarea');
            if (input) {
                this.removeInputFocus(input);
            }
        });

        // Add floating label effects
        document.addEventListener('input', (e) => {
            const input = e.target;
            if (input.matches('input, textarea')) {
                this.updateFloatingLabel(input);
            }
        });

        // Setup form validation visual feedback
        document.addEventListener('invalid', (e) => {
            this.addValidationFeedback(e.target, 'invalid');
        });
    }

    /**
     * Add focus effect to form inputs
     */
    addInputFocus(input) {
        const formGroup = input.closest('.form-group, .input-group, .form-floating');
        if (formGroup) {
            formGroup.classList.add('input-focused');
        }
        input.classList.add('input-focus');
    }

    /**
     * Remove focus effect from form inputs
     */
    removeInputFocus(input) {
        const formGroup = input.closest('.form-group, .input-group, .form-floating');
        if (formGroup) {
            formGroup.classList.remove('input-focused');
        }
        input.classList.remove('input-focus');
    }

    /**
     * Update floating label based on input value
     */
    updateFloatingLabel(input) {
        const formGroup = input.closest('.form-floating, .floating-label');
        if (formGroup) {
            if (input.value.trim() !== '') {
                formGroup.classList.add('has-value');
            } else {
                formGroup.classList.remove('has-value');
            }
        }
    }

    /**
     * Add validation feedback animation
     */
    addValidationFeedback(input, type) {
        input.classList.add(`validation-${type}`);
        
        // Shake animation for invalid inputs
        if (type === 'invalid') {
            input.classList.add('shake-input');
            setTimeout(() => {
                input.classList.remove('shake-input');
            }, 500);
        }
    }

    /**
     * Setup modal interaction effects
     */
    setupModalInteractions() {
        // Enhanced modal show/hide animations
        document.addEventListener('show.bs.modal', (e) => {
            const modal = e.target;
            modal.classList.add('modal-showing');
        });

        document.addEventListener('shown.bs.modal', (e) => {
            const modal = e.target;
            modal.classList.remove('modal-showing');
            modal.classList.add('modal-shown');
        });

        document.addEventListener('hide.bs.modal', (e) => {
            const modal = e.target;
            modal.classList.add('modal-hiding');
        });

        document.addEventListener('hidden.bs.modal', (e) => {
            const modal = e.target;
            modal.classList.remove('modal-shown', 'modal-hiding');
        });
    }

    /**
     * Setup dropdown interaction effects
     */
    setupDropdownInteractions() {
        // Enhanced dropdown animations
        document.addEventListener('show.bs.dropdown', (e) => {
            const dropdown = e.target.querySelector('.dropdown-menu');
            if (dropdown) {
                dropdown.classList.add('dropdown-showing');
            }
        });

        document.addEventListener('shown.bs.dropdown', (e) => {
            const dropdown = e.target.querySelector('.dropdown-menu');
            if (dropdown) {
                dropdown.classList.remove('dropdown-showing');
                dropdown.classList.add('dropdown-shown');
            }
        });

        document.addEventListener('hide.bs.dropdown', (e) => {
            const dropdown = e.target.querySelector('.dropdown-menu');
            if (dropdown) {
                dropdown.classList.add('dropdown-hiding');
            }
        });

        document.addEventListener('hidden.bs.dropdown', (e) => {
            const dropdown = e.target.querySelector('.dropdown-menu');
            if (dropdown) {
                dropdown.classList.remove('dropdown-shown', 'dropdown-hiding');
            }
        });
    }

    /**
     * Setup table row interactions
     */
    setupTableInteractions() {
        // Add hover effects to table rows
        document.addEventListener('mouseover', (e) => {
            const row = e.target.closest('tr, .table-row');
            if (row && !row.classList.contains('no-hover')) {
                row.classList.add('row-hover');
            }
        });

        document.addEventListener('mouseout', (e) => {
            const row = e.target.closest('tr, .table-row');
            if (row) {
                row.classList.remove('row-hover');
            }
        });

        // Add selection effects
        document.addEventListener('click', (e) => {
            const row = e.target.closest('tr[data-selectable], .table-row[data-selectable]');
            if (row) {
                this.toggleRowSelection(row);
            }
        });
    }

    /**
     * Toggle table row selection
     */
    toggleRowSelection(row) {
        const isSelected = row.classList.contains('row-selected');
        
        // Remove selection from other rows if single-select
        if (!isSelected && row.dataset.multiSelect !== 'true') {
            document.querySelectorAll('.row-selected').forEach(selectedRow => {
                selectedRow.classList.remove('row-selected');
            });
        }
        
        row.classList.toggle('row-selected', !isSelected);
        
        // Add selection animation
        row.classList.add('row-selecting');
        setTimeout(() => {
            row.classList.remove('row-selecting');
        }, 200);
    }

    /**
     * Setup navigation interactions
     */
    setupNavigationInteractions() {
        // Add active state animations to navigation items
        document.addEventListener('click', (e) => {
            const navItem = e.target.closest('.nav-link, .sidebar-link');
            if (navItem) {
                this.addNavItemClickEffect(navItem);
            }
        });

        // Sidebar toggle animations
        const sidebarToggle = document.getElementById('sidebarToggle');
        if (sidebarToggle) {
            sidebarToggle.addEventListener('click', () => {
                this.animateSidebarToggle();
            });
        }
    }

    /**
     * Add click effect to navigation items
     */
    addNavItemClickEffect(navItem) {
        navItem.classList.add('nav-clicking');
        setTimeout(() => {
            navItem.classList.remove('nav-clicking');
        }, 200);
    }

    /**
     * Animate sidebar toggle
     */
    animateSidebarToggle() {
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        if (sidebar) {
            sidebar.classList.add('sidebar-transitioning');
            setTimeout(() => {
                sidebar.classList.remove('sidebar-transitioning');
            }, 300);
        }
        
        if (mainContent) {
            mainContent.classList.add('content-transitioning');
            setTimeout(() => {
                mainContent.classList.remove('content-transitioning');
            }, 300);
        }
    }

    /**
     * Setup keyboard navigation enhancements
     */
    setupKeyboardNavigation() {
        // Enhanced focus indicators
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                document.body.classList.add('keyboard-navigation');
            }
        });

        document.addEventListener('mousedown', () => {
            document.body.classList.remove('keyboard-navigation');
        });

        // Arrow key navigation for lists and tables
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                this.handleArrowKeyNavigation(e);
            }
        });

        // Enter key activation for buttons and links
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                const focusedElement = document.activeElement;
                if (focusedElement.matches('button, .btn, [role="button"]') && e.key === ' ') {
                    e.preventDefault();
                    focusedElement.click();
                }
            }
        });
    }

    /**
     * Handle arrow key navigation in lists and tables
     */
    handleArrowKeyNavigation(e) {
        const focusedElement = document.activeElement;
        const container = focusedElement.closest('.table, .list-group, .watchlist-items');
        
        if (!container) return;
        
        const items = container.querySelectorAll('[tabindex], button, a, input, select, textarea');
        const currentIndex = Array.from(items).indexOf(focusedElement);
        
        if (currentIndex === -1) return;
        
        let nextIndex;
        if (e.key === 'ArrowUp') {
            nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
        } else {
            nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
        }
        
        if (items[nextIndex]) {
            e.preventDefault();
            items[nextIndex].focus();
        }
    }

    /**
     * Initialize ripple effect for material design-like interactions
     */
    initializeRippleEffect() {
        this.rippleElements = document.querySelectorAll('.btn, button, .card[data-ripple]');
        
        this.rippleElements.forEach(element => {
            element.addEventListener('click', (e) => {
                this.createRipple(element, e);
            });
        });
    }

    /**
     * Create ripple effect on click
     */
    createRipple(element, event) {
        // Don't add ripple if disabled or already has one
        if (element.disabled || element.querySelector('.ripple')) return;
        
        const rect = element.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = event.clientX - rect.left - size / 2;
        const y = event.clientY - rect.top - size / 2;
        
        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        ripple.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            left: ${x}px;
            top: ${y}px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: scale(0);
            animation: ripple-animation 0.6s ease-out;
            pointer-events: none;
            z-index: 1;
        `;
        
        // Ensure element has relative positioning
        if (getComputedStyle(element).position === 'static') {
            element.style.position = 'relative';
        }
        
        element.appendChild(ripple);
        
        // Remove ripple after animation
        setTimeout(() => {
            ripple.remove();
        }, 600);
    }

    /**
     * Add smooth scroll behavior to anchor links
     */
    setupSmoothScrolling() {
        document.addEventListener('click', (e) => {
            const link = e.target.closest('a[href^="#"]');
            if (link && link.getAttribute('href') !== '#') {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            }
        });
    }

    /**
     * Add loading state to buttons with async operations
     */
    addButtonLoadingState(button, promise) {
        const originalText = button.textContent;
        const originalDisabled = button.disabled;
        
        button.disabled = true;
        button.classList.add('btn-loading');
        
        // Add loading spinner if not present
        if (!button.querySelector('.spinner-border')) {
            const spinner = document.createElement('span');
            spinner.className = 'spinner-border spinner-border-sm me-2';
            spinner.setAttribute('role', 'status');
            button.insertBefore(spinner, button.firstChild);
        }
        
        return promise.finally(() => {
            button.disabled = originalDisabled;
            button.classList.remove('btn-loading');
            
            // Remove spinner
            const spinner = button.querySelector('.spinner-border');
            if (spinner) {
                spinner.remove();
            }
        });
    }

    /**
     * Add stagger animation to lists
     */
    staggerAnimation(elements, delay = 100) {
        elements.forEach((element, index) => {
            element.style.animationDelay = `${index * delay}ms`;
            element.classList.add('stagger-item');
        });
    }

    /**
     * Add parallax effect to elements
     */
    setupParallaxEffect() {
        const parallaxElements = document.querySelectorAll('[data-parallax]');
        
        if (parallaxElements.length === 0) return;
        
        const handleScroll = () => {
            const scrollTop = window.pageYOffset;
            
            parallaxElements.forEach(element => {
                const speed = parseFloat(element.dataset.parallax) || 0.5;
                const yPos = -(scrollTop * speed);
                element.style.transform = `translateY(${yPos}px)`;
            });
        };
        
        // Throttle scroll events
        let ticking = false;
        window.addEventListener('scroll', () => {
            if (!ticking) {
                requestAnimationFrame(() => {
                    handleScroll();
                    ticking = false;
                });
                ticking = true;
            }
        });
    }
}

// Initialize micro-interactions when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.microInteractions = new MicroInteractionsManager();
});

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = MicroInteractionsManager;
}
// ==========================================================================
// MOBILE NAVIGATION - Mobile-optimized navigation and menu interactions
// ==========================================================================

class MobileNavigation {
    constructor() {
        this.init();
        this.bindEvents();
    }

    init() {
        this.createMobileElements();
        this.setupResponsiveNavigation();
    }

    createMobileElements() {
        // Create mobile menu toggle if it doesn't exist
        if (!document.querySelector('.mobile-menu-toggle')) {
            const toggle = document.createElement('button');
            toggle.className = 'mobile-menu-toggle';
            toggle.innerHTML = `
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            
            // Insert toggle into header
            const header = document.querySelector('.top-bar') || document.querySelector('header');
            if (header) {
                header.insertBefore(toggle, header.firstChild);
            }
        }

        // Add mobile classes to existing navigation
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) {
            sidebar.classList.add('mobile-nav');
        }
    }

    setupResponsiveNavigation() {
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        if (sidebar && mainContent) {
            // Add overlay for mobile
            const overlay = document.createElement('div');
            overlay.className = 'mobile-nav-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1040;
                opacity: 0;
                visibility: hidden;
                transition: all 0.25s ease-in-out;
            `;
            document.body.appendChild(overlay);
        }
    }

    bindEvents() {
        // Mobile menu toggle
        document.addEventListener('click', (e) => {
            if (e.target.closest('.mobile-menu-toggle')) {
                this.toggleMobileMenu();
            }
        });

        // Close mobile menu when clicking overlay
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('mobile-nav-overlay')) {
                this.closeMobileMenu();
            }
        });

        // Close mobile menu when clicking nav link
        document.addEventListener('click', (e) => {
            if (e.target.closest('.mobile-nav .nav-link')) {
                this.closeMobileMenu();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                this.closeMobileMenu();
            }
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closeMobileMenu();
            }
        });

        // Prevent body scroll when mobile menu is open
        document.addEventListener('touchmove', (e) => {
            if (document.body.classList.contains('mobile-nav-open')) {
                if (!e.target.closest('.mobile-nav')) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
    }

    toggleMobileMenu() {
        const isOpen = document.body.classList.contains('mobile-nav-open');
        if (isOpen) {
            this.closeMobileMenu();
        } else {
            this.openMobileMenu();
        }
    }

    openMobileMenu() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.mobile-nav-overlay');
        const hamburger = document.querySelector('.hamburger');

        if (sidebar) {
            sidebar.classList.add('active');
        }

        if (overlay) {
            overlay.style.opacity = '1';
            overlay.style.visibility = 'visible';
        }

        if (hamburger) {
            hamburger.classList.add('active');
        }

        document.body.classList.add('mobile-nav-open');
        document.body.style.overflow = 'hidden';

        // Focus management for accessibility
        const firstNavLink = sidebar?.querySelector('.nav-link');
        if (firstNavLink) {
            firstNavLink.focus();
        }
    }

    closeMobileMenu() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.mobile-nav-overlay');
        const hamburger = document.querySelector('.hamburger');

        if (sidebar) {
            sidebar.classList.remove('active');
        }

        if (overlay) {
            overlay.style.opacity = '0';
            overlay.style.visibility = 'hidden';
        }

        if (hamburger) {
            hamburger.classList.remove('active');
        }

        document.body.classList.remove('mobile-nav-open');
        document.body.style.overflow = '';
    }
}

// ==========================================================================
// TOUCH GESTURES - Touch gesture handling for mobile interactions
// ==========================================================================

class TouchGestureHandler {
    constructor() {
        this.startX = 0;
        this.startY = 0;
        this.currentX = 0;
        this.currentY = 0;
        this.isDragging = false;
        this.threshold = 50; // Minimum distance for swipe
        this.restraint = 100; // Maximum perpendicular distance
        this.allowedTime = 300; // Maximum time for swipe
        this.startTime = 0;

        this.init();
    }

    init() {
        this.bindSwipeEvents();
        this.bindPullToRefresh();
        this.bindLongPress();
    }

    bindSwipeEvents() {
        // Swipe gestures for tables and charts
        const swipeableElements = document.querySelectorAll('.table-mobile, .chart-container, .swipeable');
        
        swipeableElements.forEach(element => {
            this.addSwipeListeners(element);
        });
    }

    addSwipeListeners(element) {
        element.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e, element);
        }, { passive: true });

        element.addEventListener('touchmove', (e) => {
            this.handleTouchMove(e, element);
        }, { passive: false });

        element.addEventListener('touchend', (e) => {
            this.handleTouchEnd(e, element);
        }, { passive: true });
    }

    handleTouchStart(e, element) {
        const touch = e.touches[0];
        this.startX = touch.clientX;
        this.startY = touch.clientY;
        this.startTime = new Date().getTime();
        this.isDragging = false;

        element.classList.add('touch-active');
    }

    handleTouchMove(e, element) {
        if (!e.touches[0]) return;

        const touch = e.touches[0];
        this.currentX = touch.clientX;
        this.currentY = touch.clientY;

        const deltaX = this.currentX - this.startX;
        const deltaY = this.currentY - this.startY;

        // Check if this is a horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            this.isDragging = true;
            element.classList.add('swiping');

            // For horizontal scrollable elements, allow native scrolling
            if (element.scrollWidth > element.clientWidth) {
                return;
            }

            // Prevent vertical scrolling during horizontal swipe
            e.preventDefault();
        }
    }

    handleTouchEnd(e, element) {
        if (!this.isDragging) {
            element.classList.remove('touch-active');
            return;
        }

        const deltaX = this.currentX - this.startX;
        const deltaY = this.currentY - this.startY;
        const elapsedTime = new Date().getTime() - this.startTime;

        element.classList.remove('touch-active', 'swiping');

        // Check if swipe meets criteria
        if (elapsedTime <= this.allowedTime && 
            Math.abs(deltaX) >= this.threshold && 
            Math.abs(deltaY) <= this.restraint) {
            
            if (deltaX > 0) {
                this.handleSwipeRight(element);
            } else {
                this.handleSwipeLeft(element);
            }
        }

        this.isDragging = false;
    }

    handleSwipeLeft(element) {
        // Emit custom event
        element.dispatchEvent(new CustomEvent('swipeleft', {
            detail: { element }
        }));

        // Handle specific swipe actions
        if (element.classList.contains('watchlist-item')) {
            this.showSwipeActions(element);
        }
    }

    handleSwipeRight(element) {
        // Emit custom event
        element.dispatchEvent(new CustomEvent('swiperight', {
            detail: { element }
        }));

        // Handle specific swipe actions
        if (element.classList.contains('watchlist-item')) {
            this.hideSwipeActions(element);
        }
    }

    showSwipeActions(element) {
        const actions = element.querySelector('.swipe-actions');
        if (actions) {
            actions.classList.add('visible');
            element.style.transform = 'translateX(-80px)';
        }
    }

    hideSwipeActions(element) {
        const actions = element.querySelector('.swipe-actions');
        if (actions) {
            actions.classList.remove('visible');
            element.style.transform = '';
        }
    }

    bindPullToRefresh() {
        const refreshableElements = document.querySelectorAll('.pull-to-refresh');
        
        refreshableElements.forEach(element => {
            let startY = 0;
            let currentY = 0;
            let isPulling = false;

            element.addEventListener('touchstart', (e) => {
                if (element.scrollTop === 0) {
                    startY = e.touches[0].clientY;
                }
            }, { passive: true });

            element.addEventListener('touchmove', (e) => {
                if (element.scrollTop === 0 && startY) {
                    currentY = e.touches[0].clientY;
                    const pullDistance = currentY - startY;

                    if (pullDistance > 0) {
                        isPulling = true;
                        element.classList.add('pulling');
                        
                        if (pullDistance > 80) {
                            element.classList.add('ready-to-refresh');
                        } else {
                            element.classList.remove('ready-to-refresh');
                        }

                        // Prevent default scrolling
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            element.addEventListener('touchend', () => {
                if (isPulling && element.classList.contains('ready-to-refresh')) {
                    this.triggerRefresh(element);
                }

                element.classList.remove('pulling', 'ready-to-refresh');
                isPulling = false;
                startY = 0;
            }, { passive: true });
        });
    }

    triggerRefresh(element) {
        element.classList.add('refreshing');
        
        // Emit refresh event
        element.dispatchEvent(new CustomEvent('pullrefresh', {
            detail: { element }
        }));

        // Auto-hide after 2 seconds if not manually hidden
        setTimeout(() => {
            element.classList.remove('refreshing');
        }, 2000);
    }

    bindLongPress() {
        const longPressElements = document.querySelectorAll('.long-pressable');
        
        longPressElements.forEach(element => {
            let pressTimer;
            let startX, startY;

            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                
                element.classList.add('long-pressing');
                
                pressTimer = setTimeout(() => {
                    element.dispatchEvent(new CustomEvent('longpress', {
                        detail: { element }
                    }));
                    element.classList.remove('long-pressing');
                }, 800);
            }, { passive: true });

            element.addEventListener('touchmove', (e) => {
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = Math.abs(currentX - startX);
                const deltaY = Math.abs(currentY - startY);

                // Cancel long press if finger moves too much
                if (deltaX > 10 || deltaY > 10) {
                    clearTimeout(pressTimer);
                    element.classList.remove('long-pressing');
                }
            }, { passive: true });

            element.addEventListener('touchend', () => {
                clearTimeout(pressTimer);
                element.classList.remove('long-pressing');
            }, { passive: true });
        });
    }
}

// ==========================================================================
// MOBILE OPTIMIZATIONS - Performance and UX optimizations for mobile
// ==========================================================================

class MobileOptimizations {
    constructor() {
        this.init();
    }

    init() {
        this.setupViewportMeta();
        this.optimizeScrolling();
        this.handleOrientationChange();
        this.setupTouchFeedback();
        this.optimizeInputs();
        this.setupEnhancedTouchTargets();
        this.setupAccessibilityEnhancements();
        this.setupPerformanceOptimizations();
    }

    setupViewportMeta() {
        // Ensure proper viewport meta tag
        let viewport = document.querySelector('meta[name="viewport"]');
        if (!viewport) {
            viewport = document.createElement('meta');
            viewport.name = 'viewport';
            document.head.appendChild(viewport);
        }
        
        viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
    }

    optimizeScrolling() {
        // Add momentum scrolling for iOS
        const scrollableElements = document.querySelectorAll('.modal-body, .table-container, .chart-container');
        
        scrollableElements.forEach(element => {
            element.style.webkitOverflowScrolling = 'touch';
        });
    }

    handleOrientationChange() {
        window.addEventListener('orientationchange', () => {
            // Force repaint after orientation change
            setTimeout(() => {
                window.scrollTo(0, 0);
                
                // Trigger resize event for charts
                window.dispatchEvent(new Event('resize'));
            }, 100);
        });
    }

    setupTouchFeedback() {
        // Add touch feedback to interactive elements
        const interactiveElements = document.querySelectorAll('button, .btn, .nav-link, .card-clickable');
        
        interactiveElements.forEach(element => {
            if (!element.classList.contains('touch-feedback')) {
                element.classList.add('touch-feedback');
            }
        });
    }

    optimizeInputs() {
        // Prevent zoom on input focus for iOS
        const inputs = document.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            if (!input.classList.contains('no-zoom')) {
                input.classList.add('no-zoom');
            }
        });

        // Add proper input types for mobile keyboards
        const emailInputs = document.querySelectorAll('input[name*="email"], input[id*="email"]');
        emailInputs.forEach(input => {
            input.type = 'email';
        });

        const phoneInputs = document.querySelectorAll('input[name*="phone"], input[id*="phone"]');
        phoneInputs.forEach(input => {
            input.type = 'tel';
        });

        const numberInputs = document.querySelectorAll('input[name*="quantity"], input[name*="price"], input[name*="amount"]');
        numberInputs.forEach(input => {
            input.type = 'number';
            input.inputMode = 'decimal';
        });
    }

    setupEnhancedTouchTargets() {
        // Enhance all interactive elements with proper touch targets
        const interactiveElements = document.querySelectorAll(
            'button, .btn, a, input, select, textarea, .nav-link, .card-clickable, .dropdown-toggle'
        );
        
        interactiveElements.forEach(element => {
            // Ensure minimum touch target size
            const rect = element.getBoundingClientRect();
            if (rect.width < 44 || rect.height < 44) {
                element.classList.add('touch-target');
            }
            
            // Add touch feedback
            if (!element.classList.contains('touch-feedback')) {
                element.classList.add('touch-feedback');
            }
            
            // Add enhanced touch classes for mobile
            element.classList.add('btn-mobile-enhanced');
        });
        
        // Add mobile-optimized classes to existing components
        this.addMobileOptimizedClasses();
    }
    
    addMobileOptimizedClasses() {
        // Add mobile-optimized classes to existing elements
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => card.classList.add('card-mobile-optimized'));
        
        const forms = document.querySelectorAll('form');
        forms.forEach(form => form.classList.add('form-mobile-optimized'));
        
        const tables = document.querySelectorAll('.table');
        tables.forEach(table => table.classList.add('table-mobile-optimized'));
        
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => modal.classList.add('modal-mobile-optimized'));
        
        const searchContainers = document.querySelectorAll('.search-container');
        searchContainers.forEach(container => container.classList.add('search-mobile-optimized'));
        
        const dashboards = document.querySelectorAll('.dashboard');
        dashboards.forEach(dashboard => dashboard.classList.add('dashboard-mobile-optimized'));
        
        const navs = document.querySelectorAll('.sidebar, .nav');
        navs.forEach(nav => nav.classList.add('nav-mobile-optimized'));
    }

    setupAccessibilityEnhancements() {
        // Add proper ARIA labels for mobile screen readers
        const buttons = document.querySelectorAll('button:not([aria-label])');
        buttons.forEach(button => {
            const text = button.textContent.trim() || button.title || 'Button';
            button.setAttribute('aria-label', text);
        });

        // Enhance form labels
        const inputs = document.querySelectorAll('input:not([aria-label])');
        inputs.forEach(input => {
            const label = document.querySelector(`label[for="${input.id}"]`) || 
                         input.closest('.form-group')?.querySelector('label');
            if (label) {
                input.setAttribute('aria-label', label.textContent.trim());
            }
        });

        // Add role attributes for better navigation
        const navElements = document.querySelectorAll('.nav, .navbar, .sidebar');
        navElements.forEach(nav => {
            if (!nav.getAttribute('role')) {
                nav.setAttribute('role', 'navigation');
            }
        });
    }

    setupPerformanceOptimizations() {
        // Implement passive event listeners where possible
        const scrollElements = document.querySelectorAll('.modal-body, .table-container, .chart-container');
        scrollElements.forEach(element => {
            element.addEventListener('scroll', this.throttle(() => {
                // Update scroll indicators or other UI elements
                this.updateScrollIndicators(element);
            }, 16), { passive: true });
        });

        // Optimize animations for mobile
        if (window.innerWidth <= 768) {
            document.documentElement.style.setProperty('--transition-fast', '0.15s');
            document.documentElement.style.setProperty('--transition-normal', '0.25s');
        }
    }

    throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    updateScrollIndicators(element) {
        const indicator = element.querySelector('.scroll-indicator');
        if (indicator) {
            const scrollPercent = (element.scrollLeft / (element.scrollWidth - element.clientWidth)) * 100;
            indicator.style.width = `${scrollPercent}%`;
            indicator.classList.toggle('visible', element.scrollLeft > 0);
        }
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize mobile navigation
    new MobileNavigation();
    
    // Initialize touch gestures
    new TouchGestureHandler();
    
    // Initialize mobile optimizations
    new MobileOptimizations();
});

// Export for use in other modules
window.MobileNavigation = MobileNavigation;
window.TouchGestureHandler = TouchGestureHandler;
window.MobileOptimizations = MobileOptimizations;
// ==
========================================================================
// ENHANCED MOBILE NAVIGATION GESTURES
// ==========================================================================

class EnhancedMobileNavigation extends MobileNavigation {
    constructor() {
        super();
        this.setupSwipeNavigation();
        this.setupEdgeSwipe();
        this.setupNavigationGestures();
    }

    setupSwipeNavigation() {
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;
        let isDragging = false;

        document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            isDragging = false;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!e.touches[0]) return;

            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;

            const deltaX = currentX - startX;
            const deltaY = currentY - startY;

            // Check for horizontal swipe
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                isDragging = true;

                // Right swipe from left edge to open menu
                if (startX < 50 && deltaX > 100) {
                    this.openMobileMenu();
                }

                // Left swipe to close menu when open
                if (document.body.classList.contains('mobile-nav-open') && deltaX < -100) {
                    this.closeMobileMenu();
                }
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            isDragging = false;
        }, { passive: true });
    }

    setupEdgeSwipe() {
        // Enhanced edge swipe detection
        const edgeThreshold = 20;
        let edgeSwipeStarted = false;

        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            if (touch.clientX <= edgeThreshold) {
                edgeSwipeStarted = true;
                this.showEdgeSwipeIndicator();
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (edgeSwipeStarted && e.touches[0]) {
                const deltaX = e.touches[0].clientX - edgeThreshold;
                if (deltaX > 50) {
                    this.openMobileMenu();
                    edgeSwipeStarted = false;
                    this.hideEdgeSwipeIndicator();
                }
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            edgeSwipeStarted = false;
            this.hideEdgeSwipeIndicator();
        }, { passive: true });
    }

    showEdgeSwipeIndicator() {
        let indicator = document.querySelector('.edge-swipe-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'edge-swipe-indicator';
            indicator.style.cssText = `
                position: fixed;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 4px;
                height: 60px;
                background: var(--color-primary);
                border-radius: 0 4px 4px 0;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.2s ease;
            `;
            document.body.appendChild(indicator);
        }
        indicator.style.opacity = '0.7';
    }

    hideEdgeSwipeIndicator() {
        const indicator = document.querySelector('.edge-swipe-indicator');
        if (indicator) {
            indicator.style.opacity = '0';
        }
    }

    setupNavigationGestures() {
        // Add haptic-like feedback for navigation actions
        const navLinks = document.querySelectorAll('.nav-link');
        navLinks.forEach(link => {
            link.addEventListener('touchstart', () => {
                link.classList.add('haptic-light');
            }, { passive: true });

            link.addEventListener('touchend', () => {
                setTimeout(() => {
                    link.classList.remove('haptic-light');
                }, 150);
            }, { passive: true });
        });

        // Enhanced menu toggle with gesture feedback
        const menuToggle = document.querySelector('.mobile-menu-toggle');
        if (menuToggle) {
            let pressTimer;
            
            menuToggle.addEventListener('touchstart', () => {
                menuToggle.classList.add('haptic-medium');
                
                // Long press to show navigation shortcuts
                pressTimer = setTimeout(() => {
                    this.showNavigationShortcuts();
                }, 800);
            }, { passive: true });

            menuToggle.addEventListener('touchend', () => {
                clearTimeout(pressTimer);
                setTimeout(() => {
                    menuToggle.classList.remove('haptic-medium');
                }, 200);
            }, { passive: true });
        }
    }

    showNavigationShortcuts() {
        // Create navigation shortcuts overlay
        const shortcuts = document.createElement('div');
        shortcuts.className = 'navigation-shortcuts';
        shortcuts.innerHTML = `
            <div class="shortcuts-container">
                <div class="shortcut-item" data-action="dashboard">
                    <i class="fas fa-chart-line"></i>
                    <span>Dashboard</span>
                </div>
                <div class="shortcut-item" data-action="watchlist">
                    <i class="fas fa-eye"></i>
                    <span>Watchlist</span>
                </div>
                <div class="shortcut-item" data-action="leaderboard">
                    <i class="fas fa-trophy"></i>
                    <span>Leaderboard</span>
                </div>
                <div class="shortcut-item" data-action="profile">
                    <i class="fas fa-user"></i>
                    <span>Profile</span>
                </div>
            </div>
        `;

        shortcuts.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        `;

        const container = shortcuts.querySelector('.shortcuts-container');
        container.style.cssText = `
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            padding: 40px;
        `;

        const items = shortcuts.querySelectorAll('.shortcut-item');
        items.forEach(item => {
            item.style.cssText = `
                background: var(--bg-card);
                border-radius: 16px;
                padding: 24px;
                text-align: center;
                cursor: pointer;
                transition: all 0.2s ease;
                min-height: 100px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;

            item.addEventListener('click', () => {
                const action = item.dataset.action;
                this.handleShortcutAction(action);
                document.body.removeChild(shortcuts);
            });
        });

        document.body.appendChild(shortcuts);

        // Close on background click
        shortcuts.addEventListener('click', (e) => {
            if (e.target === shortcuts) {
                document.body.removeChild(shortcuts);
            }
        });
    }

    handleShortcutAction(action) {
        const routes = {
            dashboard: '/Home',
            watchlist: '/Home#watchlist',
            leaderboard: '/Home/Leaderboard',
            profile: '/User/Profile'
        };

        if (routes[action]) {
            window.location.href = routes[action];
        }
    }
}

// ==========================================================================
// ENHANCED TOUCH FEEDBACK SYSTEM
// ==========================================================================

class EnhancedTouchFeedback {
    constructor() {
        this.init();
    }

    init() {
        this.setupRippleEffect();
        this.setupHapticFeedback();
        this.setupTouchStates();
    }

    setupRippleEffect() {
        document.addEventListener('touchstart', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target && !target.classList.contains('no-ripple')) {
                this.createRipple(target, e.touches[0]);
            }
        }, { passive: true });
    }

    createRipple(element, touch) {
        const rect = element.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = touch.clientX - rect.left - size / 2;
        const y = touch.clientY - rect.top - size / 2;

        const ripple = document.createElement('div');
        ripple.className = 'ripple-effect';
        ripple.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            left: ${x}px;
            top: ${y}px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: scale(0);
            animation: ripple-animation 0.6s ease-out;
            pointer-events: none;
            z-index: 1;
        `;

        // Ensure element has relative positioning
        if (getComputedStyle(element).position === 'static') {
            element.style.position = 'relative';
        }

        element.appendChild(ripple);

        // Add CSS animation if not exists
        if (!document.querySelector('#ripple-styles')) {
            const style = document.createElement('style');
            style.id = 'ripple-styles';
            style.textContent = `
                @keyframes ripple-animation {
                    to {
                        transform: scale(2);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Remove ripple after animation
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.parentNode.removeChild(ripple);
            }
        }, 600);
    }

    setupHapticFeedback() {
        // Visual haptic feedback for different interaction types
        const lightElements = document.querySelectorAll('.btn-sm, .nav-link');
        const mediumElements = document.querySelectorAll('.btn, .card-clickable');
        const heavyElements = document.querySelectorAll('.btn-lg, .fab');

        lightElements.forEach(el => el.classList.add('haptic-light'));
        mediumElements.forEach(el => el.classList.add('haptic-medium'));
        heavyElements.forEach(el => el.classList.add('haptic-heavy'));
    }

    setupTouchStates() {
        // Enhanced touch states for better feedback
        document.addEventListener('touchstart', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target) {
                target.classList.add('touch-active');
            }
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target) {
                setTimeout(() => {
                    target.classList.remove('touch-active');
                }, 150);
            }
        }, { passive: true });

        document.addEventListener('touchcancel', (e) => {
            const target = e.target.closest('.btn, .nav-link, .card-clickable');
            if (target) {
                target.classList.remove('touch-active');
            }
        }, { passive: true });
    }
}

// ==========================================================================
// MOBILE PERFORMANCE MONITOR
// ==========================================================================

class MobilePerformanceMonitor {
    constructor() {
        this.init();
    }

    init() {
        this.monitorScrollPerformance();
        this.optimizeAnimations();
        this.setupLazyLoading();
    }

    monitorScrollPerformance() {
        let ticking = false;

        const updateScrollElements = () => {
            // Update scroll-dependent elements
            const scrollableElements = document.querySelectorAll('.scrollable');
            scrollableElements.forEach(element => {
                this.updateScrollIndicators(element);
            });
            ticking = false;
        };

        document.addEventListener('scroll', () => {
            if (!ticking) {
                requestAnimationFrame(updateScrollElements);
                ticking = true;
            }
        }, { passive: true });
    }

    updateScrollIndicators(element) {
        const indicator = element.querySelector('.scroll-indicator');
        if (indicator) {
            const scrollPercent = (element.scrollTop / (element.scrollHeight - element.clientHeight)) * 100;
            indicator.style.width = `${Math.min(scrollPercent, 100)}%`;
            indicator.classList.toggle('visible', element.scrollTop > 0);
        }
    }

    optimizeAnimations() {
        // Reduce animations on low-end devices
        if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
            document.documentElement.style.setProperty('--transition-fast', '0.1s');
            document.documentElement.style.setProperty('--transition-normal', '0.2s');
        }

        // Pause animations when page is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                document.body.classList.add('animations-paused');
            } else {
                document.body.classList.remove('animations-paused');
            }
        });
    }

    setupLazyLoading() {
        // Lazy load images and heavy content
        const images = document.querySelectorAll('img[data-src]');
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.add('loaded');
                    imageObserver.unobserve(img);
                }
            });
        });

        images.forEach(img => imageObserver.observe(img));
    }
}

// ==========================================================================
// INITIALIZATION - Enhanced Mobile Features
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Replace basic mobile navigation with enhanced version
    if (window.innerWidth <= 768) {
        new EnhancedMobileNavigation();
        new EnhancedTouchFeedback();
        new MobilePerformanceMonitor();
    }
});
// ==========================================================================
// SWIPE GESTURES - Swipe gesture support for charts and tables
// ==========================================================================

class SwipeGestureManager {
    constructor() {
        this.activeGestures = new Map();
        this.init();
    }

    init() {
        this.setupChartSwipes();
        this.setupTableSwipes();
        this.setupWatchlistSwipes();
    }

    setupChartSwipes() {
        const chartContainers = document.querySelectorAll('.chart-container, .stock-chart');
        
        chartContainers.forEach(container => {
            this.addChartSwipeSupport(container);
        });
    }

    addChartSwipeSupport(container) {
        const gesture = new ChartSwipeGesture(container);
        this.activeGestures.set(container, gesture);
    }

    setupTableSwipes() {
        const tables = document.querySelectorAll('.holdings-table, .leaderboard-table');
        
        tables.forEach(table => {
            this.addTableSwipeSupport(table);
        });
    }

    addTableSwipeSupport(table) {
        const gesture = new TableSwipeGesture(table);
        this.activeGestures.set(table, gesture);
    }

    setupWatchlistSwipes() {
        const watchlistItems = document.querySelectorAll('.watchlist-item');
        
        watchlistItems.forEach(item => {
            this.addWatchlistSwipeSupport(item);
        });
    }

    addWatchlistSwipeSupport(item) {
        const gesture = new WatchlistSwipeGesture(item);
        this.activeGestures.set(item, gesture);
    }
}

// ==========================================================================
// CHART SWIPE GESTURE
// ==========================================================================

class ChartSwipeGesture {
    constructor(container) {
        this.container = container;
        this.startX = 0;
        this.startY = 0;
        this.currentX = 0;
        this.currentY = 0;
        this.isDragging = false;
        this.timeframes = ['1D', '1W', '1M', '3M', '1Y', '5Y'];
        this.currentTimeframeIndex = 0;
        
        this.init();
    }

    init() {
        this.createTimeframeIndicator();
        this.bindEvents();
        this.addChartZoomSupport();
    }

    createTimeframeIndicator() {
        if (this.container.querySelector('.timeframe-indicator')) return;

        const indicator = document.createElement('div');
        indicator.className = 'timeframe-indicator';
        indicator.innerHTML = `
            <div class="timeframe-pills">
                ${this.timeframes.map((tf, index) => 
                    `<span class="timeframe-pill ${index === 0 ? 'active' : ''}" data-timeframe="${tf}">${tf}</span>`
                ).join('')}
            </div>
        `;
        
        this.container.appendChild(indicator);
        
        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .timeframe-indicator {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 10;
            }
            
            .timeframe-pills {
                display: flex;
                gap: 4px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 20px;
                padding: 4px;
            }
            
            .timeframe-pill {
                padding: 4px 8px;
                border-radius: 16px;
                color: white;
                font-size: 12px;
                cursor: pointer;
                transition: background-color 0.2s;
            }
            
            .timeframe-pill.active {
                background: var(--color-primary, #007bff);
            }
        `;
        document.head.appendChild(style);
    }

    bindEvents() {
        this.container.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        this.container.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.container.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });

        // Timeframe pill clicks
        this.container.addEventListener('click', (e) => {
            if (e.target.classList.contains('timeframe-pill')) {
                this.changeTimeframe(e.target.dataset.timeframe);
            }
        });
    }

    handleTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isDragging = false;
    }

    handleTouchMove(e) {
        if (!e.touches[0]) return;

        this.currentX = e.touches[0].clientX;
        this.currentY = e.touches[0].clientY;

        const deltaX = this.currentX - this.startX;
        const deltaY = this.currentY - this.startY;

        // Check if this is a horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
            this.isDragging = true;
            e.preventDefault(); // Prevent scrolling
        }
    }

    handleTouchEnd(e) {
        if (!this.isDragging) return;

        const deltaX = this.currentX - this.startX;
        const threshold = 50;

        if (Math.abs(deltaX) > threshold) {
            if (deltaX > 0) {
                this.previousTimeframe();
            } else {
                this.nextTimeframe();
            }
        }

        this.isDragging = false;
    }

    nextTimeframe() {
        if (this.currentTimeframeIndex < this.timeframes.length - 1) {
            this.currentTimeframeIndex++;
            this.updateTimeframe();
        }
    }

    previousTimeframe() {
        if (this.currentTimeframeIndex > 0) {
            this.currentTimeframeIndex--;
            this.updateTimeframe();
        }
    }

    changeTimeframe(timeframe) {
        const index = this.timeframes.indexOf(timeframe);
        if (index !== -1) {
            this.currentTimeframeIndex = index;
            this.updateTimeframe();
        }
    }

    updateTimeframe() {
        const pills = this.container.querySelectorAll('.timeframe-pill');
        pills.forEach((pill, index) => {
            pill.classList.toggle('active', index === this.currentTimeframeIndex);
        });

        // Show swipe hint
        this.showSwipeHint();

        // Emit event for chart update
        this.container.dispatchEvent(new CustomEvent('timeframechange', {
            detail: { 
                timeframe: this.timeframes[this.currentTimeframeIndex],
                index: this.currentTimeframeIndex
            }
        }));
    }

    showSwipeHint() {
        const hint = this.container.querySelector('.swipe-hint');
        if (hint) {
            hint.textContent = `Swipe to change timeframe (${this.timeframes[this.currentTimeframeIndex]})`;
            hint.classList.add('visible');
            
            setTimeout(() => {
                hint.classList.remove('visible');
            }, 2000);
        }
    }

    addChartZoomSupport() {
        let initialDistance = 0;
        let currentScale = 1;
        let initialCenter = { x: 0, y: 0 };
        let currentTranslate = { x: 0, y: 0 };
        
        this.container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                initialDistance = this.getDistance(e.touches[0], e.touches[1]);
                initialCenter = this.getCenter(e.touches[0], e.touches[1]);
            }
        }, { passive: true });

        this.container.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDistance = this.getDistance(e.touches[0], e.touches[1]);
                const currentCenter = this.getCenter(e.touches[0], e.touches[1]);
                
                const scale = currentDistance / initialDistance;
                currentScale = Math.min(Math.max(scale, 0.5), 3);
                
                // Calculate translation based on center point
                const deltaX = currentCenter.x - initialCenter.x;
                const deltaY = currentCenter.y - initialCenter.y;
                currentTranslate.x += deltaX;
                currentTranslate.y += deltaY;
                
                const chart = this.container.querySelector('canvas');
                if (chart) {
                    chart.style.transform = `scale(${currentScale}) translate(${currentTranslate.x}px, ${currentTranslate.y}px)`;
                }
                
                this.showZoomIndicator(currentScale);
            }
        }, { passive: false });

        this.container.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                // Reset or apply zoom
                const chart = this.container.querySelector('canvas');
                if (chart && currentScale !== 1) {
                    // Emit zoom event
                    this.container.dispatchEvent(new CustomEvent('chartzoom', {
                        detail: { 
                            scale: currentScale,
                            translate: currentTranslate
                        }
                    }));
                }
                this.hideZoomIndicator();
            }
        }, { passive: true });

        // Add zoom controls
        this.addZoomControls();
    }

    addZoomControls() {
        if (this.container.querySelector('.zoom-controls')) return;

        const controls = document.createElement('div');
        controls.className = 'zoom-controls';
        controls.innerHTML = `
            <button class="zoom-btn zoom-in" data-action="zoom-in">
                <i class="fas fa-plus"></i>
            </button>
            <button class="zoom-btn zoom-out" data-action="zoom-out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="zoom-btn zoom-reset" data-action="zoom-reset">
                <i class="fas fa-expand-arrows-alt"></i>
            </button>
        `;

        this.container.appendChild(controls);

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .zoom-controls {
                position: absolute;
                bottom: 60px;
                right: 10px;
                display: flex;
                flex-direction: column;
                gap: 8px;
                z-index: 10;
            }
            
            .zoom-btn {
                width: 44px;
                height: 44px;
                border: none;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                border-radius: 50%;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .zoom-btn:hover {
                background: rgba(0, 0, 0, 0.8);
                transform: scale(1.1);
            }
            
            .zoom-indicator {
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 14px;
                z-index: 10;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .zoom-indicator.visible {
                opacity: 1;
            }
        `;
        document.head.appendChild(style);

        // Bind zoom control events
        controls.addEventListener('click', (e) => {
            const btn = e.target.closest('.zoom-btn');
            if (btn) {
                const action = btn.dataset.action;
                this.handleZoomAction(action);
            }
        });
    }

    handleZoomAction(action) {
        const chart = this.container.querySelector('canvas');
        if (!chart) return;

        let newScale = 1;
        const currentTransform = chart.style.transform;
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        switch (action) {
            case 'zoom-in':
                newScale = Math.min(currentScale * 1.2, 3);
                break;
            case 'zoom-out':
                newScale = Math.max(currentScale / 1.2, 0.5);
                break;
            case 'zoom-reset':
                newScale = 1;
                break;
        }

        chart.style.transform = `scale(${newScale})`;
        this.showZoomIndicator(newScale);
        
        setTimeout(() => {
            this.hideZoomIndicator();
        }, 1500);

        // Emit zoom event
        this.container.dispatchEvent(new CustomEvent('chartzoom', {
            detail: { scale: newScale }
        }));
    }

    showZoomIndicator(scale) {
        let indicator = this.container.querySelector('.zoom-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'zoom-indicator';
            this.container.appendChild(indicator);
        }
        
        indicator.textContent = `${Math.round(scale * 100)}%`;
        indicator.classList.add('visible');
    }

    hideZoomIndicator() {
        const indicator = this.container.querySelector('.zoom-indicator');
        if (indicator) {
            indicator.classList.remove('visible');
        }
    }

    getCenter(touch1, touch2) {
        return {
            x: (touch1.clientX + touch2.clientX) / 2,
            y: (touch1.clientY + touch2.clientY) / 2
        };
    }

    getDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
}

// ==========================================================================
// TABLE SWIPE GESTURE
// ==========================================================================

class TableSwipeGesture {
    constructor(table) {
        this.table = table;
        this.startX = 0;
        this.currentX = 0;
        this.isDragging = false;
        
        this.init();
    }

    init() {
        this.bindEvents();
        this.addTableRowActions();
    }

    bindEvents() {
        this.table.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        this.table.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.table.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });
    }

    handleTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.isDragging = false;
    }

    handleTouchMove(e) {
        if (!e.touches[0]) return;

        this.currentX = e.touches[0].clientX;
        const deltaX = this.currentX - this.startX;

        // Allow horizontal scrolling for tables
        if (Math.abs(deltaX) > 10) {
            this.isDragging = true;
            // Don't prevent default - allow native scrolling
        }
    }

    handleTouchEnd(e) {
        if (this.isDragging) {
            // Add momentum scrolling effect
            this.addMomentumScrolling();
        }
        this.isDragging = false;
    }

    addMomentumScrolling() {
        // Add CSS class for momentum scrolling
        this.table.style.webkitOverflowScrolling = 'touch';
        this.table.style.scrollBehavior = 'smooth';
        
        // Add scroll indicators
        this.addScrollIndicators();
    }

    addScrollIndicators() {
        if (this.table.querySelector('.scroll-indicator')) return;

        // Create scroll indicator container
        const indicatorContainer = document.createElement('div');
        indicatorContainer.className = 'scroll-indicator-container';
        
        const indicator = document.createElement('div');
        indicator.className = 'scroll-indicator';
        
        const leftFade = document.createElement('div');
        leftFade.className = 'scroll-fade scroll-fade-left';
        
        const rightFade = document.createElement('div');
        rightFade.className = 'scroll-fade scroll-fade-right';
        
        indicatorContainer.appendChild(indicator);
        this.table.parentNode.appendChild(indicatorContainer);
        this.table.parentNode.appendChild(leftFade);
        this.table.parentNode.appendChild(rightFade);

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .scroll-indicator-container {
                position: relative;
                height: 3px;
                background: rgba(0, 0, 0, 0.1);
                border-radius: 2px;
                margin-top: 4px;
            }
            
            .scroll-indicator {
                height: 100%;
                background: var(--color-primary);
                border-radius: 2px;
                transition: width 0.2s ease;
                width: 0%;
            }
            
            .scroll-fade {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 20px;
                pointer-events: none;
                z-index: 1;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .scroll-fade-left {
                left: 0;
                background: linear-gradient(to right, var(--bg-card), transparent);
            }
            
            .scroll-fade-right {
                right: 0;
                background: linear-gradient(to left, var(--bg-card), transparent);
            }
            
            .scroll-fade.visible {
                opacity: 1;
            }
        `;
        document.head.appendChild(style);

        // Update indicator on scroll
        this.table.addEventListener('scroll', () => {
            const scrollPercent = (this.table.scrollLeft / (this.table.scrollWidth - this.table.clientWidth)) * 100;
            indicator.style.width = `${Math.min(scrollPercent, 100)}%`;
            
            // Show/hide fade indicators
            leftFade.classList.toggle('visible', this.table.scrollLeft > 10);
            rightFade.classList.toggle('visible', 
                this.table.scrollLeft < (this.table.scrollWidth - this.table.clientWidth - 10)
            );
        }, { passive: true });

        // Initial check
        const scrollPercent = (this.table.scrollLeft / (this.table.scrollWidth - this.table.clientWidth)) * 100;
        indicator.style.width = `${Math.min(scrollPercent, 100)}%`;
        
        rightFade.classList.toggle('visible', 
            this.table.scrollWidth > this.table.clientWidth
        );
    }

    addTableRowActions() {
        // Add swipe actions to table rows on mobile
        if (window.innerWidth > 768) return;

        const rows = this.table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            this.addRowSwipeSupport(row);
        });
    }

    addRowSwipeSupport(row) {
        let startX = 0;
        let currentX = 0;
        let isDragging = false;

        row.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = false;
        }, { passive: true });

        row.addEventListener('touchmove', (e) => {
            if (!e.touches[0]) return;
            
            currentX = e.touches[0].clientX;
            const deltaX = currentX - startX;

            if (Math.abs(deltaX) > 10) {
                isDragging = true;
                e.preventDefault();

                // Show row actions on left swipe
                if (deltaX < 0) {
                    row.style.transform = `translateX(${Math.max(deltaX, -80)}px)`;
                    this.showRowActions(row);
                }
            }
        }, { passive: false });

        row.addEventListener('touchend', () => {
            if (isDragging) {
                const deltaX = currentX - startX;
                
                if (deltaX < -40) {
                    // Keep actions visible
                    row.style.transform = 'translateX(-80px)';
                } else {
                    // Hide actions
                    row.style.transform = '';
                    this.hideRowActions(row);
                }
            }
            isDragging = false;
        }, { passive: true });
    }

    showRowActions(row) {
        if (row.querySelector('.row-actions')) return;

        const actions = document.createElement('div');
        actions.className = 'row-actions';
        actions.innerHTML = `
            <button class="action-btn view-btn" data-action="view">
                <i class="fas fa-eye"></i>
            </button>
            <button class="action-btn edit-btn" data-action="edit">
                <i class="fas fa-edit"></i>
            </button>
        `;
        
        row.appendChild(actions);

        // Bind action events
        actions.addEventListener('click', (e) => {
            const btn = e.target.closest('.action-btn');
            if (btn) {
                const action = btn.dataset.action;
                this.handleRowAction(row, action);
            }
        });
    }

    hideRowActions(row) {
        const actions = row.querySelector('.row-actions');
        if (actions) {
            actions.remove();
        }
    }

    handleRowAction(row, action) {
        // Emit custom event for row actions
        row.dispatchEvent(new CustomEvent('rowaction', {
            detail: { action, row },
            bubbles: true
        }));
        
        // Hide actions after action
        this.hideRowActions(row);
        row.style.transform = '';
    }
}

// ==========================================================================
// WATCHLIST SWIPE GESTURE
// ==========================================================================

class WatchlistSwipeGesture {
    constructor(item) {
        this.item = item;
        this.startX = 0;
        this.currentX = 0;
        this.isDragging = false;
        this.threshold = 80;
        
        this.init();
    }

    init() {
        this.createSwipeActions();
        this.bindEvents();
    }

    createSwipeActions() {
        if (this.item.querySelector('.swipe-actions')) return;

        const actions = document.createElement('div');
        actions.className = 'swipe-actions';
        actions.innerHTML = `
            <button class="action-btn delete-btn touch-target" data-action="remove">
                <i class="fas fa-trash"></i>
            </button>
            <button class="action-btn trade-btn touch-target" data-action="trade">
                <i class="fas fa-chart-line"></i>
            </button>
        `;
        
        this.item.appendChild(actions);
        
        // Bind action events
        actions.addEventListener('click', (e) => {
            const btn = e.target.closest('.action-btn');
            if (btn) {
                const action = btn.dataset.action;
                this.handleAction(action);
            }
        });
    }

    bindEvents() {
        this.item.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        this.item.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.item.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });
    }

    handleTouchStart(e) {
        this.startX = e.touches[0].clientX;
        this.isDragging = false;
    }

    handleTouchMove(e) {
        if (!e.touches[0]) return;

        this.currentX = e.touches[0].clientX;
        const deltaX = this.currentX - this.startX;

        if (Math.abs(deltaX) > 10) {
            this.isDragging = true;
            e.preventDefault();

            // Only allow left swipe to reveal actions
            if (deltaX < 0) {
                const progress = Math.min(Math.abs(deltaX) / this.threshold, 1);
                this.item.style.transform = `translateX(${deltaX}px)`;
                
                const actions = this.item.querySelector('.swipe-actions');
                if (actions) {
                    actions.style.opacity = progress;
                }
            }
        }
    }

    handleTouchEnd(e) {
        if (!this.isDragging) return;

        const deltaX = this.currentX - this.startX;
        const actions = this.item.querySelector('.swipe-actions');

        if (deltaX < -this.threshold) {
            // Show actions
            this.item.style.transform = `translateX(-${this.threshold}px)`;
            if (actions) {
                actions.classList.add('visible');
                actions.style.opacity = '1';
            }
        } else {
            // Hide actions
            this.hideActions();
        }

        this.isDragging = false;
    }

    hideActions() {
        this.item.style.transform = '';
        const actions = this.item.querySelector('.swipe-actions');
        if (actions) {
            actions.classList.remove('visible');
            actions.style.opacity = '0';
        }
    }

    handleAction(action) {
        const symbol = this.item.dataset.symbol || this.item.querySelector('.stock-symbol')?.textContent;
        
        switch (action) {
            case 'remove':
                this.removeFromWatchlist(symbol);
                break;
            case 'trade':
                this.openTradeModal(symbol);
                break;
        }
        
        this.hideActions();
    }

    removeFromWatchlist(symbol) {
        // Emit custom event
        this.item.dispatchEvent(new CustomEvent('removestock', {
            detail: { symbol },
            bubbles: true
        }));
    }

    openTradeModal(symbol) {
        // Emit custom event
        this.item.dispatchEvent(new CustomEvent('tradestock', {
            detail: { symbol },
            bubbles: true
        }));
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    new SwipeGestureManager();
});

// Export for use in other modules
window.SwipeGestureManager = SwipeGestureManager;
window.ChartSwipeGesture = ChartSwipeGesture;
window.TableSwipeGesture = TableSwipeGesture;
window.WatchlistSwipeGesture = WatchlistSwipeGesture;
            
// ==========================================================================
// MOBILE PERFORMANCE - Performance optimizations for mobile devices
// ==========================================================================

class MobilePerformanceOptimizer {
    constructor() {
        this.isMobile = this.detectMobile();
        this.isLowEndDevice = this.detectLowEndDevice();
        this.connectionType = this.getConnectionType();
        this.lazyLoadObserver = null;
        this.intersectionObserver = null;
        
        this.init();
    }

    init() {
        if (this.isMobile) {
            this.setupLazyLoading();
            this.optimizeScrolling();
            this.setupImageOptimization();
            this.setupResourceHints();
            this.setupServiceWorker();
            this.handleOrientationChange();
            this.optimizeTouchInteractions();
            this.setupMemoryManagement();
        }
    }

    detectMobile() {
        return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
               window.innerWidth <= 768;
    }

    detectLowEndDevice() {
        // Detect low-end devices based on hardware capabilities
        const memory = navigator.deviceMemory || 4; // Default to 4GB if not available
        const cores = navigator.hardwareConcurrency || 4; // Default to 4 cores
        const connection = navigator.connection;
        
        return memory <= 2 || cores <= 2 || 
               (connection && (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g'));
    }

    getConnectionType() {
        const connection = navigator.connection;
        if (connection) {
            return connection.effectiveType;
        }
        return 'unknown';
    }

    setupLazyLoading() {
        // Lazy load images
        this.lazyLoadObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                        this.lazyLoadObserver.unobserve(img);
                    }
                }
            });
        }, {
            rootMargin: '50px 0px',
            threshold: 0.01
        });

        // Observe all images with data-src
        document.querySelectorAll('img[data-src]').forEach(img => {
            this.lazyLoadObserver.observe(img);
        });

        // Lazy load non-critical components
        this.setupComponentLazyLoading();
    }

    setupComponentLazyLoading() {
        // Lazy load charts
        this.intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const element = entry.target;
                    
                    if (element.classList.contains('chart-container') && !element.dataset.loaded) {
                        this.loadChart(element);
                    }
                    
                    if (element.classList.contains('table-container') && !element.dataset.loaded) {
                        this.loadTable(element);
                    }
                    
                    if (element.classList.contains('lottie-container') && !element.dataset.loaded) {
                        this.loadLottieAnimation(element);
                    }
                }
            });
        }, {
            rootMargin: '100px 0px',
            threshold: 0.1
        });

        // Observe lazy-loadable components
        document.querySelectorAll('.chart-container, .table-container, .lottie-container').forEach(el => {
            if (!el.dataset.loaded) {
                this.intersectionObserver.observe(el);
            }
        });
    }

    loadChart(container) {
        container.dataset.loaded = 'true';
        
        // Add loading indicator
        const loader = document.createElement('div');
        loader.className = 'chart-loader';
        loader.innerHTML = `
            <div class="loading-spinner">
                <div class="spinner"></div>
                <span>Loading chart...</span>
            </div>
        `;
        container.appendChild(loader);

        // Simulate chart loading (replace with actual chart initialization)
        setTimeout(() => {
            loader.remove();
            // Initialize chart here
            if (window.initializeChart) {
                window.initializeChart(container);
            }
        }, 500);

        this.intersectionObserver.unobserve(container);
    }

    loadTable(container) {
        container.dataset.loaded = 'true';
        
        // Load table data progressively
        const rows = container.querySelectorAll('tr[data-lazy]');
        const batchSize = this.isLowEndDevice ? 10 : 20;
        
        this.loadTableBatch(rows, 0, batchSize);
        this.intersectionObserver.unobserve(container);
    }

    loadTableBatch(rows, startIndex, batchSize) {
        const endIndex = Math.min(startIndex + batchSize, rows.length);
        
        for (let i = startIndex; i < endIndex; i++) {
            const row = rows[i];
            row.style.display = '';
            row.removeAttribute('data-lazy');
        }

        if (endIndex < rows.length) {
            // Load next batch after a short delay
            setTimeout(() => {
                this.loadTableBatch(rows, endIndex, batchSize);
            }, 50);
        }
    }

    loadLottieAnimation(container) {
        container.dataset.loaded = 'true';
        
        // Load Lottie animation only when needed
        if (window.lottie && container.dataset.animationPath) {
            const animation = window.lottie.loadAnimation({
                container: container,
                renderer: 'svg',
                loop: container.dataset.loop === 'true',
                autoplay: container.dataset.autoplay === 'true',
                path: container.dataset.animationPath
            });
            
            container.lottieAnimation = animation;
        }

        this.intersectionObserver.unobserve(container);
    }

    optimizeScrolling() {
        // Enable momentum scrolling on iOS
        const scrollableElements = document.querySelectorAll(
            '.modal-body, .table-container, .chart-container, .sidebar-content'
        );
        
        scrollableElements.forEach(element => {
            element.style.webkitOverflowScrolling = 'touch';
            element.style.scrollBehavior = 'smooth';
        });

        // Throttle scroll events
        let scrollTimeout;
        const handleScroll = () => {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            scrollTimeout = setTimeout(() => {
                // Handle scroll-based optimizations
                this.handleScrollOptimizations();
            }, 16); // ~60fps
        };

        window.addEventListener('scroll', handleScroll, { passive: true });
    }

    handleScrollOptimizations() {
        // Hide/show elements based on scroll position to improve performance
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        
        // Hide elements that are far off-screen
        document.querySelectorAll('.summary-card, .dashboard-section').forEach(element => {
            const rect = element.getBoundingClientRect();
            const isVisible = rect.bottom >= -windowHeight && rect.top <= windowHeight * 2;
            
            if (!isVisible && !element.dataset.hidden) {
                element.style.visibility = 'hidden';
                element.dataset.hidden = 'true';
            } else if (isVisible && element.dataset.hidden) {
                element.style.visibility = 'visible';
                delete element.dataset.hidden;
            }
        });
    }

    setupImageOptimization() {
        // Convert images to WebP if supported
        const supportsWebP = this.checkWebPSupport();
        
        if (supportsWebP) {
            document.querySelectorAll('img[data-webp]').forEach(img => {
                img.src = img.dataset.webp;
            });
        }

        // Optimize image loading based on connection
        if (this.connectionType === 'slow-2g' || this.connectionType === '2g') {
            this.loadLowQualityImages();
        }
    }

    checkWebPSupport() {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    }

    loadLowQualityImages() {
        document.querySelectorAll('img[data-low-quality]').forEach(img => {
            img.src = img.dataset.lowQuality;
        });
    }

    setupResourceHints() {
        // Preload critical resources
        const criticalResources = [
            '/css/site.css',
            '/js/site.min.js'
        ];

        criticalResources.forEach(resource => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.href = resource;
            link.as = resource.endsWith('.css') ? 'style' : 'script';
            document.head.appendChild(link);
        });

        // Prefetch likely next pages
        const prefetchPages = [
            '/Home/Leaderboard',
            '/Home/Competition'
        ];

        prefetchPages.forEach(page => {
            const link = document.createElement('link');
            link.rel = 'prefetch';
            link.href = page;
            document.head.appendChild(link);
        });
    }

    setupServiceWorker() {
        if ('serviceWorker' in navigator && !this.isLowEndDevice) {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => {
                    console.log('ServiceWorker registered:', registration);
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed:', error);
                });
        }
    }

    handleOrientationChange() {
        let orientationTimeout;
        
        window.addEventListener('orientationchange', () => {
            // Clear any existing timeout
            if (orientationTimeout) {
                clearTimeout(orientationTimeout);
            }
            
            // Debounce orientation change handling
            orientationTimeout = setTimeout(() => {
                this.optimizeForOrientation();
            }, 200);
        });
    }

    optimizeForOrientation() {
        const isLandscape = window.orientation === 90 || window.orientation === -90;
        
        // Adjust layouts for orientation
        document.body.classList.toggle('landscape', isLandscape);
        document.body.classList.toggle('portrait', !isLandscape);
        
        // Resize charts and tables
        this.resizeComponents();
        
        // Trigger window resize for other components
        window.dispatchEvent(new Event('resize'));
    }

    resizeComponents() {
        // Resize charts
        document.querySelectorAll('.chart-container canvas').forEach(canvas => {
            if (canvas.chart && canvas.chart.resize) {
                canvas.chart.resize();
            }
        });

        // Recalculate table layouts
        document.querySelectorAll('.table-responsive').forEach(table => {
            // Force reflow
            table.style.display = 'none';
            table.offsetHeight; // Trigger reflow
            table.style.display = '';
        });
    }

    optimizeTouchInteractions() {
        // Reduce touch delay
        document.addEventListener('touchstart', () => {}, { passive: true });
        
        // Optimize touch event handling
        const touchElements = document.querySelectorAll('button, .btn, .nav-link, .card-clickable');
        
        touchElements.forEach(element => {
            // Add touch-action CSS property
            element.style.touchAction = 'manipulation';
            
            // Optimize touch feedback
            element.addEventListener('touchstart', (e) => {
                element.classList.add('touch-active');
            }, { passive: true });
            
            element.addEventListener('touchend', (e) => {
                setTimeout(() => {
                    element.classList.remove('touch-active');
                }, 150);
            }, { passive: true });
            
            element.addEventListener('touchcancel', (e) => {
                element.classList.remove('touch-active');
            }, { passive: true });
        });
    }

    setupMemoryManagement() {
        // Monitor memory usage
        if (navigator.deviceMemory && navigator.deviceMemory <= 2) {
            this.enableLowMemoryMode();
        }

        // Clean up unused resources periodically
        setInterval(() => {
            this.cleanupResources();
        }, 30000); // Every 30 seconds

        // Handle memory pressure
        if ('memory' in performance) {
            setInterval(() => {
                const memInfo = performance.memory;
                const memoryUsage = memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;
                
                if (memoryUsage > 0.8) {
                    this.handleMemoryPressure();
                }
            }, 10000); // Every 10 seconds
        }
    }

    enableLowMemoryMode() {
        // Reduce animation complexity
        document.body.classList.add('low-memory-mode');
        
        // Disable non-essential animations
        document.querySelectorAll('.lottie-container').forEach(container => {
            if (container.lottieAnimation) {
                container.lottieAnimation.destroy();
            }
        });
        
        // Reduce chart update frequency
        if (window.chartUpdateInterval) {
            clearInterval(window.chartUpdateInterval);
            window.chartUpdateInterval = setInterval(window.updateCharts, 10000); // 10s instead of 5s
        }
    }

    handleMemoryPressure() {
        // Force garbage collection if available
        if (window.gc) {
            window.gc();
        }
        
        // Clear caches
        this.clearCaches();
        
        // Reduce active components
        this.reduceActiveComponents();
    }

    clearCaches() {
        // Clear image caches
        document.querySelectorAll('img').forEach(img => {
            if (!this.isElementVisible(img)) {
                img.src = '';
            }
        });
        
        // Clear chart data caches
        if (window.chartDataCache) {
            window.chartDataCache.clear();
        }
    }

    reduceActiveComponents() {
        // Pause non-visible animations
        document.querySelectorAll('.lottie-container').forEach(container => {
            if (!this.isElementVisible(container) && container.lottieAnimation) {
                container.lottieAnimation.pause();
            }
        });
        
        // Reduce table row count
        document.querySelectorAll('.table tbody tr').forEach((row, index) => {
            if (index > 50 && !this.isElementVisible(row)) {
                row.style.display = 'none';
            }
        });
    }

    cleanupResources() {
        // Remove unused event listeners
        this.cleanupEventListeners();
        
        // Clear unused DOM elements
        this.cleanupDOMElements();
        
        // Clear expired data
        this.clearExpiredData();
    }

    cleanupEventListeners() {
        // Remove listeners from elements that are no longer in the DOM
        // This is handled automatically by modern browsers, but we can help
        document.querySelectorAll('[data-cleanup-listeners]').forEach(element => {
            if (!document.contains(element)) {
                element.removeEventListener('click', element._clickHandler);
                element.removeEventListener('touchstart', element._touchHandler);
            }
        });
    }

    cleanupDOMElements() {
        // Remove hidden elements that are no longer needed
        document.querySelectorAll('[data-temporary]').forEach(element => {
            const created = parseInt(element.dataset.created);
            if (Date.now() - created > 300000) { // 5 minutes
                element.remove();
            }
        });
    }

    clearExpiredData() {
        // Clear expired localStorage data
        for (let i = localStorage.length - 1; i >= 0; i--) {
            const key = localStorage.key(i);
            if (key && key.startsWith('cache_')) {
                try {
                    const data = JSON.parse(localStorage.getItem(key));
                    if (data.expires && Date.now() > data.expires) {
                        localStorage.removeItem(key);
                    }
                } catch (e) {
                    localStorage.removeItem(key);
                }
            }
        }
    }

    isElementVisible(element) {
        const rect = element.getBoundingClientRect();
        return rect.bottom >= 0 && rect.top <= window.innerHeight;
    }

    // Public methods for external use
    pauseNonCriticalAnimations() {
        document.querySelectorAll('.lottie-container').forEach(container => {
            if (container.lottieAnimation && !this.isElementVisible(container)) {
                container.lottieAnimation.pause();
            }
        });
    }

    resumeAnimations() {
        document.querySelectorAll('.lottie-container').forEach(container => {
            if (container.lottieAnimation && this.isElementVisible(container)) {
                container.lottieAnimation.play();
            }
        });
    }

    optimizeForBattery() {
        // Reduce update frequencies when battery is low
        if ('getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                if (battery.level < 0.2) { // Less than 20%
                    this.enableBatterySaveMode();
                }
                
                battery.addEventListener('levelchange', () => {
                    if (battery.level < 0.2) {
                        this.enableBatterySaveMode();
                    } else {
                        this.disableBatterySaveMode();
                    }
                });
            });
        }
    }

    enableBatterySaveMode() {
        document.body.classList.add('battery-save-mode');
        
        // Reduce animation frame rate
        this.pauseNonCriticalAnimations();
        
        // Increase update intervals
        if (window.dataUpdateInterval) {
            clearInterval(window.dataUpdateInterval);
            window.dataUpdateInterval = setInterval(window.updateData, 15000); // 15s instead of 5s
        }
    }

    disableBatterySaveMode() {
        document.body.classList.remove('battery-save-mode');
        
        // Resume normal operation
        this.resumeAnimations();
        
        // Restore normal update intervals
        if (window.dataUpdateInterval) {
            clearInterval(window.dataUpdateInterval);
            window.dataUpdateInterval = setInterval(window.updateData, 5000); // Back to 5s
        }
    }
}

// ==========================================================================
// MOBILE-SPECIFIC LAYOUT OPTIMIZATIONS
// ==========================================================================

class MobileLayoutOptimizer {
    constructor() {
        this.init();
    }

    init() {
        this.setupMobileSpecificLayouts();
        this.optimizeTableLayouts();
        this.setupAdaptiveLayouts();
    }

    setupMobileSpecificLayouts() {
        if (window.innerWidth <= 768) {
            // Convert complex tables to card layouts
            this.convertTablesToCards();
            
            // Optimize modal layouts
            this.optimizeModalLayouts();
            
            // Setup bottom sheet alternatives
            this.setupBottomSheets();
        }
    }

    convertTablesToCards() {
        document.querySelectorAll('.table-mobile').forEach(table => {
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            const rows = tbody.querySelectorAll('tr');
            const headers = table.querySelectorAll('thead th');
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                
                // Create card structure
                const card = document.createElement('div');
                card.className = 'mobile-table-card';
                
                cells.forEach((cell, index) => {
                    const cardRow = document.createElement('div');
                    cardRow.className = 'card-row';
                    
                    const label = document.createElement('span');
                    label.className = 'card-label';
                    label.textContent = headers[index]?.textContent || '';
                    
                    const value = document.createElement('span');
                    value.className = 'card-value';
                    value.innerHTML = cell.innerHTML;
                    
                    cardRow.appendChild(label);
                    cardRow.appendChild(value);
                    card.appendChild(cardRow);
                });
                
                row.parentNode.insertBefore(card, row);
                row.style.display = 'none';
            });
        });
    }

    optimizeModalLayouts() {
        document.querySelectorAll('.modal').forEach(modal => {
            const dialog = modal.querySelector('.modal-dialog');
            if (dialog && !dialog.classList.contains('modal-fullscreen')) {
                dialog.classList.add('modal-fullscreen-sm-down');
            }
        });
    }

    setupBottomSheets() {
        // Convert certain modals to bottom sheets on mobile
        document.querySelectorAll('.modal[data-mobile="bottom-sheet"]').forEach(modal => {
            modal.classList.add('bottom-sheet-modal');
        });
    }

    optimizeTableLayouts() {
        // Add horizontal scrolling for wide tables
        document.querySelectorAll('table').forEach(table => {
            if (!table.closest('.table-responsive')) {
                const wrapper = document.createElement('div');
                wrapper.className = 'table-responsive';
                table.parentNode.insertBefore(wrapper, table);
                wrapper.appendChild(table);
            }
        });
    }

    setupAdaptiveLayouts() {
        // Handle dynamic layout changes based on screen size
        const mediaQuery = window.matchMedia('(max-width: 768px)');
        
        const handleLayoutChange = (e) => {
            if (e.matches) {
                this.enableMobileLayout();
            } else {
                this.enableDesktopLayout();
            }
        };
        
        mediaQuery.addListener(handleLayoutChange);
        handleLayoutChange(mediaQuery);
    }

    enableMobileLayout() {
        document.body.classList.add('mobile-layout');
        document.body.classList.remove('desktop-layout');
        
        // Adjust grid layouts
        document.querySelectorAll('.row').forEach(row => {
            row.classList.add('mobile-stack');
        });
    }

    enableDesktopLayout() {
        document.body.classList.add('desktop-layout');
        document.body.classList.remove('mobile-layout');
        
        // Restore grid layouts
        document.querySelectorAll('.row').forEach(row => {
            row.classList.remove('mobile-stack');
        });
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize mobile performance optimizer
    window.mobilePerformanceOptimizer = new MobilePerformanceOptimizer();
    
    // Initialize mobile layout optimizer
    window.mobileLayoutOptimizer = new MobileLayoutOptimizer();
    
    // Setup battery optimization
    if (window.mobilePerformanceOptimizer.isMobile) {
        window.mobilePerformanceOptimizer.optimizeForBattery();
    }
});

// Export for use in other modules
window.MobilePerformanceOptimizer = MobilePerformanceOptimizer;
window.MobileLayoutOptimizer = MobileLayoutOptimizer;
// ==========================================================================
// ORIENTATION HANDLER - Handle orientation changes and adaptive layouts
// ==========================================================================

class OrientationHandler {
    constructor() {
        this.currentOrientation = this.getOrientation();
        this.isTransitioning = false;
        this.transitionTimeout = null;
        
        this.init();
    }

    init() {
        this.bindEvents();
        this.applyInitialClasses();
        this.setupViewportHeightFix();
    }

    bindEvents() {
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            this.handleOrientationChange();
        });

        // Handle resize as fallback
        window.addEventListener('resize', () => {
            this.handleResize();
        });

        // Handle visual viewport changes (for keyboard)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                this.handleViewportResize();
            });
        }

        // Handle device motion for better orientation detection
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => {
                this.handleDeviceOrientation(e);
            });
        }
    }

    getOrientation() {
        // Use screen.orientation if available
        if (screen.orientation) {
            return screen.orientation.angle;
        }
        
        // Fallback to window.orientation
        if (window.orientation !== undefined) {
            return window.orientation;
        }
        
        // Fallback to aspect ratio
        return window.innerWidth > window.innerHeight ? 90 : 0;
    }

    isPortrait() {
        const orientation = this.getOrientation();
        return orientation === 0 || orientation === 180;
    }

    isLandscape() {
        const orientation = this.getOrientation();
        return orientation === 90 || orientation === -90;
    }

    handleOrientationChange() {
        if (this.isTransitioning) return;
        
        this.isTransitioning = true;
        
        // Add transition class
        document.body.classList.add('orientation-transition');
        
        // Clear any existing timeout
        if (this.transitionTimeout) {
            clearTimeout(this.transitionTimeout);
        }
        
        // Wait for orientation to stabilize
        this.transitionTimeout = setTimeout(() => {
            this.updateOrientation();
        }, 100);
    }

    handleResize() {
        // Debounce resize events
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
        }
        
        this.resizeTimeout = setTimeout(() => {
            const newOrientation = this.getOrientation();
            if (newOrientation !== this.currentOrientation) {
                this.updateOrientation();
            }
        }, 150);
    }

    handleViewportResize() {
        // Handle keyboard show/hide
        const viewport = window.visualViewport;
        const isKeyboardOpen = viewport.height < window.innerHeight * 0.75;
        
        document.body.classList.toggle('keyboard-open', isKeyboardOpen);
        
        // Adjust elements for keyboard
        if (isKeyboardOpen) {
            this.adjustForKeyboard();
        } else {
            this.restoreFromKeyboard();
        }
    }

    handleDeviceOrientation(event) {
        // Use device orientation for more accurate detection
        const { alpha, beta, gamma } = event;
        
        // Determine orientation based on device tilt
        let orientation;
        if (Math.abs(gamma) > Math.abs(beta)) {
            orientation = gamma > 0 ? 90 : -90;
        } else {
            orientation = beta > 0 ? 180 : 0;
        }
        
        if (orientation !== this.currentOrientation) {
            this.currentOrientation = orientation;
            this.updateOrientationClasses();
        }
    }

    updateOrientation() {
        const newOrientation = this.getOrientation();
        
        if (newOrientation !== this.currentOrientation) {
            this.currentOrientation = newOrientation;
            this.updateOrientationClasses();
        }
        
        // Update viewport height
        this.updateViewportHeight();
        
        // Notify components of orientation change
        this.notifyComponents();
        
        // Remove transition class after animation
        setTimeout(() => {
            document.body.classList.remove('orientation-transition');
            this.isTransitioning = false;
        }, 300);
    }

    updateOrientationClasses() {
        const body = document.body;
        
        // Remove existing orientation classes
        body.classList.remove('portrait', 'landscape', 'landscape-left', 'landscape-right');
        
        // Add new orientation classes
        if (this.isPortrait()) {
            body.classList.add('portrait');
        } else if (this.isLandscape()) {
            body.classList.add('landscape');
            
            // Add specific landscape direction
            if (this.currentOrientation === 90) {
                body.classList.add('landscape-left');
            } else if (this.currentOrientation === -90) {
                body.classList.add('landscape-right');
            }
        }
        
        // Add device-specific classes
        this.addDeviceSpecificClasses();
    }

    addDeviceSpecificClasses() {
        const body = document.body;
        const { innerWidth, innerHeight } = window;
        
        // Small screen detection
        if (innerHeight <= 667 && innerWidth <= 375) {
            body.classList.add('small-screen-optimize');
        } else {
            body.classList.remove('small-screen-optimize');
        }
        
        // Tall screen detection
        if (innerHeight >= 800) {
            body.classList.add('tall-screen-optimize');
        } else {
            body.classList.remove('tall-screen-optimize');
        }
        
        // Foldable device detection
        if (window.screen && window.screen.isExtended) {
            body.classList.add('foldable-device');
        }
    }

    applyInitialClasses() {
        this.updateOrientationClasses();
        
        // Add adaptive classes to components
        this.addAdaptiveClasses();
    }

    addAdaptiveClasses() {
        // Add classes to tables
        document.querySelectorAll('table, .table-container').forEach(element => {
            element.classList.add('table-orientation-adaptive');
        });
        
        // Add classes to forms
        document.querySelectorAll('form, .form-container').forEach(element => {
            element.classList.add('form-orientation-adaptive');
        });
        
        // Add classes to charts
        document.querySelectorAll('.chart-container').forEach(element => {
            element.classList.add('chart-orientation-adaptive');
        });
        
        // Add classes to notifications
        document.querySelectorAll('.toast, .alert').forEach(element => {
            element.classList.add('notification-orientation-adaptive');
        });
    }

    setupViewportHeightFix() {
        // Fix for mobile browsers that change viewport height
        const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        };
        
        setViewportHeight();
        window.addEventListener('resize', setViewportHeight);
    }

    updateViewportHeight() {
        // Update CSS custom property for viewport height
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        
        // Update elements that use viewport height
        document.querySelectorAll('.viewport-height-adaptive').forEach(element => {
            element.style.height = `${window.innerHeight}px`;
        });
    }

    adjustForKeyboard() {
        // Adjust modals for keyboard
        document.querySelectorAll('.modal.show').forEach(modal => {
            const modalBody = modal.querySelector('.modal-body');
            if (modalBody) {
                modalBody.style.paddingBottom = '50vh';
            }
        });
        
        // Adjust bottom sheets
        document.querySelectorAll('.bottom-sheet.active').forEach(sheet => {
            sheet.style.transform = 'translateY(-30vh)';
        });
        
        // Adjust FAB
        document.querySelectorAll('.fab').forEach(fab => {
            fab.style.bottom = '60vh';
        });
    }

    restoreFromKeyboard() {
        // Restore modal padding
        document.querySelectorAll('.modal .modal-body').forEach(modalBody => {
            modalBody.style.paddingBottom = '';
        });
        
        // Restore bottom sheets
        document.querySelectorAll('.bottom-sheet').forEach(sheet => {
            sheet.style.transform = '';
        });
        
        // Restore FAB
        document.querySelectorAll('.fab').forEach(fab => {
            fab.style.bottom = '';
        });
    }

    notifyComponents() {
        // Notify charts to resize
        window.dispatchEvent(new Event('resize'));
        
        // Notify custom components
        document.dispatchEvent(new CustomEvent('orientationchange', {
            detail: {
                orientation: this.currentOrientation,
                isPortrait: this.isPortrait(),
                isLandscape: this.isLandscape()
            }
        }));
        
        // Resize charts specifically
        this.resizeCharts();
        
        // Recalculate table layouts
        this.recalculateTableLayouts();
        
        // Update modal layouts
        this.updateModalLayouts();
    }

    resizeCharts() {
        // Resize Chart.js charts
        if (window.Chart) {
            Object.values(window.Chart.instances).forEach(chart => {
                if (chart && chart.resize) {
                    setTimeout(() => chart.resize(), 100);
                }
            });
        }
        
        // Resize custom charts
        document.querySelectorAll('canvas[data-chart]').forEach(canvas => {
            if (canvas.chart && canvas.chart.resize) {
                setTimeout(() => canvas.chart.resize(), 100);
            }
        });
    }

    recalculateTableLayouts() {
        // Force table reflow
        document.querySelectorAll('.table-responsive').forEach(container => {
            const display = container.style.display;
            container.style.display = 'none';
            container.offsetHeight; // Trigger reflow
            container.style.display = display;
        });
        
        // Update mobile table cards
        if (window.innerWidth <= 768) {
            document.querySelectorAll('.mobile-table-card').forEach(card => {
                card.classList.add('orientation-animate');
                setTimeout(() => {
                    card.classList.remove('orientation-animate');
                }, 300);
            });
        }
    }

    updateModalLayouts() {
        // Update modal sizes and positions
        document.querySelectorAll('.modal.show').forEach(modal => {
            const dialog = modal.querySelector('.modal-dialog');
            if (dialog) {
                // Force recalculation
                dialog.style.transform = 'none';
                dialog.offsetHeight; // Trigger reflow
                dialog.style.transform = '';
            }
        });
    }

    // Public methods
    getCurrentOrientation() {
        return this.currentOrientation;
    }

    isCurrentlyPortrait() {
        return this.isPortrait();
    }

    isCurrentlyLandscape() {
        return this.isLandscape();
    }

    forceUpdate() {
        this.updateOrientation();
    }
}

// ==========================================================================
// INITIALIZATION
// ==========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize orientation handler
    window.orientationHandler = new OrientationHandler();
});

// Export for use in other modules
window.OrientationHandler = OrientationHandler;
// ==========================================================================
// MODERN APP - Main application JavaScript
// ==========================================================================

class ModernApp {
    constructor() {
        this.init();
    }

    init() {
        this.initializeComponents();
        this.setupEventListeners();
        this.initializeAnimations();
        this.setupTheme();
    }

    initializeComponents() {
        // Initialize AOS (Animate On Scroll)
        if (typeof AOS !== 'undefined') {
            AOS.init({
                duration: 600,
                easing: 'ease-in-out',
                once: true,
                mirror: false
            });
        }

        // Initialize tooltips
        this.initializeTooltips();

        // Initialize modals
        this.initializeModals();

        // Initialize dropdowns
        this.initializeDropdowns();

        // Initialize sidebar
        this.initializeSidebar();

        // Initialize search
        this.initializeSearch();

        // Initialize notifications
        this.initializeNotifications();
    }

    initializeTooltips() {
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
    }

    initializeModals() {
        // Auto-initialize modals with enhanced features
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('show.bs.modal', (e) => {
                // Add fade-in animation
                modal.classList.add('animate-fade-in');
            });

            modal.addEventListener('hidden.bs.modal', (e) => {
                // Clean up animations
                modal.classList.remove('animate-fade-in');
            });
        });
    }

    initializeDropdowns() {
        // Enhanced dropdown functionality
        document.querySelectorAll('.dropdown-toggle').forEach(dropdown => {
            dropdown.addEventListener('click', (e) => {
                e.preventDefault();
                const menu = dropdown.nextElementSibling;
                if (menu && menu.classList.contains('dropdown-menu')) {
                    menu.classList.toggle('show');
                }
            });
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });
    }

    initializeSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const sidebarToggle = document.querySelector('.sidebar-toggle');
        const sidebarOverlay = document.querySelector('.sidebar-overlay');

        if (sidebarToggle) {
            sidebarToggle.addEventListener('click', () => {
                this.toggleSidebar();
            });
        }

        if (sidebarOverlay) {
            sidebarOverlay.addEventListener('click', () => {
                this.closeSidebar();
            });
        }

        // Handle responsive sidebar
        this.handleResponsiveSidebar();
    }

    toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');

        if (sidebar) {
            sidebar.classList.toggle('show');
            if (overlay) {
                overlay.classList.toggle('show');
            }
        }
    }

    closeSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');

        if (sidebar) {
            sidebar.classList.remove('show');
            if (overlay) {
                overlay.classList.remove('show');
            }
        }
    }

    handleResponsiveSidebar() {
        const mediaQuery = window.matchMedia('(max-width: 991.98px)');
        
        const handleMediaChange = (e) => {
            if (!e.matches) {
                // Desktop view - close mobile sidebar
                this.closeSidebar();
            }
        };

        mediaQuery.addListener(handleMediaChange);
        handleMediaChange(mediaQuery);
    }

    initializeSearch() {
        const searchInputs = document.querySelectorAll('.search-input');
        
        searchInputs.forEach(input => {
            let searchTimeout;
            
            input.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    this.performSearch(e.target.value);
                }, 300);
            });

            input.addEventListener('focus', () => {
                const results = input.parentElement.querySelector('.search-results');
                if (results && input.value.length > 0) {
                    results.style.display = 'block';
                }
            });

            input.addEventListener('blur', () => {
                // Delay hiding to allow clicking on results
                setTimeout(() => {
                    const results = input.parentElement.querySelector('.search-results');
                    if (results) {
                        results.style.display = 'none';
                    }
                }, 200);
            });
        });
    }

    performSearch(query) {
        if (query.length < 2) return;

        // Implement search logic here
        console.log('Searching for:', query);
        
        // Example: Show loading state
        this.showSearchLoading();
        
        // Example: Simulate API call
        setTimeout(() => {
            this.showSearchResults([
                { symbol: 'AAPL', name: 'Apple Inc.', price: '$150.25' },
                { symbol: 'GOOGL', name: 'Alphabet Inc.', price: '$2,750.80' }
            ]);
        }, 500);
    }

    showSearchLoading() {
        const results = document.querySelector('.search-results');
        if (results) {
            results.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><span>Searching...</span></div>';
            results.style.display = 'block';
        }
    }

    showSearchResults(results) {
        const resultsContainer = document.querySelector('.search-results');
        if (!resultsContainer) return;

        if (results.length === 0) {
            resultsContainer.innerHTML = '<div class="no-results">No stocks found</div>';
        } else {
            const html = results.map(result => `
                <div class="search-result-item" data-symbol="${result.symbol}">
                    <span class="result-symbol">${result.symbol}</span>
                    <span class="result-name">${result.name}</span>
                    <span class="result-price">${result.price}</span>
                </div>
            `).join('');
            resultsContainer.innerHTML = html;
        }

        resultsContainer.style.display = 'block';
    }

    initializeNotifications() {
        // Initialize notification system
        window.NotificationManager = new NotificationManager();
    }

    initializeAnimations() {
        // Add stagger animations to lists
        document.querySelectorAll('.stagger-animation').forEach(container => {
            const items = container.children;
            Array.from(items).forEach((item, index) => {
                item.style.animationDelay = `${index * 0.1}s`;
            });
        });

        // Add intersection observer for animations
        this.setupIntersectionObserver();
    }

    setupIntersectionObserver() {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate-slide-up');
                }
            });
        }, {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        });

        document.querySelectorAll('.animate-on-scroll').forEach(el => {
            observer.observe(el);
        });
    }

    setupTheme() {
        // Theme switching functionality
        const themeToggle = document.querySelector('.theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                this.toggleTheme();
            });
        }

        // Load saved theme
        this.loadTheme();
    }

    toggleTheme() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        
        // Update theme toggle icon
        this.updateThemeToggleIcon(newTheme);
    }

    loadTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        this.updateThemeToggleIcon(savedTheme);
    }

    updateThemeToggleIcon(theme) {
        const themeToggle = document.querySelector('.theme-toggle i');
        if (themeToggle) {
            themeToggle.className = theme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
        }
    }

    setupEventListeners() {
        // Global event listeners
        document.addEventListener('DOMContentLoaded', () => {
            this.handlePageLoad();
        });

        window.addEventListener('resize', () => {
            this.handleResize();
        });

        // Handle form submissions
        document.addEventListener('submit', (e) => {
            if (e.target.classList.contains('ajax-form')) {
                e.preventDefault();
                this.handleAjaxForm(e.target);
            }
        });

        // Handle button clicks
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn-loading')) {
                this.handleLoadingButton(e.target);
            }
        });
    }

    handlePageLoad() {
        // Add page loaded class for animations
        document.body.classList.add('page-loaded');
        
        // Initialize page-specific functionality
        this.initializePageSpecific();
    }

    handleResize() {
        // Handle responsive changes
        this.handleResponsiveSidebar();
    }

    handleAjaxForm(form) {
        const formData = new FormData(form);
        const url = form.action || window.location.href;
        const method = form.method || 'POST';

        // Show loading state
        const submitBtn = form.querySelector('button[type="submit"]');
        if (submitBtn) {
            submitBtn.classList.add('loading');
            submitBtn.disabled = true;
        }

        fetch(url, {
            method: method,
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                NotificationManager.show(data.message || 'Success!', 'success');
                if (data.redirect) {
                    window.location.href = data.redirect;
                }
            } else {
                NotificationManager.show(data.message || 'An error occurred', 'error');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            NotificationManager.show('An error occurred', 'error');
        })
        .finally(() => {
            // Remove loading state
            if (submitBtn) {
                submitBtn.classList.remove('loading');
                submitBtn.disabled = false;
            }
        });
    }

    handleLoadingButton(button) {
        button.classList.add('loading');
        
        // Remove loading state after 2 seconds (or when operation completes)
        setTimeout(() => {
            button.classList.remove('loading');
        }, 2000);
    }

    initializePageSpecific() {
        const page = document.body.getAttribute('data-page');
        
        switch (page) {
            case 'dashboard':
                this.initializeDashboard();
                break;
            case 'leaderboard':
                this.initializeLeaderboard();
                break;
            case 'login':
                this.initializeLogin();
                break;
        }
    }

    initializeDashboard() {
        // Dashboard-specific initialization
        console.log('Initializing dashboard...');
        
        // Initialize charts if Chart.js is available
        if (typeof Chart !== 'undefined') {
            this.initializeCharts();
        }
        
        // Initialize real-time updates
        this.initializeRealTimeUpdates();
    }

    initializeLeaderboard() {
        // Leaderboard-specific initialization
        console.log('Initializing leaderboard...');
        
        // Initialize data tables
        this.initializeDataTables();
    }

    initializeLogin() {
        // Login-specific initialization
        console.log('Initializing login...');
        
        // Initialize form validation
        this.initializeFormValidation();
    }

    initializeCharts() {
        // Chart initialization will be handled in separate chart modules
        console.log('Charts available, initializing...');
    }

    initializeRealTimeUpdates() {
        // Real-time update functionality
        console.log('Initializing real-time updates...');
    }

    initializeDataTables() {
        // Data table functionality
        console.log('Initializing data tables...');
    }

    initializeFormValidation() {
        // Form validation functionality
        console.log('Initializing form validation...');
    }
}

// Notification Manager Class
class NotificationManager {
    constructor() {
        this.container = this.createContainer();
    }

    createContainer() {
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
        }
        return container;
    }

    show(message, type = 'info', duration = 5000) {
        const toast = this.createToast(message, type);
        this.container.appendChild(toast);

        // Show toast
        setTimeout(() => toast.classList.add('show'), 100);

        // Auto remove
        setTimeout(() => this.remove(toast), duration);

        return toast;
    }

    createToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        
        const icons = {
            success: 'fas fa-check-circle',
            error: 'fas fa-exclamation-circle',
            warning: 'fas fa-exclamation-triangle',
            info: 'fas fa-info-circle'
        };

        toast.innerHTML = `
            <div class="toast-content">
                <i class="${icons[type] || icons.info} toast-icon"></i>
                <span class="toast-message">${message}</span>
            </div>
            <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
            <div class="toast-progress"></div>
        `;

        return toast;
    }

    remove(toast) {
        toast.classList.add('hide');
        setTimeout(() => {
            if (toast.parentElement) {
                toast.parentElement.removeChild(toast);
            }
        }, 300);
    }
}

// Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.ModernApp = new ModernApp();
});

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { ModernApp, NotificationManager };
}
function GetGameType() {
    var type = $("#mainGrid").attr("data-value");
    let gameType = "";
    switch (type) {
        case "Competition":
            gameType = "C1";
            break;
    }
    return gameType;
}

function GetHoldingsGrid() {
    var cols = [
        { title:"Stocks", name: "Name", type: "text", width: 20 },
        { title: "Quant.", name:"Count", type: "number", width: 20 },
        { title: "Avg", name: "AveragePrice", type: "number", width: 20 },
        { title: "LTP",name:"Price", type: "number", width: 20 },
        { title:"P/L", name: "ProfitLoss", type: "number", width: 20 }
    ];
    $.ajax({
        url: "/api/UserStocks",
        dataType: "json",
        data: {
            "GameType": GetGameType()
        },
        contentType:"application/json",
        success: function (Data) {
            var listData = JSON.parse(Data).Value.UserStockList;
            if (listData != null && listData.length > 0) {
                listData.forEach(x => {
                    x.ProfitLoss = Number((x.Price - x.AveragePrice) * x.Count).toFixed(2);
                    //if (x.ProfitLoss < 1 && x.ProfitLoss > -1) {
                    //    x.ProfitLoss = 0;
                    //}
                });
            }
                PopulateHoldings("grid", listData, cols, "275px");
                var json = {};
                var total = 0;
                var current = 0;
                var pnl = 0;
                listData.forEach(x => {
                    total += x.AveragePrice * x.Count;
                    current += x.Price * x.Count;
                });
                json.TotalHoldings = total.toFixed(2);
                json.CurrentValue = current.toFixed(2);
                json.ProfitLoss = (current - total).toFixed(2);
                var mycol = [
                    { title: "Total Holdings", name: "TotalHoldings", type: "number", width: 35 },
                    { title: "Current Value", name: "CurrentValue", type: "number", width: 35 },
                    { title: "P/L", name: "ProfitLoss", type: "number", width: 30 }
                ];
                var gridData = [json];

            PopulateHoldings("gridFooter", gridData, mycol, "auto");
        },
        error: function (res) {
            PopulateHoldings("Error");
        }
    });
}

function RegisterForCompetition() {
    $.ajax({
        url: "/api/Enter",
        type: "POST",
        data: JSON.stringify({ "GameType": "C1" }),
        contentType: "application/json",
        success: function (Data) {
            window.location.href = "\Home\Competition";
        },
        error: function (res) {
            alert("House Full, Please try again tomorrow.");
        }
    });
}

function GetWatchListGrid() {
    var cols = [
        { name: "Name", type: "text", width: 50 },
        { name: "Price", type: "number", width: 50 },
        {
            type: "control", modeSwitchButton: false, editButton: false
        }];
    $.ajax({
        url: "/api/UserWatchlist",
        dataType: "json",
        data: {
            "GameType": GetGameType()
        },
        contentType: "application/json",
        success: function (Data) {
            var listData = JSON.parse(Data).Value;
            var grid = "grid2";
            PopulateHoldings(grid,listData,cols);
        },
        error: function (res) {
            PopulateHoldings("Error");
        }
    });
}

function PopulateHoldings(grid,Data,cols,height) {
    if (Data != "Error") {
        if (cols == null || cols == "") {
            cols = [
                { name: "Name", type: "text", width: 40 },
                { name: "Price", type: "number", width: 30 },
                { name: "Count", type: "number", width: 30 }

                //    { name: "Address", type: "text", width: 200 },
                //    { name: "Country", type: "select", items: countries, valueField: "Id", textField: "Name" },
                //    { name: "Married", type: "checkbox", title: "Is Married", sorting: false },
                //    { type: "control" }
            ];
        }
        if (height == null || height == "") {
            height = "400px";
        }

        $("#" + grid).jsGrid({
            width: "100%",
            height: height,
            editing: false,
            sorting: true,
            paging: true,
            data: Data,
            fields: cols,
            onItemDeleting: function (args) {
                DeleteStock(args.item.Name);
            },
            rowClick: function (args) {
                GridOnClick(args);
            }
        });
    }
    else {
        $("#grid").html("Something went Wrong");
    }
}

function GetCompetitionData() {
    $.ajax({
        url: "/api/UserWatchlist",
        dataType: "json",
        data: {
            "GameType": GetGameType()
        },
        contentType: "application/json",
        success: function (Data) {
            PopulateCompetitionResult();
        },
        error: function (res) {
            console.log("Failed : GetCompetitionData");
        }
    });
}

function PopulateCompetitionResult(Data) {

    let cols = [
        { name: "Rank", type: "number", width: 30 },
        { name: "Name", type: "number", width: 30 },
        { name: "Capital", type: "number", width: 30 }
    ];
    $("#competitionResult").jsGrid({
        width: "100%",
        height: height,
        editing: false,
        sorting: false,
        paging: true,
        data: Data,
        fields: cols
    });
}

function GetUserData() {
    GetFunds();
}

function GetFunds() {
    $.ajax({
        type: "GET",
        url: "/api/GetFunds",
        data: {
            "GameType": GetGameType()
        },
        contentType: "application/json",
        success: function (args) {
//            $("#funds").html(Number(args).toFixed(2));
            $("#funds").html((args));
        },
        error: function (args) {
            alert("failed to load funds");
        }
    });
}



function GetRank() {
    $.ajax({
        type: "GET",
        url: "/api/GetRank",
        data: {
            "GameType": GetGameType()
        },
        contentType: "application/json",
        success: function (args) {
            //            $("#funds").html(Number(args).toFixed(2));
            $("#rank").html(args.split(" / ")[0]);
            $("#totalParticipants").html(args.split(" / ")[1]);
        },
        error: function (args) {
            //alert("failed to load rank");
            $("#totalParticipants").html("Network Issue");
        }
    });
}

function OnBuySell(e) {
    var type = e.id=="buyButton" ? 1:0;
    var stock = $("#mStock").html();
    var price = $("#mPrice").html();
    var quantity = $("#mQuantity").val();
    if (quantity > 0) {
        //$('#myModal').modal('toggle');
        if (type != 1) {
            quantity *= -1;
        }
        ExecuteOrder(stock, price, quantity);
    }
    else {
        alert("Please enter Quant. > 0.");
    }
}

function ExecuteOrder(stock, price, quantity) {
    var OrderData = {};
    OrderData.Stock = stock;
    OrderData.Price = price;
    OrderData.Quantity = Number(quantity);
    OrderData.GameType = GetGameType();
    $("#buyButton").prop("disabled", true);
    $("#sellButton").prop("disabled", true);

    $.ajax({
        url: "/api/ExecuteOrder",
        type: "POST",
        data: JSON.stringify(OrderData),
        contentType: "application/json",
        success: function (Data) {
            $('#myModal').modal('toggle');
            GetFunds();
        },
        error: function (res) {
            $("#buyButton").prop("disabled", false);
            $("#sellButton").prop("disabled", false);
            alert("Order Execution Fail.");
        }
    });
}

function GridOnClick(data) {
    var item = data.item;
    var Stock = item.Name;
    var Low = item.Low;
    var High = item.High;
    var Price = item.Price;
    var Open = item.Open;
    var Close = item.Close;
    $("#mHigh").html(High);
    $("#mLow").html(Low);
    $("#mLastClose").html(Close);
    $("#mOpen").html(Open);
    $("#mStock").html(Stock);
    $("#mPrice").html(Price);
    $("#buyButton").prop("disabled", false);
    $("#sellButton").prop("disabled", false);
    $('#myModal').modal('toggle');
}

function DynamicSearch() {
    var URL = "/api/AllStocks";
 
    $("#SearchStocks").select2({
        ajax: {
            url: URL,
            delay: 250,
            data: function (params) {
                var lData = {};
                lData.item = params.term;
                return lData;                
            },
            processResults: function (data, params) {
                // parse the results into the format expected by Select2
                // since we are using custom formatting functions we do not need to
                // alter the remote JSON data, except to indicate that infinite
                // scrolling can be used
                params.page = params.page || 1;

                return {
                    results: JSON.parse(data).Value
                };
            },
            cache: true
        },
        placeholder: 'Search for Equity',
        minimumInputLength: 1,
        templateResult: formatRepo,
        templateSelection: formatRepoSelection
    });
    }

function formatRepo(repo) {
   

    var $container = $(
        "<div id = '" + repo.Symbol + "'><span>" + repo.Symbol + "</span><span style='float:right' class='badge' onclick='AddStock(this)'>Add</span></div>"
    );

    return $container;
}

function DeleteStock(stock) {
    var actionData = {};
    actionData.Stock = stock;
    actionData.AddDel = 0;
    actionData.GameType = GetGameType();


    $.ajax({
        url: "/api/AddDelete",
        type: "GET",
        data: (actionData),
        contentType: "application/json",
        success: function (Data) {
            console.log("Deleted " + Data);
        },
        error: function (res) {
            alert("Deleting failed");
        }
    });
}

function AddStock(e) {
    var symbol = e.parentElement.id;
    var actionData = {};
    actionData.Stock = symbol;
    actionData.AddDel = 1;
    actionData.GameType = GetGameType();

    $.ajax({
        url: "/api/AddDelete",
        type: "GET",
        data: (actionData),        
        contentType: "application/json",
        success: function (Data) {
            GetWatchListGrid();
        },
        error: function (res) {
            alert("Adding failed");
        }
    });

}


function formatRepoSelection(repo) {
    return repo.Symbol;
}